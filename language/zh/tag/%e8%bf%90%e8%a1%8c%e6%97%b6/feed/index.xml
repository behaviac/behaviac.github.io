<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>运行时 &#8211; behaviac</title>
	<atom:link href="./../../%E8%BF%90%E8%A1%8C%E6%97%B6/feed/index.html" rel="self" type="application/rss+xml" />
	<link>./../../../../../index.html</link>
	<description>Tencent behaviac, Game AI, Behavior Tree, Finite State Machine, Hierarchical Task Network, BT FSM HTN, 腾讯开源, 游戏AI, 行为树,有限状态机,分层任务网络</description>
	<lastBuildDate>Thu, 23 Feb 2017 08:05:20 +0000</lastBuildDate>
	<language>zh-CN</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>https://wordpress.org/?v=5.4.1</generator>

<image>
	<url>./../../../../../wp-content/uploads/2016/04/cropped-256x256-32x32.png</url>
	<title>运行时 &#8211; behaviac</title>
	<link>./../../../../../index.html</link>
	<width>32</width>
	<height>32</height>
</image> 
	<item>
		<title>VS项目中使用behaviac组件</title>
		<link>./../../../../../cpp_include/index.html</link>
					<comments>./../../../../../cpp_include/index.html#comments</comments>
		
		<dc:creator><![CDATA[admin]]></dc:creator>
		<pubDate>Fri, 13 May 2016 02:44:04 +0000</pubDate>
				<category><![CDATA[文章]]></category>
		<category><![CDATA[上手]]></category>
		<category><![CDATA[C++]]></category>
		<category><![CDATA[编译构建]]></category>
		<category><![CDATA[运行时]]></category>
		<guid isPermaLink="false">./../../../../../index.html?p=311</guid>

					<description><![CDATA[下载完behaviac组件的全部源码后，整个组件的目录结构，如下图所示： 将behaviac组件整合到自己的项目中时，可以通过两种方式使用behaviac组件：<a class="moretag" href="./../../../../../cpp_include/index.html">Read More...</a>]]></description>
										<content:encoded><![CDATA[<p id="cbehaviac">下载完behaviac组件的全部源码后，整个组件的目录结构，如下图所示：</p>
<p><img src="./../../../../../img/tutorials/tutorial16/sourceFolder.png" alt="" /></p>
<p>将behaviac组件整合到自己的项目中时，可以通过两种方式使用behaviac组件：</p>
<ul>
<li>将全部源码（包括behaviac组件的所有<a href="https://github.com/Tencent/behaviac/blob/master/inc/behaviac">.h</a>和<a href="https://github.com/Tencent/behaviac/blob/master/src">.cpp</a>文件）全部复制到自己的游戏项目中。</li>
<li>单独编译behaviac组件库，生成lib文件，然后自己的项目包含.h文件和生成的.lib文件。</li>
</ul>
<p>对于上面的第二种用法，请先参考<a href="./../../../../../docs/zh/tutorials/how_to_build/index.html">如何编译构建</a>文档来编译构建behavaic组件。</p>
<p>在Windows平台，如果是使用VS来管理项目的，需要在VS的项目“Property Pages”-&gt;“Configuration Properties”-&gt;“C/C++”-&gt;“General”中的“Additional Include Directories”项中添加behaviac组件头文件（即图1中的inc文件夹）所在的路径，如下图所示：</p>
<p><img src="./../../../../../img/tutorials/tutorial16/includeHeaderSettings.png" alt="" /></p>
<p>再在VS的项目“Property Pages”-&gt;“Configuration Properties”-&gt;“Linker”-&gt;“General”中的“Additional Library Directories”项中添加自己编译出的behaviac lib文件（即图1中的lib文件夹）所在的路径，如下图所示：</p>
<p><img src="./../../../../../img/tutorials/tutorial16/includeLibSettings.png" alt="" /></p>
<p>最后在VS的项目“Property Pages”-&gt;“Configuration Properties”-&gt;“Linker”-&gt;“Input”中的“Additional Dependencies”项中添加自己编译出的behaviac lib文件，如下图所示：</p>
<p><img src="./../../../../../img/tutorials/tutorial16/addLibSettings.png" alt="" /></p>
<p>注意：上图中的behaviac_debugdll_win32_vs2010.lib文件是用VS2010编译出来的，说明游戏项目也需要用VS2010来编译。如果你的游戏项目使用其他版本的VS，则编译behaviac组件也需要用相应版本的VS来编译。</p>
]]></content:encoded>
					
					<wfw:commentRss>./../../../../../cpp_include/feed/index.html</wfw:commentRss>
			<slash:comments>3</slash:comments>
		
		
			</item>
		<item>
		<title>C++运行时端的使用上手</title>
		<link>./../../../../../tutorial14_cpp_workflow/index.html</link>
					<comments>./../../../../../tutorial14_cpp_workflow/index.html#comments</comments>
		
		<dc:creator><![CDATA[admin]]></dc:creator>
		<pubDate>Fri, 13 May 2016 02:21:24 +0000</pubDate>
				<category><![CDATA[3.5]]></category>
		<category><![CDATA[上手]]></category>
		<category><![CDATA[C++]]></category>
		<category><![CDATA[运行时]]></category>
		<guid isPermaLink="false">./../../../../../index.html?p=273</guid>

					<description><![CDATA[运行时（游戏）端使用行为树之前，需要确保行为树文件已经成功导出。 如何注册和导出类型信息请参考C++类型信息的注册和导出，如何导出行为树请参考导出和使用XML/<a class="moretag" href="./../../../../../tutorial14_cpp_workflow/index.html">Read More...</a>]]></description>
										<content:encoded><![CDATA[<p id="c">运行时（游戏）端使用行为树之前，需要确保行为树文件已经成功导出。</p>
<p>如何注册和导出类型信息请参考<a href="./../../../../../docs/zh/tutorials/tutorial3_1_meta_cpp_register/index.html">C++类型信息的注册和导出</a>，如何导出行为树请参考<a href="./../../../../../docs/zh/tutorials/tutorial4_1_export_xml_bson/index.html">导出和使用XML/BSON行为树</a>。</p>
<p>通过编辑器导出行为树文件后，运行时端的执行主要分为三个部分：</p>
<ul>
<li>初始化</li>
<li>循环更新</li>
<li>清理</li>
</ul>
<h3 id="section"><span class="ez-toc-section" id="1">1 初始化</span></h3>
<p>在游戏的初始化函数中，添加初始化behaviac组件所需的功能，例如注册Agent子类信息、设置行为树文件的加载路径和文件格式、创建Agent子类的实例、加载行为树并设置当前所需执行的行为树等。</p>
<p>如下代码所示：</p>
<div class="highlighter-rouge">
<pre class="highlight"><code><span class="n">bool</span> <span class="nf">InitBehavic</span><span class="p">(</span><span class="n">behaviac</span><span class="o">::</span><span class="n">Workspace</span><span class="o">::</span><span class="n">EFileFormat</span> <span class="n">ff</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">behaviac</span><span class="o">::</span><span class="n">Config</span><span class="o">::</span><span class="n">SetSocketBlocking</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>
    <span class="n">behaviac</span><span class="o">::</span><span class="n">Config</span><span class="o">::</span><span class="n">SetSocketPort</span><span class="p">(</span><span class="mi">8081</span><span class="p">);</span>

    <span class="n">behaviac</span><span class="o">::</span><span class="n">Agent</span><span class="o">::</span><span class="n">Register</span><span class="o">&lt;</span><span class="n">CBTPlayer</span><span class="o">&gt;</span><span class="p">();</span>

    <span class="n">behaviac</span><span class="o">::</span><span class="n">Workspace</span><span class="o">::</span><span class="n">GetInstance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">SetFilePath</span><span class="p">(</span><span class="s">"../test/demo_running/behaviac/exported"</span><span class="p">);</span>
    <span class="n">behaviac</span><span class="o">::</span><span class="n">Workspace</span><span class="o">::</span><span class="n">GetInstance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">SetFileFormat</span><span class="p">(</span><span class="n">ff</span><span class="p">);</span>

    <span class="n">behaviac</span><span class="o">::</span><span class="n">Workspace</span><span class="o">::</span><span class="n">GetInstance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">ExportMetas</span><span class="p">(</span><span class="s">"../test/demo_running/behaviac/demo_running.xml"</span><span class="p">);</span>

    <span class="c1">//behaviac::Agent::SetIdMask(kIdMask_Wolrd | kIdMask_Opponent);
</span>    <span class="n">behaviac</span><span class="o">::</span><span class="n">Workspace</span><span class="o">::</span><span class="n">GetInstance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">SetDeltaFrames</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">bool</span> <span class="nf">InitPlayer</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">pszTreeName</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">g_player</span> <span class="o">=</span> <span class="n">behaviac</span><span class="o">::</span><span class="n">Agent</span><span class="o">::</span><span class="n">Create</span><span class="o">&lt;</span><span class="n">CBTPlayer</span><span class="o">&gt;</span><span class="p">();</span>

    <span class="n">bool</span> <span class="n">bRet</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="n">bRet</span> <span class="o">=</span> <span class="n">g_player</span><span class="o">-&gt;</span><span class="n">btload</span><span class="p">(</span><span class="n">pszTreeName</span><span class="p">);</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">bRet</span><span class="p">);</span>

    <span class="n">g_player</span><span class="o">-&gt;</span><span class="n">btsetcurrent</span><span class="p">(</span><span class="n">pszTreeName</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">bRet</span><span class="p">;</span>
<span class="p">}</span>

</code></pre>
</div>
<div class="note info">
<h5><span class="ez-toc-section" id="i">关于文件路径的说明</span></h5>
</div>
<ul>
<li>Workspace::SetFilePath指定的是编辑器中Workspace的导出路径，可以是绝对路径。当指定的是相对路径的时候，相对的是当前<strong>工作路径</strong>（一般都是运行程序所在目录）。</li>
<li>Agent::btload使用的文件名是相对于Workspace::SetFilePath指定的路径，没有扩展名，可以有目录结构的层次化文件名，如“node_test/selector_loop_ut_7”。在编辑器中打开某个行为树后，右键文件页选取“复制文件名”获取。</li>
</ul>
<p><img src="./../../../../../img/tutorials/tutorial14/copy_filepath.png" alt="copy_filepath" /></p>
<ul>
<li>例如：
<ul>
<li>如果运行程序所在目录（或者VS里指定的工作路径$(TargetDir)）是”D:\Test\bin”</li>
<li>Workspace::SetFilePath指定的相对路径是“../behaviac/workspace/exported”</li>
<li>btload指定是“node_test/selector_loop_ut_7”</li>
<li>则workspace的导出路径实际是“D:/Test/behaviac/workspace/exported”，<br />
而相应的导出行为树文件是“D:/Test/behaviac/workspace/exported/node_test/selector_loop_ut_7.xml”或<br />
“D:/Test/behaviac/workspace/exported/node_test/selector_loop_ut_7.bson.bytes”。</li>
<li>具体是xml或bson则由Workspace::SetFileFormat确定。</li>
<li>当指定格式是cpp或c#的时候，导出的行为树是cpp或c#源码，已经编译构建进可执行程序，Agent::btload指定的文件名（跟xml的用法一样，无需修改btload的参数）只是用来标识该行为树的，从而代码可以据此创建相应的行为树，不像xml或bson格式的时候需要加载数据文件。</li>
</ul>
</li>
<li>如果Agent::btload加载失败，请注意检查当前路径，Workspace::SetFilePath设定的导出路径，以及Agent::btload指定的文件标识。还可以在当前路径里检查log文件<code class="highlighter-rouge">_behaviac_$_$_.log</code></li>
</ul>
<h3 id="section-1"><span class="ez-toc-section" id="2">2 循环更新</span></h3>
<p>在游戏的主循环中，添加执行Agent实例的行为树相关代码，也即通过调用Agent类的接口btexec()或Workspace类的接口Update()来执行行为树。</p>
<p>这两种执行方式的区别，请参考<a href="./../../../../../docs/zh/tutorials/tutorial13_updateloop/index.html">更新流程</a>。</p>
<p>如下代码样例所示：</p>
<div class="highlighter-rouge">
<pre class="highlight"><code>
<span class="kt">void</span> <span class="nf">UpdateLoop</span><span class="p">()</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span>  <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">frames</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">behaviac</span><span class="o">::</span><span class="n">EBTStatus</span> <span class="n">status</span> <span class="o">=</span> <span class="n">behaviac</span><span class="o">::</span><span class="n">BT_RUNNING</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="n">behaviac</span><span class="o">::</span><span class="n">BT_RUNNING</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"frame "</span> <span class="o">&lt;&lt;</span> <span class="o">++</span><span class="n">frames</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">g_player</span><span class="o">-&gt;</span><span class="n">btexec</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>

</code></pre>
</div>
<h3 id="section-2"><span class="ez-toc-section" id="3">3 清理</span></h3>
<p>最后的清理过程，包括销毁Agent子类的实例，以及反注册Agent子类信息等。</p>
<p>如下代码样例所示：</p>
<div class="highlighter-rouge">
<pre class="highlight"><code>
<span class="kt">void</span> <span class="nf">CleanupPlayer</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">behaviac</span><span class="o">::</span><span class="n">Agent</span><span class="o">::</span><span class="n">Destroy</span><span class="p">(</span><span class="n">g_player</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">CleanupBehaviac</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">behaviac</span><span class="o">::</span><span class="n">Agent</span><span class="o">::</span><span class="n">UnRegister</span><span class="o">&lt;</span><span class="n">CBTPlayer</span><span class="o">&gt;</span><span class="p">();</span>

	<span class="n">behaviac</span><span class="o">::</span><span class="n">Workspace</span><span class="o">::</span><span class="n">GetInstance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">Cleanup</span><span class="p">();</span>
<span class="p">}</span>

</code></pre>
</div>
<p>以上步骤的完整代码，请参考<a href="https://github.com/Tencent/behaviac/blob/master/test/demo_running/demo_running.cpp">demo_running.cpp</a>文件。</p>
]]></content:encoded>
					
					<wfw:commentRss>./../../../../../tutorial14_cpp_workflow/feed/index.html</wfw:commentRss>
			<slash:comments>2</slash:comments>
		
		
			</item>
		<item>
		<title>C++运行时端中元信息的注册和导出</title>
		<link>./../../../../../tutorial3_1_meta_cpp_register/index.html</link>
					<comments>./../../../../../tutorial3_1_meta_cpp_register/index.html#comments</comments>
		
		<dc:creator><![CDATA[admin]]></dc:creator>
		<pubDate>Fri, 13 May 2016 02:23:51 +0000</pubDate>
				<category><![CDATA[3.5]]></category>
		<category><![CDATA[上手]]></category>
		<category><![CDATA[C++]]></category>
		<category><![CDATA[运行时]]></category>
		<guid isPermaLink="false">./../../../../../index.html?p=276</guid>

					<description><![CDATA[behaviac组件的基本运作机制就是在运行时端（C++）和编辑器通过元信息进行交互，如图1所示。其中，元信息里面包含了类自身的描述、属性、方法及类的实例等。 <a class="moretag" href="./../../../../../tutorial3_1_meta_cpp_register/index.html">Read More...</a>]]></description>
										<content:encoded><![CDATA[<p id="c">behaviac组件的基本运作机制就是在运行时端（C++）和编辑器通过元信息进行交互，如图1所示。其中，元信息里面包含了类自身的描述、属性、方法及类的实例等。</p>
<p><img class="aligncenter" src="./../../../../../img/overview/meta.png" alt="" /></p>
<p style="text-align: center;">图1 基于元信息的编辑器和运行时端的交互</p>
<p>在运行时端，也即游戏代码端，通过注册（C++通过宏的方式）并导出供行为树引擎和编辑器使用的XML元信息。运行时端主要是由程序员编写Agent的子类及其属性和方法，然后调用相关接口将这些元信息导出，就可以在编辑器中对这些元信息进行使用。</p>
<p>在编辑器中也可以创建和编辑元信息。在项目开始初期，也就是程序员还没把代码写出来之前，策划就可以自己手动的创建一些Agent子类、属性和方法等元信息。这样可以加速游戏原型的创建，也就是策划不用等程序员，就可以进行游戏原型的编辑。</p>
<p>整个工作流程主要分为以下几个步骤：</p>
<h3 id="section">1 注册元信息</h3>
<ul>
<li>在.h文件中，根据项目需要按以下步骤编写自己的游戏类：
<ul>
<li>首先需要包含头文件#include “behaviac/behaviac.h”。</li>
<li>该类需要从behaviac::Agent基类继承。</li>
<li>首先用宏DECLARE_BEHAVIAC_AGENT声明该类及其父类，用于行为树引擎内部的反射系统所需的类型信息。</li>
<li>为该类添加必要的属性和方法等。</li>
</ul>
</li>
</ul>
<p>如下代码样例所示：</p>
<div class="highlighter-rouge">
<pre class="highlight"><code>
<span class="cp">#include "behaviac/behaviac.h"
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">behaviac</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">CBTPlayer</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Agent</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">DECLARE_BEHAVIAC_AGENT</span><span class="p">(</span><span class="n">CBTPlayer</span><span class="p">,</span> <span class="n">Agent</span><span class="p">);</span>

    <span class="n">CBTPlayer</span><span class="p">();</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">CBTPlayer</span><span class="p">();</span>

    <span class="kt">time_t</span> <span class="n">GetCurTime</span><span class="p">();</span>
    <span class="n">bool</span> <span class="n">Condition</span><span class="p">();</span>
    <span class="n">behaviac</span><span class="o">::</span><span class="n">EBTStatus</span> <span class="n">Action1</span><span class="p">();</span>
    <span class="n">EBTStatus</span> <span class="n">Action3</span><span class="p">();</span>

<span class="k">private</span><span class="o">:</span>
    <span class="kt">int</span>                 <span class="n">m_iX</span><span class="p">;</span>
    <span class="kt">int</span>                 <span class="n">m_iY</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">int</span>        <span class="n">m_iBaseSpeed</span><span class="p">;</span>
    <span class="kt">int</span>					<span class="n">m_Frames</span><span class="p">;</span>
<span class="p">};</span>

</code></pre>
</div>
<ul>
<li>在.cpp文件中，通过一系列宏来注册该类自身的描述及其属性与方法：
<ul>
<li>宏BEGIN_PROPERTIES_DESCRIPTION和END_PROPERTIES_DESCRIPTION表示类型信息注册的开始和结束。</li>
<li>宏CLASS_DISPLAYNAME和CLASS_DESC用于注册类自身的显示名和描述。</li>
<li>宏REGISTER_PROPERTY用于注册类的属性，可以通过.DISPLAYNAME的追加方式为属性添加显示名，通过.DESC的追加方式为属性添加描述。</li>
<li>宏REGISTER_METHOD用于注册类的方法，可以通过.DISPLAYNAME的追加方式为方法添加显示名，通过.DESC的追加方式为方法添加描述，通过.PARAM_DISPLAY_INFO的追加方式为参数添加显示名和描述等。如果参数类型是数值类型（例如int、unsigned int、float等），.PARAM_DISPLAY _INFO还可以用来指定参数的有效范围。</li>
</ul>
</li>
</ul>
<p>如下代码样例所示：</p>
<div class="highlighter-rouge">
<pre class="highlight"><code>
<span class="n">BEGIN_PROPERTIES_DESCRIPTION</span><span class="p">(</span><span class="n">CBTPlayer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">REGISTER_PROPERTY</span><span class="p">(</span><span class="n">m_iBaseSpeed</span><span class="p">);</span>

	<span class="n">REGISTER_METHOD</span><span class="p">(</span><span class="n">Condition</span><span class="p">);</span>
	<span class="n">REGISTER_METHOD</span><span class="p">(</span><span class="n">Action1</span><span class="p">);</span>
	<span class="n">REGISTER_METHOD</span><span class="p">(</span><span class="n">Action3</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">END_PROPERTIES_DESCRIPTION</span><span class="p">()</span>

</code></pre>
</div>
<h3 id="section-1">2 导出元信息</h3>
<p>注册完类信息之后，按以下步骤导出元数据文件：</p>
<ul>
<li>在初始化函数里，添加Agent::Register&lt;***&gt;()用于注册类信息到引擎库中。</li>
<li>通过Agent::RegisterInstanceName&lt;***&gt;(…)来注册类的实例名。</li>
<li>调用Workspace::GetInstance()-&gt;SetFilePath(…)设置元信息文件导出的位置。</li>
<li>调用Workspace::GetInstance()-&gt;ExportMetas(…)导出元信息文件。</li>
<li>在释放函数里，添加Agent::Unregister&lt;***&gt;()用于释放类型的注册信息。</li>
</ul>
<p>如下代码样例所示：</p>
<div class="highlighter-rouge">
<pre class="highlight"><code>
<span class="n">bool</span> <span class="nf">InitBehavic</span><span class="p">(</span><span class="n">behaviac</span><span class="o">::</span><span class="n">Workspace</span><span class="o">::</span><span class="n">EFileFormat</span> <span class="n">ff</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">behaviac</span><span class="o">::</span><span class="n">Config</span><span class="o">::</span><span class="n">SetSocketBlocking</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>
    <span class="n">behaviac</span><span class="o">::</span><span class="n">Config</span><span class="o">::</span><span class="n">SetSocketPort</span><span class="p">(</span><span class="mi">8081</span><span class="p">);</span>

    <span class="n">behaviac</span><span class="o">::</span><span class="n">Agent</span><span class="o">::</span><span class="n">Register</span><span class="o">&lt;</span><span class="n">CBTPlayer</span><span class="o">&gt;</span><span class="p">();</span>

    <span class="n">behaviac</span><span class="o">::</span><span class="n">Workspace</span><span class="o">::</span><span class="n">GetInstance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">SetFilePath</span><span class="p">(</span><span class="s">"../test/demo_running/behaviac/exported"</span><span class="p">);</span>
    <span class="n">behaviac</span><span class="o">::</span><span class="n">Workspace</span><span class="o">::</span><span class="n">GetInstance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">SetFileFormat</span><span class="p">(</span><span class="n">ff</span><span class="p">);</span>

    <span class="n">behaviac</span><span class="o">::</span><span class="n">Workspace</span><span class="o">::</span><span class="n">GetInstance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">ExportMetas</span><span class="p">(</span><span class="s">"../test/demo_running/behaviac/demo_running.xml"</span><span class="p">);</span>

    <span class="c1">//behaviac::Agent::SetIdMask(kIdMask_Wolrd | kIdMask_Opponent);
</span>    <span class="n">behaviac</span><span class="o">::</span><span class="n">Workspace</span><span class="o">::</span><span class="n">GetInstance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">SetDeltaFrames</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">CleanupBehaviac</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">behaviac</span><span class="o">::</span><span class="n">Agent</span><span class="o">::</span><span class="n">UnRegister</span><span class="o">&lt;</span><span class="n">CBTPlayer</span><span class="o">&gt;</span><span class="p">();</span>
<span class="n">    behaviac</span><span class="o">::</span><span class="n">Workspace</span><span class="o">::</span><span class="n">GetInstance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">Cleanup</span><span class="p">();</span>
<span class="p">}</span>

</code></pre>
</div>
<p>更多细节可以参考behaviac组件C++源码中附带的test/demo_running工程的<a href="https://github.com/Tencent/behaviac/blob/master/test/demo_running/demo_running.cpp">demo_running.cpp</a>文件。</p>
]]></content:encoded>
					
					<wfw:commentRss>./../../../../../tutorial3_1_meta_cpp_register/feed/index.html</wfw:commentRss>
			<slash:comments>2</slash:comments>
		
		
			</item>
		<item>
		<title>C#运行时端中元信息的注册和导出</title>
		<link>./../../../../../tutorial3_2_meta_cs_register/index.html</link>
					<comments>./../../../../../tutorial3_2_meta_cs_register/index.html#respond</comments>
		
		<dc:creator><![CDATA[admin]]></dc:creator>
		<pubDate>Fri, 13 May 2016 02:25:57 +0000</pubDate>
				<category><![CDATA[3.5]]></category>
		<category><![CDATA[unity]]></category>
		<category><![CDATA[上手]]></category>
		<category><![CDATA[运行时]]></category>
		<guid isPermaLink="false">./../../../../../index.html?p=278</guid>

					<description><![CDATA[behaviac组件的基本运作机制就是在运行时端（C#）和编辑器通过元信息进行交互，如图1所示。其中，元信息里面包含了类自身的描述、属性、方法及类的实例等。 图<a class="moretag" href="./../../../../../tutorial3_2_meta_cs_register/index.html">Read More...</a>]]></description>
										<content:encoded><![CDATA[<p id="c-">behaviac组件的基本运作机制就是在运行时端（C#）和编辑器通过元信息进行交互，如图1所示。其中，元信息里面包含了类自身的描述、属性、方法及类的实例等。</p>
<p><img class="aligncenter" src="./../../../../../img/overview/meta.png" alt="" /></p>
<p style="text-align: center;">图1 基于元信息的编辑器和运行时端的交互</p>
<p>在运行时端，也即游戏代码端，通过注册（C#通过标记Attribute的方式）并导出供行为树引擎和编辑器使用的XML元信息。运行时端主要是由程序员编写Agent的子类及其属性和方法，然后调用相关接口将这些元信息导出，就可以在编辑器中对这些元信息进行使用。</p>
<p>在编辑器中也可以创建和编辑元信息。在项目开始初期，也就是程序员还没把代码写出来之前，策划就可以自己手动的创建一些Agent子类、属性和方法等元信息。这样可以加速游戏原型的创建，也就是策划不用等程序员，就可以进行游戏原型的编辑。</p>
<p>整个工作流程主要分为以下几个步骤：</p>
<h3 id="section">1 注册元信息</h3>
<p>C#中编写的游戏类从behaviac.Agent派生，并通过相关的Attribute来标记元信息：</p>
<ul>
<li>类：TypeMetaInfo</li>
<li>成员属性：MemberMetaInfo</li>
<li>成员方法：MethodMetaInfo</li>
</ul>
<p>这3个类都可以接受诸如显示名字，描述等更多参数。详细请参考代码。</p>
<p>如下代码样例所示：</p>
<figure class="highlight">
<pre><code class="language-cs" data-lang="cs"><span class="na">[behaviac.TypeMetaInfo()]</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">AgentNodeTest</span> <span class="p">:</span> <span class="n">behaviac</span><span class="p">.</span><span class="n">Agent</span>
<span class="p">{</span>
    <span class="p">[</span><span class="n">behaviac</span><span class="p">.</span><span class="nf">MemberMetaInfo</span><span class="p">()]</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">testVar_0</span> <span class="p">=</span> <span class="p">-</span><span class="m">1</span><span class="p">;</span>

    <span class="p">[</span><span class="n">behaviac</span><span class="p">.</span><span class="nf">MemberMetaInfo</span><span class="p">(</span><span class="s">"testVar_1"</span><span class="p">,</span> <span class="s">"testVar_1 property"</span><span class="p">,</span> <span class="m">100</span><span class="p">)]</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">testVar_1</span> <span class="p">=</span> <span class="p">-</span><span class="m">1</span><span class="p">;</span>

    <span class="p">[</span><span class="n">behaviac</span><span class="p">.</span><span class="nf">MemberMetaInfo</span><span class="p">()]</span>
    <span class="k">public</span> <span class="kt">float</span> <span class="n">testVar_2</span> <span class="p">=</span> <span class="p">-</span><span class="m">1.0f</span><span class="p">;</span>

    <span class="p">[</span><span class="n">behaviac</span><span class="p">.</span><span class="nf">MemberMetaInfo</span><span class="p">()]</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">waiting_timeout_interval</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>

    <span class="p">[</span><span class="n">behaviac</span><span class="p">.</span><span class="nf">MemberMetaInfo</span><span class="p">()]</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">testVar_str_0</span> <span class="p">=</span> <span class="kt">string</span><span class="p">.</span><span class="n">Empty</span><span class="p">;</span>

    <span class="k">public</span> <span class="kt">bool</span> <span class="n">m_bCanSee</span> <span class="p">=</span> <span class="k">false</span><span class="p">;</span>

    <span class="p">[</span><span class="n">behaviac</span><span class="p">.</span><span class="nf">MethodMetaInfo</span><span class="p">()]</span>
    <span class="k">public</span> <span class="k">void</span> <span class="nf">setEventVarInt</span><span class="p">(</span><span class="kt">int</span> <span class="n">var</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">event_test_var_int</span> <span class="p">=</span> <span class="n">var</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="p">[</span><span class="n">behaviac</span><span class="p">.</span><span class="nf">MethodMetaInfo</span><span class="p">()]</span>
    <span class="k">public</span> <span class="k">void</span> <span class="nf">setEventVarBool</span><span class="p">(</span><span class="kt">bool</span> <span class="n">var</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">event_test_var_bool</span> <span class="p">=</span> <span class="n">var</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre>
</figure>
<h3 id="section-1">2 导出元信息</h3>
<p>由于C#代码中已经包含了各种Attribute来描述元信息，因而导出相比C++要简单：</p>
<ul>
<li>Agent子类的实例通过Agent.RegisterInstanceName&lt;***&gt;(…)来进行注册。</li>
<li>调用Workspace.Instance.FilePath设置元信息文件导出的位置。</li>
<li>调用Workspace.Instance.ExportMetas(…)导出元信息文件。</li>
</ul>
<p>如下代码样例所示：</p>
<figure class="highlight">
<pre><code class="language-cs" data-lang="cs"><span class="k">public</span> <span class="kt">bool</span> <span class="nf">Init</span> <span class="p">()</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ms_fileSystem</span> <span class="p">==</span> <span class="k">null</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">ms_fileSystem</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">BehaviacFileManager</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="c1">//&lt; write log file
</span>    <span class="n">behaviac</span><span class="p">.</span><span class="n">Config</span><span class="p">.</span><span class="n">IsLogging</span> <span class="p">=</span> <span class="k">true</span><span class="p">;</span>
    <span class="c1">//behaviac.Config.IsSocketing = false;
</span>
    <span class="n">behaviac</span><span class="p">.</span><span class="n">Workspace</span><span class="p">.</span><span class="n">Instance</span><span class="p">.</span><span class="n">FilePath</span> <span class="p">=</span> <span class="k">this</span><span class="p">.</span><span class="n">WorkspaceExportPath</span><span class="p">;</span>
    <span class="n">behaviac</span><span class="p">.</span><span class="n">Workspace</span><span class="p">.</span><span class="n">Instance</span><span class="p">.</span><span class="n">FileFormat</span> <span class="p">=</span> <span class="n">behaviac</span><span class="p">.</span><span class="n">Workspace</span><span class="p">.</span><span class="n">EFileFormat</span><span class="p">.</span><span class="n">EFF_xml</span><span class="p">;</span>

    <span class="c1">//register names
</span>    <span class="n">behaviac</span><span class="p">.</span><span class="n">Agent</span><span class="p">.</span><span class="n">RegisterInstanceName</span><span class="p">&lt;</span><span class="n">GameLevelCommon</span><span class="p">&gt;(</span><span class="s">"GameLevel"</span><span class="p">);</span>
    <span class="n">behaviac</span><span class="p">.</span><span class="n">Workspace</span><span class="p">.</span><span class="n">Instance</span><span class="p">.</span><span class="nf">ExportMetas</span><span class="p">(</span><span class="s">"behaviac/workspace/xmlmeta/BattleCityMeta.xml"</span><span class="p">);</span>

    <span class="n">behaviac</span><span class="p">.</span><span class="n">Debug</span><span class="p">.</span><span class="nf">Log</span><span class="p">(</span><span class="s">"Behaviac meta data export over."</span><span class="p">);</span>
    <span class="n">behaviac</span><span class="p">.</span><span class="n">Agent</span><span class="p">.</span><span class="nf">SetIdMask</span><span class="p">(</span><span class="m">0xffffffff</span><span class="p">);</span>

    <span class="k">return</span> <span class="k">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">void</span> <span class="nf">Uninit</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">behaviac</span><span class="p">.</span><span class="n">Workspace</span><span class="p">.</span><span class="n">Instance</span><span class="p">.</span><span class="nf">Cleanup</span><span class="p">();</span>
<span class="p">}</span></code></pre>
</figure>
<p>更多细节可以参考behaviac组件C#源码中附带的integration/BattleCityDemo工程的<a href="https://github.com/Tencent/behaviac/blob/master/integration/BattleCityDemo/Assets/Scripts/BehaviacSystem.cs">BehaviacSystem.cs</a>文件。</p>
]]></content:encoded>
					
					<wfw:commentRss>./../../../../../tutorial3_2_meta_cs_register/feed/index.html</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>导出和使用XML/BSON行为树</title>
		<link>./../../../../../tutorial4_1_export_xml_bson/index.html</link>
					<comments>./../../../../../tutorial4_1_export_xml_bson/index.html#respond</comments>
		
		<dc:creator><![CDATA[admin]]></dc:creator>
		<pubDate>Fri, 13 May 2016 02:27:46 +0000</pubDate>
				<category><![CDATA[3.5]]></category>
		<category><![CDATA[unity]]></category>
		<category><![CDATA[上手]]></category>
		<category><![CDATA[C++]]></category>
		<category><![CDATA[运行时]]></category>
		<guid isPermaLink="false">./../../../../../index.html?p=282</guid>

					<description><![CDATA[目前behaviac组件支持4种文件格式（XML、BSON、C++和C#）行为树的导出。在项目开发过程中，建议使用XML格式的导出文件，以便于调试和查错等；而在<a class="moretag" href="./../../../../../tutorial4_1_export_xml_bson/index.html">Read More...</a>]]></description>
										<content:encoded><![CDATA[<p id="section">目前behaviac组件支持4种文件格式（XML、BSON、C++和C#）行为树的导出。在项目开发过程中，建议使用XML格式的导出文件，以便于调试和查错等；而在最终的发布（release）版本中，可以导出C++或C#格式的行为树文件，以便提高运行效率。</p>
<h3 id="xmlbson">导出和使用XML/BSON行为树</h3>
<ul>
<li>在编辑器中导出整个工作区文件，在“导出行为树”对话框中，勾选“Xml Behavior Exporter”或“Bson Behavior Exporter”，如下图所示：</li>
</ul>
<p><img class="aligncenter" src="./../../../../../img/tutorials/tutorial4/exportXMLBson.png" alt="" /></p>
<ul>
<li>导出行为树文件结束后，回到运行时（游戏）代码端，按以下步骤使用行为树文件：
<ul>
<li>在游戏的初始化函数中，添加Agent::Register&lt;***&gt;()注册类信息到引擎库中。</li>
<li>调用Workspace::SetFilePath(…)函数，设置行为树文件的加载路径，也即编辑器导出行为树文件所在的目录。</li>
<li>调用Workspace::SetFileFormat(…)函数，设置加载行为树的文件格式，如果不调用则默认加载EFF_xml格式。</li>
<li>通过调用Agent的接口btload(…)加载所需的行为树文件。</li>
<li>通过调用Agent的接口btsetcurrent(…)设置当前准备执行的行为树文件。</li>
<li>行为树的更新执行流程请参考<a href="./../../../../../docs/zh/tutorials/tutorial13_updateloop/index.html">更新流程</a>。</li>
<li>在游戏的释放函数里面，添加Agent::Unregister&lt;***&gt;()用于释放类型的注册信息。</li>
</ul>
</li>
</ul>
<p>如下代码样例所示：</p>
<div class="highlighter-rouge">
<pre class="highlight"><code>
<span class="n">bool</span> <span class="nf">InitBehavic</span><span class="p">(</span><span class="n">behaviac</span><span class="o">::</span><span class="n">Workspace</span><span class="o">::</span><span class="n">EFileFormat</span> <span class="n">ff</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">behaviac</span><span class="o">::</span><span class="n">Config</span><span class="o">::</span><span class="n">SetSocketBlocking</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>
    <span class="n">behaviac</span><span class="o">::</span><span class="n">Config</span><span class="o">::</span><span class="n">SetSocketPort</span><span class="p">(</span><span class="mi">8081</span><span class="p">);</span>

    <span class="n">behaviac</span><span class="o">::</span><span class="n">Agent</span><span class="o">::</span><span class="n">Register</span><span class="o">&lt;</span><span class="n">CBTPlayer</span><span class="o">&gt;</span><span class="p">();</span>

    <span class="n">behaviac</span><span class="o">::</span><span class="n">Workspace</span><span class="o">::</span><span class="n">GetInstance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">SetFilePath</span><span class="p">(</span><span class="s">"../test/demo_running/behaviac/exported"</span><span class="p">);</span>
    <span class="n">behaviac</span><span class="o">::</span><span class="n">Workspace</span><span class="o">::</span><span class="n">GetInstance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">SetFileFormat</span><span class="p">(</span><span class="n">ff</span><span class="p">);</span>

    <span class="n">behaviac</span><span class="o">::</span><span class="n">Workspace</span><span class="o">::</span><span class="n">GetInstance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">ExportMetas</span><span class="p">(</span><span class="s">"../test/demo_running/behaviac/demo_running.xml"</span><span class="p">);</span>

    <span class="c1">//behaviac::Agent::SetIdMask(kIdMask_Wolrd | kIdMask_Opponent);
</span>    <span class="n">behaviac</span><span class="o">::</span><span class="n">Workspace</span><span class="o">::</span><span class="n">GetInstance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">SetDeltaFrames</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">bool</span> <span class="nf">InitPlayer</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">pszTreeName</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">g_player</span> <span class="o">=</span> <span class="n">behaviac</span><span class="o">::</span><span class="n">Agent</span><span class="o">::</span><span class="n">Create</span><span class="o">&lt;</span><span class="n">CBTPlayer</span><span class="o">&gt;</span><span class="p">();</span>

    <span class="n">bool</span> <span class="n">bRet</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="n">bRet</span> <span class="o">=</span> <span class="n">g_player</span><span class="o">-&gt;</span><span class="n">btload</span><span class="p">(</span><span class="n">pszTreeName</span><span class="p">);</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">bRet</span><span class="p">);</span>

    <span class="n">g_player</span><span class="o">-&gt;</span><span class="n">btsetcurrent</span><span class="p">(</span><span class="n">pszTreeName</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">bRet</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">CleanupPlayer</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">behaviac</span><span class="o">::</span><span class="n">Agent</span><span class="o">::</span><span class="n">Destroy</span><span class="p">(</span><span class="n">g_player</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">CleanupBehaviac</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">behaviac</span><span class="o">::</span><span class="n">Agent</span><span class="o">::</span><span class="n">UnRegister</span><span class="o">&lt;</span><span class="n">CBTPlayer</span><span class="o">&gt;</span><span class="p">();</span>

<span class="n">    behaviac</span><span class="o">::</span><span class="n">Workspace</span><span class="o">::</span><span class="n">GetInstance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">Cleanup</span><span class="p">();</span>
<span class="p">}</span>

</code></pre>
</div>
<p>总之，一棵行为树的加载到执行，关键的就是前面提及的三个接口：btload()、btsetcurrent()和btexec()。</p>
<p>更多细节可以参考behaviac组件C++源码中附带的test/demo_running工程的<a href="https://github.com/Tencent/behaviac/blob/master/test/demo_running/demo_running.cpp">demo_running.cpp</a>文件。</p>
<p>类似的，对于C#版的运行时端，采用如下代码样例加载使用刚才导出的行为树：</p>
<figure class="highlight">
<pre><code class="language-cs" data-lang="cs"><span class="k">public</span> <span class="kt">bool</span> <span class="nf">Init</span> <span class="p">()</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ms_fileSystem</span> <span class="p">==</span> <span class="k">null</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">ms_fileSystem</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">BehaviacFileManager</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="c1">//&lt; write log file
</span>    <span class="n">behaviac</span><span class="p">.</span><span class="n">Config</span><span class="p">.</span><span class="n">IsLogging</span> <span class="p">=</span> <span class="k">true</span><span class="p">;</span>
    <span class="c1">//behaviac.Config.IsSocketing = false;
</span>
    <span class="n">behaviac</span><span class="p">.</span><span class="n">Workspace</span><span class="p">.</span><span class="n">Instance</span><span class="p">.</span><span class="n">FilePath</span> <span class="p">=</span> <span class="k">this</span><span class="p">.</span><span class="n">WorkspaceExportPath</span><span class="p">;</span>
    <span class="n">behaviac</span><span class="p">.</span><span class="n">Workspace</span><span class="p">.</span><span class="n">Instance</span><span class="p">.</span><span class="n">FileFormat</span> <span class="p">=</span> <span class="n">behaviac</span><span class="p">.</span><span class="n">Workspace</span><span class="p">.</span><span class="n">EFileFormat</span><span class="p">.</span><span class="n">EFF_xml</span><span class="p">;</span>

    <span class="c1">//register names
</span>    <span class="n">behaviac</span><span class="p">.</span><span class="n">Agent</span><span class="p">.</span><span class="n">RegisterInstanceName</span><span class="p">&lt;</span><span class="n">GameLevelCommon</span><span class="p">&gt;(</span><span class="s">"GameLevel"</span><span class="p">);</span>
    <span class="n">behaviac</span><span class="p">.</span><span class="n">Workspace</span><span class="p">.</span><span class="n">Instance</span><span class="p">.</span><span class="nf">ExportMetas</span><span class="p">(</span><span class="s">"behaviac/workspace/xmlmeta/BattleCityMeta.xml"</span><span class="p">);</span>

    <span class="n">behaviac</span><span class="p">.</span><span class="n">Debug</span><span class="p">.</span><span class="nf">Log</span><span class="p">(</span><span class="s">"Behaviac meta data export over."</span><span class="p">);</span>
    <span class="n">behaviac</span><span class="p">.</span><span class="n">Agent</span><span class="p">.</span><span class="nf">SetIdMask</span><span class="p">(</span><span class="m">0xffffffff</span><span class="p">);</span>

    <span class="k">return</span> <span class="k">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">void</span> <span class="nf">Uninit</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">behaviac</span><span class="p">.</span><span class="n">Workspace</span><span class="p">.</span><span class="n">Instance</span><span class="p">.</span><span class="nf">Cleanup</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">// 加载所需的行为树文件
</span><span class="k">if</span><span class="p">(</span><span class="n">behaviorTree</span><span class="p">.</span><span class="n">Length</span> <span class="p">&gt;</span> <span class="m">0</span><span class="p">)</span>
<span class="p">{</span>
<span class="n">    btloadResult</span> <span class="p">=</span> agent.<span class="nf">btload</span><span class="p">(</span><span class="n">behaviorTree</span><span class="p">,</span> <span class="k">true</span><span class="p">);</span>
<span class="k">    if</span><span class="p">(</span><span class="n">btloadResult</span><span class="p">)</span>
        agent.<span class="nf">btsetcurrent</span><span class="p">(</span><span class="n">behaviorTree</span><span class="p">);</span>
<span class="k">    else</span>
        <span class="n">Debug</span><span class="p">.</span><span class="nf">LogError</span><span class="p">(</span><span class="s">"Behavior tree data load failed! "</span> <span class="p">+ </span><span class="n">behaviorTree</span><span class="p">);</span>
<span class="p">}</span></code></pre>
</figure>
<p>更多细节可以参考behaviac组件C#源码中附带的integration/BattleCityDemo工程的<a href="https://github.com/Tencent/behaviac/blob/master/integration/BattleCityDemo/Assets/Scripts/BehaviacSystem.cs">BehaviacSystem.cs</a>文件。</p>
]]></content:encoded>
					
					<wfw:commentRss>./../../../../../tutorial4_1_export_xml_bson/feed/index.html</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>类、结构体或枚举的数组</title>
		<link>./../../../../../tutorial8_customarray/index.html</link>
					<comments>./../../../../../tutorial8_customarray/index.html#respond</comments>
		
		<dc:creator><![CDATA[admin]]></dc:creator>
		<pubDate>Fri, 13 May 2016 02:34:48 +0000</pubDate>
				<category><![CDATA[3.5]]></category>
		<category><![CDATA[扩展]]></category>
		<category><![CDATA[C++]]></category>
		<category><![CDATA[运行时]]></category>
		<guid isPermaLink="false">./../../../../../index.html?p=296</guid>

					<description><![CDATA[对于C#版，类型信息不支持[]类型的数组，只支持List&#60;***&#62;类型的数组。 对于C++版，需要按照如下方式进行注册： 基本类型（bool、int<a class="moretag" href="./../../../../../tutorial8_customarray/index.html">Read More...</a>]]></description>
										<content:encoded><![CDATA[<p id="section">对于C#版，类型信息不支持[]类型的数组，只支持List&lt;***&gt;类型的数组。</p>
<p>对于C++版，需要按照如下方式进行注册：</p>
<p>基本类型（bool、int、float、char、sbyte、ubyte等）的数组可以直接使用，但当使用到其他自定义类型数组的时候，需要添加特殊的宏和代码，否则运行时可能会有错误（如果没有使用到相应的操作，则没有错误）：</p>
<ul>
<li>在.h的头文件里添加如下所示的宏，但需放在任意namespace之外：</li>
</ul>
<div class="highlighter-rouge">
<pre class="highlight"><code>
<span class="n">BEHAVIAC_DECLARE_TYPE_VECTOR_HANDLER</span><span class="p">(</span><span class="n">TNS</span><span class="o">::</span><span class="n">ST</span><span class="o">::</span><span class="n">PER</span><span class="o">::</span><span class="n">WRK</span><span class="o">::</span><span class="n">kEmployee</span><span class="p">);</span>

</code></pre>
</div>
<ul>
<li>在初始化的代码里添加如下所示的注册代码：</li>
</ul>
<div class="highlighter-rouge">
<pre class="highlight"><code>
<span class="n">behaviac</span><span class="o">::</span><span class="n">TypeRegister</span><span class="o">::</span><span class="n">Register</span><span class="o">&lt;</span><span class="n">TNS</span><span class="o">::</span><span class="n">ST</span><span class="o">::</span><span class="n">PER</span><span class="o">::</span><span class="n">WRK</span><span class="o">::</span><span class="n">kEmployee</span><span class="o">&gt;</span><span class="p">(</span><span class="s">" TNS::ST::PER::WRK::kEmployee"</span><span class="p">);</span>

</code></pre>
</div>
<ul>
<li>在结束代码里添加如下所示的反注册代码：</li>
</ul>
<div class="highlighter-rouge">
<pre class="highlight"><code>
<span class="n">behaviac</span><span class="o">::</span><span class="n">TypeRegister</span><span class="o">::</span><span class="n">UnRegister</span><span class="o">&lt;</span><span class="n">TNS</span><span class="o">::</span><span class="n">ST</span><span class="o">::</span><span class="n">PER</span><span class="o">::</span><span class="n">WRK</span><span class="o">::</span><span class="n">kEmployee</span><span class="o">&gt;</span><span class="p">(</span><span class="s">" TNS::ST::PER::WRK::kEmployee"</span><span class="p">);</span>

</code></pre>
</div>
<p>更多细节可以参考behaviac组件C++源码中附带的<a href="https://github.com/Tencent/behaviac/blob/master/test/btunittest/Agent/UnitTestTypes.h">UnitTestTypes.h</a>文件中的结构体kEmployee。</p>
<ul>
<li>Agent及其子类的数组<br />
当涉及<code class="highlighter-rouge">behaviac::Agent</code>或是其子类的时候，仅支持其指针类型即<code class="highlighter-rouge">behaviac::Agent*</code>或<code class="highlighter-rouge">SubclassAgent*</code>（<code class="highlighter-rouge">SubclassAgent</code>是<code class="highlighter-rouge">behaviac::Agent</code>的一个子类）。<br />
<code class="highlighter-rouge">behaviac::Agent*</code>或<code class="highlighter-rouge">vector&lt;behaviac::Agent*&gt;</code>类型直接被支持，不需要做什么额外的工作，其任何子类<code class="highlighter-rouge">SubclassAgent*</code>也直接被支持。<br />
但是需要支持<code class="highlighter-rouge">vector&lt;SubclassAgent*&gt;</code>的时候，则需要在.h文件里添加如下所示的宏，但需放在任意namespace之外：</li>
</ul>
<div class="highlighter-rouge">
<pre class="highlight"><code>
<span class="n">BEHAVIAC_DECLARE_TYPE_VECTOR_HANDLER</span><span class="p">(</span><span class="n">SubclassAgent</span><span class="o">*</span><span class="p">);</span>

</code></pre>
</div>
<p>在初始化和结束的时候分别注册和反注册：</p>
<div class="highlighter-rouge">
<pre class="highlight"><code>
<span class="n">behaviac</span><span class="o">::</span><span class="n">Agent</span><span class="o">::</span><span class="n">Register</span><span class="o">&lt;</span><span class="n">SubclassAgent</span><span class="o">&gt;</span><span class="p">();</span>

<span class="n">behaviac</span><span class="o">::</span><span class="n">Agent</span><span class="o">::</span><span class="n">UnRegister</span><span class="o">&lt;</span><span class="n">SubclassAgent</span><span class="o">&gt;</span><span class="p">();</span>

</code></pre>
</div>
<p>更多细节可以参考behaviac组件C++源码中附带的<a href="https://github.com/Tencent/behaviac/blob/master/test/btunittest/Agent/EmployeeParTestAgent.h">EmployeeParTestAgent.h</a>文件中的类EmployeeParTestAgent。</p>
]]></content:encoded>
					
					<wfw:commentRss>./../../../../../tutorial8_customarray/feed/index.html</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>自定义枚举</title>
		<link>./../../../../../tutorial7_customenum/index.html</link>
					<comments>./../../../../../tutorial7_customenum/index.html#respond</comments>
		
		<dc:creator><![CDATA[admin]]></dc:creator>
		<pubDate>Fri, 13 May 2016 02:34:01 +0000</pubDate>
				<category><![CDATA[3.5]]></category>
		<category><![CDATA[扩展]]></category>
		<category><![CDATA[C++]]></category>
		<category><![CDATA[运行时]]></category>
		<guid isPermaLink="false">./../../../../../index.html?p=294</guid>

					<description><![CDATA[类似于自定义类，在.h文件中，任意编写一个自定义枚举类型，然后通过宏DECLARE_BEHAVIAC_ENUM声明该枚举类型。需要注意的是，宏DECLARE_B<a class="moretag" href="./../../../../../tutorial7_customenum/index.html">Read More...</a>]]></description>
										<content:encoded><![CDATA[<ul>
<li>类似于自定义类，在.h文件中，任意编写一个自定义枚举类型，然后通过宏DECLARE_BEHAVIAC_ENUM声明该枚举类型。需要注意的是，宏DECLARE_BEHAVIAC_ENUM必须定义在全局的namespace里，即放在任何命名空间之外。<br />
如下代码样例所示：</li>
</ul>
<div class="highlighter-rouge">
<pre class="highlight"><code><span class="k">namespace</span> <span class="n">TNS</span>
<span class="p">{
</span><span class="k">    namespace</span> <span class="n">NE</span>
<span class="p">    {</span>
<span class="k">        namespace</span> <span class="n">NAT</span>
	<span class="p">{</span>
            <span class="k">enum</span> <span class="n">eColor</span>
	    <span class="p">{</span>
	        <span class="n">RED</span><span class="p">,</span>
                <span class="n">GREEN</span><span class="p">,</span>
                <span class="n">BLUE</span><span class="p">,</span>
                <span class="n">YELLOW</span><span class="p">,</span>
                <span class="n">WHITE</span><span class="p">,</span>
	    <span class="p">};</span>
	<span class="p">}</span>
<span class="p">    }</span>
<span class="p">}</span>

<span class="n">DECLARE_BEHAVIAC_ENUM</span><span class="p">(</span><span class="n">TNS</span><span class="o">::</span><span class="n">NE</span><span class="o">::</span><span class="n">NAT</span><span class="o">::</span><span class="n">eColor</span><span class="p">,</span> <span class="n">eColor</span><span class="p">);</span>
</code></pre>
</div>
<ul>
<li>在.cpp文件中，通过一系列宏注册该枚举自身的描述及其枚举值：
<ul>
<li>宏BEGIN_ENUM_DESCRIPTION和END_ENUM_DESCRIPTION表示枚举信息注册的开始和结束。</li>
<li>可选的宏ENUMCLASS_DISPLAY_INFO用于注册枚举自身的显示名和描述。</li>
<li>宏DEFINE_ENUM_VALUE用于注册枚举的值，可以通过.DISPLAYNAME的追加方式为值添加显示名，通过.DESC的追加方式为值添加描述。<br />
如下代码样例所示：</li>
</ul>
</li>
</ul>
<div class="highlighter-rouge">
<pre class="highlight"><code><span class="n">BEGIN_ENUM_DESCRIPTION</span><span class="p">(</span><span class="n">TNS</span><span class="o">::</span><span class="n">NE</span><span class="o">::</span><span class="n">NAT</span><span class="o">::</span><span class="n">eColor</span><span class="p">,</span> <span class="n">eColor</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">ENUMCLASS_DISPLAY_INFO</span><span class="p">(</span><span class="s">L"色彩枚举"</span><span class="p">,</span> <span class="s">L"eColor是用于测试枚举使用的类型"</span><span class="p">);</span>

    <span class="n">DEFINE_ENUM_VALUE</span><span class="p">(</span><span class="n">TNS</span><span class="o">::</span><span class="n">NE</span><span class="o">::</span><span class="n">NAT</span><span class="o">::</span><span class="n">RED</span><span class="p">,</span> <span class="s">"RED"</span><span class="p">).</span><span class="n">DISPLAY_INFO</span><span class="p">(</span><span class="s">L"红色"</span><span class="p">,</span> <span class="s">L"激进"</span><span class="p">);</span>
    <span class="n">DEFINE_ENUM_VALUE</span><span class="p">(</span><span class="n">TNS</span><span class="o">::</span><span class="n">NE</span><span class="o">::</span><span class="n">NAT</span><span class="o">::</span><span class="n">GREEN</span><span class="p">,</span> <span class="s">"GREEN"</span><span class="p">);</span>
    <span class="n">DEFINE_ENUM_VALUE</span><span class="p">(</span><span class="n">TNS</span><span class="o">::</span><span class="n">NE</span><span class="o">::</span><span class="n">NAT</span><span class="o">::</span><span class="n">BLUE</span><span class="p">,</span> <span class="s">"BLUE"</span><span class="p">);</span>
    <span class="n">DEFINE_ENUM_VALUE</span><span class="p">(</span><span class="n">TNS</span><span class="o">::</span><span class="n">NE</span><span class="o">::</span><span class="n">NAT</span><span class="o">::</span><span class="n">YELLOW</span><span class="p">,</span> <span class="s">"YELLOW"</span><span class="p">);</span>
    <span class="n">DEFINE_ENUM_VALUE</span><span class="p">(</span><span class="n">TNS</span><span class="o">::</span><span class="n">NE</span><span class="o">::</span><span class="n">NAT</span><span class="o">::</span><span class="n">WHITE</span><span class="p">,</span> <span class="s">"WHITE"</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">END_ENUM_DESCRIPTION</span><span class="p">()</span>
</code></pre>
</div>
<ul>
<li>在初始化注册（Register）的部分需要加上如下的代码，反注册（UnRegister）的部分添加相应UnRegister的代码。注意这部分Register/UnRegister的代码不是必须的，如果该类型没有用作par或者没有用作条件比较，就可以不需要。</li>
</ul>
<div class="highlighter-rouge">
<pre class="highlight"><code><span class="n">behaviac</span><span class="o">::</span><span class="n">TypeRegister</span><span class="o">::</span><span class="n">Register</span><span class="o">&lt;</span> <span class="n">TNS</span><span class="o">::</span><span class="n">EnumTest</span> <span class="o">&gt;</span><span class="p">(</span><span class="s">" TNS::EnumTest "</span><span class="p">);</span>

<span class="n">behaviac</span><span class="o">::</span><span class="n">TypeRegister</span><span class="o">::</span><span class="n">UnRegister</span><span class="o">&lt;</span> <span class="n">TNS</span><span class="o">::</span><span class="n">EnumTest</span> <span class="o">&gt;</span><span class="p">(</span><span class="s">" TNS::EnumTest "</span><span class="p">);</span>
</code></pre>
</div>
<p>更多细节可以参考behaviac组件C++源码库中btunittest工程的<a href="#?https://github.com/Tencent/behaviac/blob/master/test/btunittest/Agent/UnitTestTypes.h">UnitTestTypes.h</a>文件中eColor结构体相关的代码。</p>
<hr />
<p><!--StartFragment --></p>
<div>声明的类型只用被使用过才会导出。所谓使用过是指：</div>
<div>1. 作为某Agent的成员</div>
<div>2. 作为某Agent成员函数的参数或返回值</div>
<div></div>
<div>如果只是声明了，但是没有被使用过，则不会被导出。</div>
]]></content:encoded>
					
					<wfw:commentRss>./../../../../../tutorial7_customenum/feed/index.html</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>自定义类或结构体</title>
		<link>./../../../../../tutorial6_customtypes/index.html</link>
					<comments>./../../../../../tutorial6_customtypes/index.html#comments</comments>
		
		<dc:creator><![CDATA[admin]]></dc:creator>
		<pubDate>Fri, 13 May 2016 02:32:53 +0000</pubDate>
				<category><![CDATA[3.5]]></category>
		<category><![CDATA[扩展]]></category>
		<category><![CDATA[运行时]]></category>
		<guid isPermaLink="false">./../../../../../index.html?p=292</guid>

					<description><![CDATA[在.h文件中，任意编写一个自定义的类或结构体，并用宏DECLARE_BEHAVIAC_STRUCT声明该类或者结构体为非虚类，如下代码所示： struct Ty<a class="moretag" href="./../../../../../tutorial6_customtypes/index.html">Read More...</a>]]></description>
										<content:encoded><![CDATA[<ul>
<li>在.h文件中，任意编写一个自定义的类或结构体，并用宏DECLARE_BEHAVIAC_STRUCT声明该类或者结构体为非虚类，如下代码所示：</li>
</ul>
<pre>struct TypeTest2_t
{
    int	  name;
    float weight;
    bool  bLive;

    DECLARE_BEHAVIAC_STRUCT(TypeTest2_t);
};</pre>
<p>上面的用法定义出来的TypeTest2_t在导出的元信息中为值类型（也即在导出的元信息中其值IsRefType为false），值类型可以在编辑器中设置其成员属性。与值类型对应的是引用类型，引用类型不会导出其成员属性，在编辑器中也不用配置其成员属性。</p>
<p>另外，宏DECLARE_BEHAVIAC_STRUCT也可以带2个参数，第一个参数为类型，第二个参数为true表示该类型用作为引用类型（也即导出元信息后其值IsRefType为true），否则不用第二个参数表示为值类型，如下代码所示：</p>
<pre>DECLARE_BEHAVIAC_STRUCT(TypeTest2_t, true);</pre>
<ul>
<li>在.cpp文件中，通过一系列宏注册该类或结构体自身的描述及其属性：</li>
</ul>
<pre>BEGIN_PROPERTIES_DESCRIPTION(TypeTest2_t)
{
    CLASS_DISPLAYNAME(L"测试结构体")
    CLASS_DESC(L"自定义结构体")

    REGISTER_PROPERTY(name);
    REGISTER_PROPERTY(weight).DISPLAYNAME(L”重量”);
    REGISTER_PROPERTY(bLive) .DISPLAYNAME(L”是否活着”).DESC(L”存活状态”);
}
END_PROPERTIES_DESCRIPTION()</pre>
<ul>
<li>在初始化注册（Register）的部分需要加上如下的代码，反注册（UnRegister）的部分添加相应UnRegister的代码。注意这部分Register/UnRegister的代码不是必须的，如果该类型没有用作par或者没有用作条件比较，就可以不需要。</li>
</ul>
<pre>behaviac::TypeRegister::Register&amp;amp;amp;amp;lt; TypeTest2_t &amp;amp;amp;amp;gt;(" TypeTest2_t ");

behaviac::TypeRegister::UnRegister&amp;amp;amp;amp;lt; TypeTest2_t &amp;amp;amp;amp;gt;(" TypeTest2_t ");</pre>
<p>更多细节可以参考behaviac组件C++源码库中btunittest工程的<a href="https://github.com/Tencent/behaviac/blob/master/test/btunittest/Others/reflectionunittest.cpp">reflectionunittest.cpp</a>文件中TypeTest2_t结构体相关的代码。</p>
]]></content:encoded>
					
					<wfw:commentRss>./../../../../../tutorial6_customtypes/feed/index.html</wfw:commentRss>
			<slash:comments>3</slash:comments>
		
		
			</item>
		<item>
		<title>扩展使用已有的类型</title>
		<link>./../../../../../tutorial5_extendtypes/index.html</link>
					<comments>./../../../../../tutorial5_extendtypes/index.html#respond</comments>
		
		<dc:creator><![CDATA[admin]]></dc:creator>
		<pubDate>Fri, 13 May 2016 02:32:11 +0000</pubDate>
				<category><![CDATA[3.5]]></category>
		<category><![CDATA[扩展]]></category>
		<category><![CDATA[运行时]]></category>
		<guid isPermaLink="false">./../../../../../index.html?p=290</guid>

					<description><![CDATA[在某些情况下，除了运行时库（C++）中提供支持的一些基本类型（bool、short、int、float等）之外，behaviac还支持扩展使用已有的或者用户自定<a class="moretag" href="./../../../../../tutorial5_extendtypes/index.html">Read More...</a>]]></description>
										<content:encoded><![CDATA[<p>在某些情况下，除了运行时库（C++）中提供支持的一些基本类型（bool、short、int、float等）之外，behaviac还支持扩展使用已有的或者用户自定义的类、结构体和枚举类型。<br />
这里有两种情况，其处理方式是不同的：</p>
<ul>
<li>有些类型是程序中本来就有的，该类型可能是某个第三方库中提供的，但这些类型是不方便随意修改的。</li>
<li>另外一些可以随便修改的类型，请参考<a href="./../../../../../docs/zh/tutorials/tutorial6_customtypes/index.html">自定义类或结构体</a>。</li>
</ul>
<h3 id="section">字符串和数组类型</h3>
<p>需要注意的是，behaviac组件为了支持C++的反射系统，对字符串和数组类型有如下要求：</p>
<ul>
<li>字符串：不要使用std::string，需要使用behaviac::string，因为behaviac::string使用了自定义的allocator，可以对内存的使用进行统一的管理。</li>
<li>数组：不要使用std::vector，需要使用behaviac::vector。</li>
</ul>
<h3 id="char">char类型</h3>
<p>此外，需要对char、signed char和unsigned char做出一些必要的说明：</p>
<ul>
<li>在C++中，char、signed char和unsigned char是三个不同的类型。</li>
<li>在编辑器中，分别对应char、sbyte、ubyte。</li>
<li>对于C#，char、sbyte和byte是基本类型，分别对应编辑器中的char、sbyte和ubyte。</li>
</ul>
<h3 id="section-1">扩展使用已有的类型</h3>
<p>对于已有的不能修改源码的类型，需要按照如下步骤进行扩展：</p>
<ul>
<li>在.h文件中，通过宏BEHAVIAC_EXTEND_EXISTING_TYPE特化某个需要的类型。<br />
如下代码样例所示（假设TestNS::Float2是某个第三方库中的类型，需要用到但不能修改它）：</li>
</ul>
<div class="highlighter-rouge">
<pre class="highlight"><code><span class="n">BEHAVIAC_EXTEND_EXISTING_TYPE</span><span class="p">(</span><span class="n">myFloat2</span><span class="p">,</span> <span class="n">TestNS</span><span class="o">::</span><span class="n">Float2</span><span class="p">);</span>
</code></pre>
</div>
<ul>
<li>定义一个“相似”的struct（myFloat2），该struct的作用是用来定义那个已存在的类的成员，以便behaviac能够访问该类。</li>
<li>通过DECLARE_BEHAVIAC_STRUCT的第二个参数isRefType为true或false表示该类型是否为引用类型，如下代码所示。</li>
</ul>
<div class="highlighter-rouge">
<pre class="highlight"><code><span class="k">struct</span> <span class="n">myFloat2</span>
<span class="p">{</span>
    <span class="kt">float</span> <span class="n">x</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">y</span><span class="p">;
</span>
    <span class="n">DECLARE_BEHAVIAC_STRUCT</span> <span class="p">(</span><span class="n">myFloat2</span><span class="p">,</span> <span class="nb">false</span><span class="p">);
</span>
    <span class="n">myFloat2</span><span class="p">()</span>
<span class="p">    {</span>
<span class="p">    }
</span>
<span class="n">    myFloat2</span><span class="p">(</span><span class="k">const</span> <span class="n">TestNS</span><span class="o">::</span><span class="n">Float2</span><span class="o">&amp;</span> <span class="n">v</span><span class="p">)</span> <span class="o">:</span> <span class="n">x</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">x</span><span class="p">),</span> <span class="n">y</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">y</span><span class="p">)</span>
<span class="p">    {</span>
<span class="p">    }</span>
<span class="p">};</span>
</code></pre>
</div>
<ul>
<li>在命名空间StringUtils的嵌套子空间Private中实现该类型的ToString()和FromString()函数。注意myFloat2中需要实现相应的转换构造函数（myFloat2(const TestNS::Float2&amp; v)），如下代码样例所示：</li>
</ul>
<div class="highlighter-rouge">
<pre class="highlight"><code><span class="k">namespace</span> <span class="n">behaviac</span>
<span class="p">{</span>
    <span class="c1">// ValueToString &amp; ValueFromString
</span>    <span class="k">namespace</span> <span class="n">StringUtils</span>
    <span class="p">{</span>
        <span class="k">namespace</span> <span class="n">Private</span>
        <span class="p">{</span>
            <span class="k">template</span><span class="o">&lt;&gt;</span>
            <span class="kr">inline</span> <span class="n">behaviac</span><span class="o">::</span><span class="n">string</span> <span class="n">ToString</span><span class="p">(</span><span class="k">const</span> <span class="n">TestNS</span><span class="o">::</span><span class="n">Float2</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="c1">//myFloat2::ToString is defined by DECLARE_BEHAVIAC_STRUCT(myFloat2)
</span>                <span class="n">myFloat2</span> <span class="n">temp</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
                <span class="k">return</span> <span class="n">temp</span><span class="p">.</span><span class="n">ToString</span><span class="p">();</span>
            <span class="p">}</span>

            <span class="k">template</span><span class="o">&lt;&gt;</span>
            <span class="kr">inline</span> <span class="n">bool</span> <span class="n">FromString</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">str</span><span class="p">,</span> <span class="n">TestNS</span><span class="o">::</span><span class="n">Float2</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">myFloat2</span> <span class="n">temp</span><span class="p">;</span>

                <span class="c1">//myFloat2::FromString is defined by DECLARE_BEHAVIAC_STRUCT(myFloat2)
</span>                <span class="k">if</span> <span class="p">(</span><span class="n">temp</span><span class="p">.</span><span class="n">FromString</span><span class="p">(</span><span class="n">str</span><span class="p">))</span>
                <span class="p">{</span>
                    <span class="n">val</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">temp</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
                    <span class="n">val</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">temp</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
                    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
                <span class="p">}</span>

                <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>
<ul>
<li>实现该类型的模板函数SwapByteTempl()，注意该函数不能放在任何命名空间（namespace）中，如下代码样例所示：</li>
</ul>
<div class="highlighter-rouge">
<pre class="highlight"><code><span class="k">template</span><span class="o">&lt;</span> <span class="k">typename</span> <span class="n">SWAPPER</span> <span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">void</span> <span class="n">SwapByteTempl</span><span class="p">(</span><span class="n">TestNS</span><span class="o">::</span><span class="n">Float2</span><span class="o">&amp;</span> <span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
<span class="n">    SwapByteTempl</span><span class="o">&lt;</span> <span class="n">SWAPPER</span> <span class="o">&gt;</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">x</span><span class="p">);</span>
<span class="n">    SwapByteTempl</span><span class="o">&lt;</span> <span class="n">SWAPPER</span> <span class="o">&gt;</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
</div>
<ul>
<li>在命名空间behaviac的嵌套子空间Details中实现该类型的Equal()模板函数，如下代码样例所示：</li>
</ul>
<div class="highlighter-rouge">
<pre class="highlight"><code><span class="k">namespace</span> <span class="n">behaviac</span>
<span class="p">{
</span><span class="k">    namespace</span> <span class="n">Details</span>
    <span class="p">{</span>
        <span class="k">template</span><span class="o">&lt;&gt;</span>
	<span class="kr">inline</span> <span class="n">bool</span> <span class="n">Equal</span><span class="p">(</span><span class="k">const</span> <span class="n">TestNS</span><span class="o">::</span><span class="n">Float2</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="k">const</span> <span class="n">TestNS</span><span class="o">::</span><span class="n">Float2</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span>
        <span class="p">{</span>
	    <span class="k">return</span> <span class="n">Tag</span><span class="o">::</span><span class="n">IsEqualWithEpsilon</span><span class="p">(</span><span class="n">lhs</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">rhs</span><span class="p">.</span><span class="n">x</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">Tag</span><span class="o">::</span><span class="n">IsEqualWithEpsilon</span><span class="p">(</span><span class="n">lhs</span><span class="p">.</span><span class="n">y</span><span class="p">,</span> <span class="n">rhs</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">    }</span>
<span class="p">}</span>
</code></pre>
</div>
<ul>
<li>在初始化注册（Register）的部分需要加上如下的代码，反注册（UnRegister）的部分添加相应UnRegister的代码。注意：这部分Register/UnRegister的代码不是必须的，如果该类型没有用作par或者没有用作条件比较，就可以不需要。</li>
</ul>
<div class="highlighter-rouge">
<pre class="highlight"><code><span class="n">behaviac</span><span class="o">::</span><span class="n">TypeRegister</span><span class="o">::</span><span class="n">Register</span><span class="o">&lt;</span><span class="n">TestNS</span><span class="o">::</span><span class="n">Float2</span><span class="o">&gt;</span><span class="p">(</span><span class="s">"TestNS::Float2"</span><span class="p">);</span>

<span class="n">behaviac</span><span class="o">::</span><span class="n">TypeRegister</span><span class="o">::</span><span class="n">UnRegister</span><span class="o">&lt;</span><span class="n">TestNS</span><span class="o">::</span><span class="n">Float2</span><span class="o">&gt;</span><span class="p">(</span><span class="s">"TestNS::Float2"</span><span class="p">);</span>
</code></pre>
</div>
<p>详细代码可以参考behaviac组件C++源码库中btunittest工程的<a href="https://github.com/Tencent/behaviac/blob/master/test/btunittest/ext/extendstruct.h">extendstruct.h</a>文件。</p>
]]></content:encoded>
					
					<wfw:commentRss>./../../../../../tutorial5_extendtypes/feed/index.html</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>热加载</title>
		<link>./../../../../../tutorial12_hotreload/index.html</link>
					<comments>./../../../../../tutorial12_hotreload/index.html#respond</comments>
		
		<dc:creator><![CDATA[admin]]></dc:creator>
		<pubDate>Fri, 13 May 2016 02:41:28 +0000</pubDate>
				<category><![CDATA[文章]]></category>
		<category><![CDATA[概念]]></category>
		<category><![CDATA[编辑器]]></category>
		<category><![CDATA[运行时]]></category>
		<guid isPermaLink="false">./../../../../../index.html?p=304</guid>

					<description><![CDATA[behaviac组件中的编辑器和运行时库都支持热加载，但是只针对XML/BSON格式的行为树文件。 在编辑器中，只要当前打开的行为树文件在编辑器外由于某种原因得<a class="moretag" href="./../../../../../tutorial12_hotreload/index.html">Read More...</a>]]></description>
										<content:encoded><![CDATA[<p id="section">behaviac组件中的编辑器和运行时库都支持热加载，但是只针对XML/BSON格式的行为树文件。</p>
<p>在编辑器中，只要当前打开的行为树文件在编辑器外由于某种原因得到修改（例如，通过项目中的文件版本管理系统强制同步行为树文件，或者通过文本编辑器强制修改行为树XML文件等），那么都可以自动的在编辑器中得到刷新。</p>
<p>对于运行时端（或程序端），只要在编辑器中修改了行为树文件并重新导出，那么在游戏运行过程中不用退出游戏，最新导出的行为树就可以自动进行加载。这样可以及时查看或使用行为树最新的修改效果。</p>
<p>行为树的更新执行流程请参考<a href="./../../../../../docs/zh/tutorials/tutorial13_updateloop/index.html">更新流程</a>。</p>
<p>为了启动热加载功能，需要确保在运行时端直接或间接调用了Workspace::DebugUpdate()函数，有两种方式：</p>
<ul>
<li>如果Agent的行为树是通过调用Workspace::Update()来集中执行的，则无需额外调用Workspace::DebugUpdate()函数</li>
<li>如果Agent的行为树是通过调用Agent::btexec()来执行的，则需要游戏每次更新时调用Workspace::DebugUpdate()函数</li>
</ul>
]]></content:encoded>
					
					<wfw:commentRss>./../../../../../tutorial12_hotreload/feed/index.html</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>优化及性能</title>
		<link>./../../../../../performence/index.html</link>
					<comments>./../../../../../performence/index.html#comments</comments>
		
		<dc:creator><![CDATA[admin]]></dc:creator>
		<pubDate>Fri, 13 May 2016 02:39:39 +0000</pubDate>
				<category><![CDATA[文章]]></category>
		<category><![CDATA[连调]]></category>
		<category><![CDATA[优化]]></category>
		<category><![CDATA[编译构建]]></category>
		<category><![CDATA[运行时]]></category>
		<guid isPermaLink="false">./../../../../../index.html?p=300</guid>

					<description><![CDATA[优化及性能 宏BEHAVIAC_RELEASE定义的时候是最终版，BEHAVIAC_RELEASE没有定义的时候是为开发版。 在debug版中，BEHAVIAC<a class="moretag" href="./../../../../../performence/index.html">Read More...</a>]]></description>
										<content:encoded><![CDATA[<h2 id="section">优化及性能</h2>
<p>宏BEHAVIAC_RELEASE定义的时候是最终版，BEHAVIAC_RELEASE没有定义的时候是为开发版。</p>
<ul>
<li>在debug版中，BEHAVIAC_RELEASE缺省下没有定义的。诸如logging、socketing、热加载等开发功能是有效的。可以通过behaviac::Config::IsLogging和behaviac::Config::IsSocketing来控制是否要Log到文件或是否与编辑器的连接。</li>
<li>在release版中，BEHAVIAC_RELEASE缺省是有定义的。诸如logging、socketing、热加载等开发功能都是没有定义的。</li>
</ul>
<div class="note info">
<h5>BEHAVIAC_RELEASE缺省下是否定义的说明</h5>
</div>
<p>BEHAVIAC_RELEASE缺省下是否定义可以参考文章《<a href="./../../../build/index.html">构建说明</a>》。</p>
<p>简单来说对于Cpp，当使用CMake的时候，BEHAVIAC_VERSION_MODE用来控制BEHAVIAC_RELEASE是否定义：</p>
<ol>
<li>Default：缺省模式是Debug下BEHAVIAC_RELEASE没有定义，而Release下BEHAVIAC_RELEASE有定义</li>
<li>ForceUseDev：强制不定义BEHAVIAC_RELEASE</li>
<li>ForceUseRelease：强制定义BEHAVIAC_RELEASE</li>
</ol>
<p>而当BEHAVIAC_RELEASE有定义的最终版里，logging和socketing是关闭的，也不支持连接编辑器。</p>
<p>具体可以参考文章《<a href="./../../../config/index.html">开发功能开关</a>》。</p>
<p>总之，针对效率可以有下述选择：</p>
<ol>
<li>定义BEHAVIAC_RELEASE，从而不编译诸如logging、socketing、热加载等开发功能，提供最高效率，也不支持连调功能。
<ul>
<li>C++下，在_config.h中定义BEHAVIAC_RELEASE为1</li>
<li>C#下，在Assets目录下的smcs.rsp文件中，定义BEHAVIAC_RELEASE</li>
<li>如果想选择打开或关闭调试功能而不是完全的关闭，则不需要修改任何关于BEHAVIAC_RELEASE的定义，通过behaviac::Config::SetLogging和behaviac::Config::SetSocketing来控制是否打开logging和socketing。</li>
</ul>
</li>
<li>不使用xml或bson格式，而是使用C++或C#格式
<ul>
<li>C#下，还需要那些在行为树中使用到的Agent的成员都是public的（非public的成员即使通过C#代码访问也需要使用反射系统来进行，会导致GC Alloc以及性能损失）。</li>
</ul>
</li>
</ol>
<div class="note info">
<h5>overhead</h5>
</div>
<p>behaviac可以导出xml(bson)，或者源码（cpp/c#），源码的效率要优于数据（xml/bson）的执行效率。实际上这里的效率都是指的behaviac本身的overhead，如果提供的<code class="highlighter-rouge">方法</code>本身效率很低，运行很慢，behaviac本身的overhead就可以忽略不计了，无论是选用导出何种格式都遇事无补，这个时候，最需要解决的是优化方法的执行效率。</p>
<p><img src="./../../../../../img/references/overhead.png" alt="overhead" /><br />
如上图，尽管xml格式是cpp格式的大约2倍，但这个overhead实际上是非常小的，只有0.0000269秒，0.0269毫秒。（具体数据会因为测试环境的不同有差异）。</p>
]]></content:encoded>
					
					<wfw:commentRss>./../../../../../performence/feed/index.html</wfw:commentRss>
			<slash:comments>3</slash:comments>
		
		
			</item>
		<item>
		<title>运行时端常用类的介绍</title>
		<link>./../../../../../basic_classes/index.html</link>
					<comments>./../../../../../basic_classes/index.html#respond</comments>
		
		<dc:creator><![CDATA[admin]]></dc:creator>
		<pubDate>Mon, 11 Apr 2016 09:49:47 +0000</pubDate>
				<category><![CDATA[文章]]></category>
		<category><![CDATA[上手]]></category>
		<category><![CDATA[运行时]]></category>
		<guid isPermaLink="false">./../../../../../index.html?p=152</guid>

					<description><![CDATA[在使用behaviac运行时端（Runtime）的源代码或API时，有几个最常用的类值得注意：如Workspace、Agent、Config等。 Workspa<a class="moretag" href="./../../../../../basic_classes/index.html">Read More...</a>]]></description>
										<content:encoded><![CDATA[<p>在使用behaviac运行时端（Runtime）的源代码或API时，有几个最常用的类值得注意：如Workspace、Agent、Config等。</p>
<h3>Workspace类</h3>
<p>Workspace类主要用于管理类型信息的导出，加载、卸载、执行、停止执行行为树，设置时间和帧数等。</p>
<ul>
<li>GetInstance() ：用于获取Workspace的单件实例。</li>
<li>ExportMetas(const char*) ：导出类型信息文件到指定的路径，详见文档《<a href="{{site.url}}{{site.baseurl}}/docs/zh/tutorials/tutorial3_1_meta_cpp_register/">C++运行时端中类型信息的注册和导出</a>》。</li>
<li>SetFilePath(const char*) ：用于加载行为树时指定行为树文件所在的目录。</li>
<li>SetFileFormat(EFileFormat) ：用于指定加载行为树文件的格式，包括Xml、Bson、Cpp/Cs、Default。其中Default表示先尝试加载Xml格式，如果找不到再尝试加载Bson格式，最后尝试加载Cpp/Cs格式，这个功能可用于行为树的热更新。</li>
<li>Update() ：用于执行所有Agent的当前行为树，行为树的执行也可以不通过该API，可以自己单独调用Agent的btexec()方法，详见文档《<a href="{{site.url}}{{site.baseurl}}/docs/zh/tutorials/tutorial13_updateloop/">运行时端的更新流程</a>》。</li>
<li>DebugUpdate() ：用于执行调试和热加载相关的方法，如果已经使用了Update()方法来执行，则连调或热加载时就不需要再调用该DebugUpdate()方法。</li>
<li>SetIsExecAgents(bool) ：用于停止/继续执行所有Agent的当前行为树，前提是行为树是执行是通过Update()方法发起的。如果是自己单独调用Agent的btexec()方法，则通过Agent的SetActive(bool)方法来停止/继续执行。</li>
<li>SetTimeSinceStartup(double) ：用于设置游戏从启动到当前的总时间，该总时间主要用于时间、等待时间等与时间有关的节点的执行。如果不每帧设置该值，这些节点将不会正常工作。</li>
<li>SetFrameSinceStartup(int) ：用于设置游戏从启动到当前的总帧数，该总帧数主要用于帧数、等待帧数等与帧数有关的节点的执行。如果不每帧设置该值，这些节点将不会正常工作。</li>
</ul>
<p>具体的代码可以查看<a href="{{site.repository}}/blob/master/inc/behaviac/base/workspace.h">behaviac/base/workspace.h</a></p>
<h3>Agent类</h3>
<p>静态方法：</p>
<ul>
<li>Create(const char*, int, short) ：用于创建Agent的实例。</li>
<li>Destroy(Agent*) ：用于销毁Agent的实例。</li>
<li>Register() ：注册该Agent类，用于记录该类的类型信息。</li>
<li>UnRegister() ：取消注册该Agent类。</li>
<li>RegisterInstanceName(const char*, const wchar_t*, const wchar_t*) ：注册实例名字，作为类型信息的一部分，导出后可用于编辑器中节点的配置。</li>
<li>UnRegisterInstanceName(const char*) ：取消注册实例名字。</li>
<li>BindInstance(Agent*, const char*, int) ：将某个Agent实例跟某个名字进行绑定。</li>
<li>UnbindInstance(const char*, int） ：取消某个Agent实例跟某个名字的绑定。</li>
</ul>
<p>成员方法：</p>
<ul>
<li>btload(const char*, bool) ：用于加载指定名字的行为树，不需要后缀名（文件格式）。</li>
<li>btunload(const char*) ：用于卸载指定名字的行为树。</li>
<li>btsetcurrent(const char*) ：用于设置当前行为树。</li>
<li>btexec() ：执行当前行为树。</li>
<li>SetActive(bool) ：用于停止/继续执行当前行为树，如果设置为false，表示停止执行当前行为树；否则，表示继续执行。</li>
<li>FireEvent(const char*) ：用于发出事件，以便于行为树中绑定的事件得到响应。</li>
<li>SetIdFlag(uint32_t) ：用于设置连调时是否需要跟踪该Agent。通过静态方法SetIdMask()设置全部Agent的Mask值，然后再通过SetIdFlag()设置当前Agent的Flag值。如果IsMasked()返回为真，则表明需要跟踪该Agent。</li>
<li>SetName(const char*) ：用于设置名字。</li>
</ul>
<p>具体的代码可以查看<a href="{{site.repository}}/blob/master/inc/behaviac/agent/agent.h">behaviac/agent/agent.h</a></p>
<h3>Config类</h3>
<p>详见文档《<a href="{{site.url}}{{site.baseurl}}/docs/zh/articles/config/">开发功能开关</a>》。</p>
]]></content:encoded>
					
					<wfw:commentRss>./../../../../../basic_classes/feed/index.html</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
	</channel>
</rss>
