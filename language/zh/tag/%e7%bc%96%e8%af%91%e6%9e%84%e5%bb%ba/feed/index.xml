<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>编译构建 &#8211; behaviac</title>
	<atom:link href="/language/zh/tag/%E7%BC%96%E8%AF%91%E6%9E%84%E5%BB%BA/feed/" rel="self" type="application/rss+xml" />
	<link>/</link>
	<description>Tencent behaviac, Game AI, Behavior Tree, Finite State Machine, Hierarchical Task Network, BT FSM HTN, 腾讯开源, 游戏AI, 行为树,有限状态机,分层任务网络</description>
	<lastBuildDate>Tue, 25 Jul 2017 03:06:50 +0000</lastBuildDate>
	<language>zh-CN</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>https://wordpress.org/?v=5.4.1</generator>
	<item>
		<title>如何编译构建</title>
		<link>/how_to_build/</link>
					<comments>/how_to_build/#comments</comments>
		
		<dc:creator><![CDATA[admin]]></dc:creator>
		<pubDate>Fri, 13 May 2016 02:43:18 +0000</pubDate>
				<category><![CDATA[文章]]></category>
		<category><![CDATA[上手]]></category>
		<category><![CDATA[编译构建]]></category>
		<guid isPermaLink="false">/?p=308</guid>

					<description><![CDATA[如何编译构建 请首先到/language/zh/downloads/下载或克隆源码。 C++运行时库的构建 请参考<a class="moretag" href="/how_to_build/">Read More...</a>]]></description>
										<content:encoded><![CDATA[<h2><span class="ez-toc-section" id="i">如何编译构建</span></h2>
<p id="section">请首先到<a href="/language/zh/downloads/#https://github.com/Tencent/behaviac">/language/zh/downloads/</a>下载或克隆源码。</p>
<h3 id="c"><span class="ez-toc-section" id="C">C++运行时库的构建</span></h3>
<p>请参考文档《<a href="/docs/zh/articles/build/">使用cmake构建C++版运行时库</a>》。</p>
<h4><span class="ez-toc-section" id="i-2">项目文件</span></h4>
<p>从3.6.33版本，我们提供了预先生成的项目文件，如下图：</p>
<p id="NgRlqmF"><img class="alignnone size-full wp-image-2062 " src="/wp-content/uploads/2017/07/img_5976b5154fe90.png" alt="" srcset="/wp-content/uploads/2017/07/img_5976b5154fe90.png 558w, /wp-content/uploads/2017/07/img_5976b5154fe90-300x110.png 300w" sizes="(max-width: 558px) 100vw, 558px" /></p>
<h3><span class="ez-toc-section" id="CUnity">C#和Unity运行时库的构建</span></h3>
<p>安装目录中的/integration/unity是基于Unity C#的单元测试项目。</p>
<p>自己的C#项目需要将目录/integration/unity/Assets/Scripts/behaviac/runtime下的所有源码直接复制过去，如下图所示：</p>
<p><img class="aligncenter size-full wp-image-1365" src="/wp-content/uploads/2016/05/unity_runtime.png" alt="unity_runtime" width="453" height="579" srcset="/wp-content/uploads/2016/05/unity_runtime.png 453w, /wp-content/uploads/2016/05/unity_runtime-235x300.png 235w" sizes="(max-width: 453px) 100vw, 453px" /></p>
<p>如果是Unity平台下的C#开发，还可以在Unity编辑器中导入/integration/behaviac.unitypackage包（安装完发布的BehaviacSetup_***.exe后，会在安装目录中的/integration文件夹中找到该behaviac.unitypackage包）。</p>
<h3><span class="ez-toc-section" id="i-3">编辑器的构建</span></h3>
<p>编辑器的源码目录结构，如下图所示：<br />
<img src="/img/faq/source_designer_path.png" alt="source_designer_path.png" /></p>
<p>请使用vs2010或以上打开并构建<code class="highlighter-rouge">tools/designer/BehaviacDesigner.sln</code>。</p>
]]></content:encoded>
					
					<wfw:commentRss>/how_to_build/feed/</wfw:commentRss>
			<slash:comments>6</slash:comments>
		
		
			</item>
		<item>
		<title>VS项目中使用behaviac组件</title>
		<link>/cpp_include/</link>
					<comments>/cpp_include/#comments</comments>
		
		<dc:creator><![CDATA[admin]]></dc:creator>
		<pubDate>Fri, 13 May 2016 02:44:04 +0000</pubDate>
				<category><![CDATA[文章]]></category>
		<category><![CDATA[上手]]></category>
		<category><![CDATA[C++]]></category>
		<category><![CDATA[编译构建]]></category>
		<category><![CDATA[运行时]]></category>
		<guid isPermaLink="false">/?p=311</guid>

					<description><![CDATA[下载完behaviac组件的全部源码后，整个组件的目录结构，如下图所示： 将behaviac组件整合到自己的项目中时，可以通过两种方式使用behaviac组件：<a class="moretag" href="/cpp_include/">Read More...</a>]]></description>
										<content:encoded><![CDATA[<p id="cbehaviac">下载完behaviac组件的全部源码后，整个组件的目录结构，如下图所示：</p>
<p><img src="/img/tutorials/tutorial16/sourceFolder.png" alt="" /></p>
<p>将behaviac组件整合到自己的项目中时，可以通过两种方式使用behaviac组件：</p>
<ul>
<li>将全部源码（包括behaviac组件的所有<a href="https://github.com/Tencent/behaviac/blob/master/inc/behaviac">.h</a>和<a href="https://github.com/Tencent/behaviac/blob/master/src">.cpp</a>文件）全部复制到自己的游戏项目中。</li>
<li>单独编译behaviac组件库，生成lib文件，然后自己的项目包含.h文件和生成的.lib文件。</li>
</ul>
<p>对于上面的第二种用法，请先参考<a href="/docs/zh/tutorials/how_to_build/">如何编译构建</a>文档来编译构建behavaic组件。</p>
<p>在Windows平台，如果是使用VS来管理项目的，需要在VS的项目“Property Pages”-&gt;“Configuration Properties”-&gt;“C/C++”-&gt;“General”中的“Additional Include Directories”项中添加behaviac组件头文件（即图1中的inc文件夹）所在的路径，如下图所示：</p>
<p><img src="/img/tutorials/tutorial16/includeHeaderSettings.png" alt="" /></p>
<p>再在VS的项目“Property Pages”-&gt;“Configuration Properties”-&gt;“Linker”-&gt;“General”中的“Additional Library Directories”项中添加自己编译出的behaviac lib文件（即图1中的lib文件夹）所在的路径，如下图所示：</p>
<p><img src="/img/tutorials/tutorial16/includeLibSettings.png" alt="" /></p>
<p>最后在VS的项目“Property Pages”-&gt;“Configuration Properties”-&gt;“Linker”-&gt;“Input”中的“Additional Dependencies”项中添加自己编译出的behaviac lib文件，如下图所示：</p>
<p><img src="/img/tutorials/tutorial16/addLibSettings.png" alt="" /></p>
<p>注意：上图中的behaviac_debugdll_win32_vs2010.lib文件是用VS2010编译出来的，说明游戏项目也需要用VS2010来编译。如果你的游戏项目使用其他版本的VS，则编译behaviac组件也需要用相应版本的VS来编译。</p>
]]></content:encoded>
					
					<wfw:commentRss>/cpp_include/feed/</wfw:commentRss>
			<slash:comments>3</slash:comments>
		
		
			</item>
		<item>
		<title>C++生成代码大小的说明</title>
		<link>/code_size/</link>
					<comments>/code_size/#respond</comments>
		
		<dc:creator><![CDATA[jonygli]]></dc:creator>
		<pubDate>Mon, 09 May 2016 03:15:17 +0000</pubDate>
				<category><![CDATA[文章]]></category>
		<category><![CDATA[编译构建]]></category>
		<guid isPermaLink="false">/?p=204</guid>

					<description><![CDATA[C++版本广泛的用到了template。 Code bloat occurs because compilers generate code for all t<a class="moretag" href="/code_size/">Read More...</a>]]></description>
										<content:encoded><![CDATA[<p>C++版本广泛的用到了template。</p>
<blockquote><p>Code bloat occurs because compilers generate code for all templated functions in each translation unit that use them. Back in the day the duplicate code was not consolidated resulting in “code bloat”. These days the duplicate code can be removed at link time.</p></blockquote>
<p>所以，在看到产生的代码的大小后不要过于惊慌。（另外，编译速度也会比较慢。）</p>
<p>在3.4.0后的版本里，behaviac已经支持了Link Time Optimization（LTO）。LTO可以极大的减少产生代码的大小以及优化产生代码的效率。</p>
<h3 id="gcc">gcc</h3>
<ul>
<li>如下所示，通过参数指定<code class="highlighter-rouge">Release</code>以及<code class="highlighter-rouge">ForeUseRelease</code>可以打开LTO（如果你的gcc支持的话）<br />
<code class="highlighter-rouge">cmake -G "Unix Makefiles" -DCMAKE_BUILD_TYPE=Release -DBEHAVIAC_VERSION_MODE=ForeUseRelease --build ../../../..</code></li>
<li>或者通过cmake gui设置<code class="highlighter-rouge">CMAKE_BUILD_TYPE</code>为<code class="highlighter-rouge">Release</code>和<code class="highlighter-rouge">BEHAVIAC_VERSION_MODE</code>为<code class="highlighter-rouge">ForeUseRelease</code></li>
<li>gcc版本需要是4.9以上，低版本不支持LTO</li>
<li>其他版本的gcc请参考相应文档设置LTO</li>
</ul>
<h3 id="msvc">msvc</h3>
<ul>
<li>在visual studio中可以参考打开编译选项/Gy, /GL及/OPT:ICF /OPT:REF /LTCG链接选项</li>
<li>指定<code class="highlighter-rouge">ForeUseRelease</code>的时候，cmake生成的项目文件，在Release下缺省的已经打开上述优化开关。</li>
<li>也可以考虑调整O1,O2或Ox编译选项</li>
</ul>
<p>请参考<a href="http://Tencent.github.io/behaviac/docs/zh/articles/build">构建说明</a></p>
]]></content:encoded>
					
					<wfw:commentRss>/code_size/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>优化及性能</title>
		<link>/performence/</link>
					<comments>/performence/#comments</comments>
		
		<dc:creator><![CDATA[admin]]></dc:creator>
		<pubDate>Fri, 13 May 2016 02:39:39 +0000</pubDate>
				<category><![CDATA[文章]]></category>
		<category><![CDATA[连调]]></category>
		<category><![CDATA[优化]]></category>
		<category><![CDATA[编译构建]]></category>
		<category><![CDATA[运行时]]></category>
		<guid isPermaLink="false">/?p=300</guid>

					<description><![CDATA[优化及性能 宏BEHAVIAC_RELEASE定义的时候是最终版，BEHAVIAC_RELEASE没有定义的时候是为开发版。 在debug版中，BEHAVIAC<a class="moretag" href="/performence/">Read More...</a>]]></description>
										<content:encoded><![CDATA[<h2 id="section">优化及性能</h2>
<p>宏BEHAVIAC_RELEASE定义的时候是最终版，BEHAVIAC_RELEASE没有定义的时候是为开发版。</p>
<ul>
<li>在debug版中，BEHAVIAC_RELEASE缺省下没有定义的。诸如logging、socketing、热加载等开发功能是有效的。可以通过behaviac::Config::IsLogging和behaviac::Config::IsSocketing来控制是否要Log到文件或是否与编辑器的连接。</li>
<li>在release版中，BEHAVIAC_RELEASE缺省是有定义的。诸如logging、socketing、热加载等开发功能都是没有定义的。</li>
</ul>
<div class="note info">
<h5>BEHAVIAC_RELEASE缺省下是否定义的说明</h5>
</div>
<p>BEHAVIAC_RELEASE缺省下是否定义可以参考文章《<a href="/language/zh/build/">构建说明</a>》。</p>
<p>简单来说对于Cpp，当使用CMake的时候，BEHAVIAC_VERSION_MODE用来控制BEHAVIAC_RELEASE是否定义：</p>
<ol>
<li>Default：缺省模式是Debug下BEHAVIAC_RELEASE没有定义，而Release下BEHAVIAC_RELEASE有定义</li>
<li>ForceUseDev：强制不定义BEHAVIAC_RELEASE</li>
<li>ForceUseRelease：强制定义BEHAVIAC_RELEASE</li>
</ol>
<p>而当BEHAVIAC_RELEASE有定义的最终版里，logging和socketing是关闭的，也不支持连接编辑器。</p>
<p>具体可以参考文章《<a href="/language/zh/config/">开发功能开关</a>》。</p>
<p>总之，针对效率可以有下述选择：</p>
<ol>
<li>定义BEHAVIAC_RELEASE，从而不编译诸如logging、socketing、热加载等开发功能，提供最高效率，也不支持连调功能。
<ul>
<li>C++下，在_config.h中定义BEHAVIAC_RELEASE为1</li>
<li>C#下，在Assets目录下的smcs.rsp文件中，定义BEHAVIAC_RELEASE</li>
<li>如果想选择打开或关闭调试功能而不是完全的关闭，则不需要修改任何关于BEHAVIAC_RELEASE的定义，通过behaviac::Config::SetLogging和behaviac::Config::SetSocketing来控制是否打开logging和socketing。</li>
</ul>
</li>
<li>不使用xml或bson格式，而是使用C++或C#格式
<ul>
<li>C#下，还需要那些在行为树中使用到的Agent的成员都是public的（非public的成员即使通过C#代码访问也需要使用反射系统来进行，会导致GC Alloc以及性能损失）。</li>
</ul>
</li>
</ol>
<div class="note info">
<h5>overhead</h5>
</div>
<p>behaviac可以导出xml(bson)，或者源码（cpp/c#），源码的效率要优于数据（xml/bson）的执行效率。实际上这里的效率都是指的behaviac本身的overhead，如果提供的<code class="highlighter-rouge">方法</code>本身效率很低，运行很慢，behaviac本身的overhead就可以忽略不计了，无论是选用导出何种格式都遇事无补，这个时候，最需要解决的是优化方法的执行效率。</p>
<p><img src="/img/references/overhead.png" alt="overhead" /><br />
如上图，尽管xml格式是cpp格式的大约2倍，但这个overhead实际上是非常小的，只有0.0000269秒，0.0269毫秒。（具体数据会因为测试环境的不同有差异）。</p>
]]></content:encoded>
					
					<wfw:commentRss>/performence/feed/</wfw:commentRss>
			<slash:comments>3</slash:comments>
		
		
			</item>
		<item>
		<title>开发功能开关</title>
		<link>/config/</link>
					<comments>/config/#comments</comments>
		
		<dc:creator><![CDATA[jonygli]]></dc:creator>
		<pubDate>Mon, 11 Apr 2016 09:57:37 +0000</pubDate>
				<category><![CDATA[文章]]></category>
		<category><![CDATA[连调]]></category>
		<category><![CDATA[概述]]></category>
		<category><![CDATA[编译构建]]></category>
		<guid isPermaLink="false">/?p=160</guid>

					<description><![CDATA[behaviac的运行时提供有核心的更新行为树的功能，在其之上，还有logging，热加载，连调等调试功能。这些调试功能只是‘开发’功能，在游戏发布后实际上是不<a class="moretag" href="/config/">Read More...</a>]]></description>
										<content:encoded><![CDATA[<p>behaviac的运行时提供有核心的更新行为树的功能，在其之上，还有logging，热加载，连调等调试功能。这些调试功能只是‘开发’功能，在游戏发布后实际上是不需要的。</p>
<p>除了可以在<code>config.h</code>中定义<code>BEHAVIAC_RELEASE</code>宏为1来完全使‘开发功能’不被编译外。也可以保留这些‘开发’功能但只是使用下面所列的‘开关’来关闭或者打开某些功能。</p>
<p>具体可以参考<a href="/language/zh/tutorial10_performence/">优化及性能</a></p>
<h2>Cpp</h2>
<pre class="brush: cpp; title: ; notranslate">namespace behaviac
{
class BEHAVIAC_API Config
{
public:
static bool IsProfiling();
static void SetProfiling(bool bEnabled);

//logging是否打开
static bool IsLogging();
static void SetLogging(bool bLogging);

//logging打开的情况下，是否每次logging的时候都Flush
static bool IsLoggingFlush();
static void SetLoggingFlush(bool bFlush);

//socket连接是否打开，只有打开socket连接，连调功能才会支持
static bool IsSocketing();
static void SetSocketing(bool bSocketing);

//是否是阻塞模式，当时阻塞模式的时候，游戏会阻塞，等待编辑器的连接，
//只有成功建立连接后，游戏才继续运行
static bool IsSocketBlocking();
static void SetSocketBlocking(bool bBlocking);

//游戏和编辑器建立连接的时候使用的端口
static void SetSocketPort(unsigned short port);
static unsigned short GetSocketPort();

//热加载是否打开
static bool IsHotReload();
static void SetHotReload(bool bHotReload);
};</pre>
<p>具体的代码可以查看<a href="{{site.repository}}/blob/master/inc/behaviac/base/workspace.h">behaviac/base/workspace.h</a></p>
<h2>Unity</h2>
<p>C#下同名函数的意义和Cpp一样，此外，<code>IsSuppressingNonPublicWarning</code>是个用来控制是否输出非public成员的警告。</p>
<p>当<code>IsSuppressingNonPublicWarning</code>为true的时候，Agent的成员（field，method，property）如果不是public的，则输出警告信息，从而可以修改其为public，这样的话，当使用导出格式为c#时其效率就是最高的，而且没有GC Alloc。</p>
<p>具体的代码请查看<a href="{{site.repository}}/blob/master/integration/unity/Assets/Scripts/behaviac/runtime/Workspace.cs">behaviac/runtime/workspace.cs</a></p>
]]></content:encoded>
					
					<wfw:commentRss>/config/feed/</wfw:commentRss>
			<slash:comments>4</slash:comments>
		
		
			</item>
		<item>
		<title>使用cmake构建C++版运行时库</title>
		<link>/build/</link>
					<comments>/build/#comments</comments>
		
		<dc:creator><![CDATA[jonygli]]></dc:creator>
		<pubDate>Mon, 11 Apr 2016 09:55:36 +0000</pubDate>
				<category><![CDATA[文章]]></category>
		<category><![CDATA[上手]]></category>
		<category><![CDATA[C++]]></category>
		<category><![CDATA[编译构建]]></category>
		<guid isPermaLink="false">/?p=156</guid>

					<description><![CDATA[请首先到/language/zh/downloads/下载或克隆源码。 缺省的，我们使用cmake来生成对应平台的<a class="moretag" href="/build/">Read More...</a>]]></description>
										<content:encoded><![CDATA[<p>请首先到<a href="/language/zh/downloads/#https://github.com/Tencent/behaviac">/language/zh/downloads/</a>下载或克隆源码。</p>
<p id="cpp">缺省的，我们使用<a href="https://cmake.org/download/">cmake</a>来生成对应平台的项目文件（sln或make文件等）。</p>
<p>但cmake不是必须的，也可以选择自己喜欢的方式创建自己的项目文件。比如，使用premake等来生成项目文件，或者手工创建。</p>
<h3></h3>
<h3 id="windows"><span class="ez-toc-section" id="Windows">Windows平台</span></h3>
<ul>
<li>下载并安装<a href="https://cmake.org/download/">cmake</a>，请使用3.3以上版本</li>
<li>cmake的路径需要添加到环境变量PATH</li>
<li>运行build目录下的cmake_generate_projects.bat生成项目文件</li>
<li>如果需要build android版本
<ul>
<li>需要安装vs2015</li>
<li>使用android_vs2015子目录下的项目文件</li>
<li>或者使用cmake生成项目文件
<ul>
<li>下载并安装<a href="https://github.com/Microsoft/CMake/releases">cmake android</a>, 直接覆盖上面步骤安装的cmake就好。</li>
<li>运行build目录下的cmake_generate_projects_android.bat生成项目文件</li>
<li>如果想使用mk，可以修改生成的linux下的make文件</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="section"><span class="ez-toc-section" id="i">其他平台</span></h3>
<ul>
<li>下载并安装<a href="https://cmake.org/">cmake</a>，请使用3.3以上版本</li>
<li>如果可能，请保证4.4.6以上版本的gcc
<ul>
<li>使用版本为4.4.6的gcc可以顺利编译，但4.1.2的gcc有错误（未测试低于4.4.6的版本）</li>
</ul>
</li>
<li>运行build目录下的cmake_generate_projects.sh生成项目文件
<ul>
<li>mac上，运行build目录下的cmake_generate_projects_mac.sh生成项目文件</li>
</ul>
</li>
</ul>
<h3 id="section-1"><span class="ez-toc-section" id="i-2">注意</span></h3>
<ol>
<li>cmake_generate*.bat里使用的是vs2013和vs2015，用户可以根据自己的需要选择相应的编译器，比如vs2008、vs2010等，或者通过cmakegui进行选择。</li>
<li>CMakeLists.txt里提供的是缺省设置，可以根据自己的需要直接修改或通过cmakegui来选择配置。特别的，CMakeLists.txt里有若干个选项可以配置。<br />
<img src="/img/concepts/cmake_config.png" alt="cmake_config" /></p>
<ul>
<li>BEHAVIAC_VERSION_MODE用来控制BEHAVIAC_RELEASE是否定义。BEHAVIAC_RELEASE的用途请参考文章《<a href="/docs/zh/articles/tutorial10_performence">优化及性能</a>》。
<ul>
<li>Default：缺省模式是Debug下BEHAVIAC_RELEASE没有定义，而Release下BEHAVIAC_RELEASE有定义</li>
<li>ForceUseDev：强制不定义BEHAVIAC_RELEASE</li>
<li>ForceUseRelease：强制定义BEHAVIAC_RELEASE
<ul>
<li>在ForceUseRelease的时候，Release下，生成的项目文件会试图打开LTO开关，请参考文档《<a href="/docs/zh/articles/code_size">Cpp生成代码大小的说明</a>》</li>
</ul>
</li>
</ul>
</li>
<li>CMAKE_BUILD_TYPE用来控制生成Debug还是Release（Visual Studio的时候不需要指定CMAKE_BUILD_TYPE）</li>
<li>BUILD_SHARED_LIBS用来控制libbehaviac是stati lib/a还是dynamid dll/so</li>
<li>BUILD_USE_64BITS用来控制是否生成64位 （使用Visual Studio时，需要指定带Win64的generator，请参考cmake的文档）</li>
<li>根据上面的配置，CMake生成下面的_config.h文件，用来自动定义宏BEHAVIAC_RELEASE，如下图所示：<img class="aligncenter size-full wp-image-1650" src="/wp-content/uploads/2016/04/config.png" alt="" width="874" height="286" srcset="/wp-content/uploads/2016/04/config.png 874w, /wp-content/uploads/2016/04/config-300x98.png 300w, /wp-content/uploads/2016/04/config-768x251.png 768w" sizes="(max-width: 874px) 100vw, 874px" /></li>
<li>在另一个文件config.h中，会根据_DEBUG或DEBUG宏来尝试重新定义宏BEHAVIAC_RELEASE，如果在_config.h中宏BEHAVIAC_RELEASE并没有定义，如下图所示：<img class="aligncenter size-full wp-image-1651" src="/wp-content/uploads/2016/04/config-1.png" alt="" width="855" height="372" srcset="/wp-content/uploads/2016/04/config-1.png 855w, /wp-content/uploads/2016/04/config-1-300x131.png 300w, /wp-content/uploads/2016/04/config-1-768x334.png 768w" sizes="(max-width: 855px) 100vw, 855px" /></li>
</ul>
</li>
<li>cmake不是必须的
<ul>
<li>你可以选择自己喜欢的其他类似工具，比如premake等来生成项目文件。</li>
<li>或者，你可以手工创建项目文件。</li>
<li>又或者，可以直接把src和inc加到你已有的项目文件。</li>
<li>当你自行修改或创建项目文件的时候，可能需要参考CMakeLists.txt查看需要的设置：
<ul>
<li>include_directories包含目录，你需要设置正确的包含目录</li>
<li>add_definitions编译宏，比如_DEBUG</li>
<li>add_target_definitions编译宏，比如BEHAVIACDLL_EXPORTS，BEHAVIAC_DLL</li>
<li>CMAKE_CXX_FLAGS编译开关</li>
<li>BUILD_SHARED_LIBS是否动态库还是静态库</li>
</ul>
</li>
</ul>
</li>
<li>build\android_vs2015是提供的缺省的使用Visual Studio 2015来生成android项目的项目工程，支持64位。</li>
<li>可以使用cmakegui选择设置，或者在cmake的命令行里指定设置（ -DCMAKE_BUILD_TYPE=Debug -DBUILD_USE_64BITS=ON等）。请参考<a href="https://github.com/Tencent/behaviac/blob/master/build/cmake_generate_projects.bat">build/cmake_generate_projects.bat</a>或者cmake文档。</li>
</ol>
<h3 id="section-2"><span class="ez-toc-section" id="i-3">构建</span></h3>
<ul>
<li>无论Windows平台还是其他平台，项目文件都生成到目录cmake_binary</li>
<li>项目文件生成到目录cmake_binary，根据选用的编译工具（vs2013、make等）打开相应目录的项目文件或运行make等进行构建</li>
<li>.a、.lib、.dll、.exe等被生成到根目录的lib目录和bin目录</li>
<li>生成的项目配置(mvsc, linxu, xcode)包含了Debug和Release，请根据需要构建Debug或Release版本</li>
</ul>
<h2 id="unity"></h2>
]]></content:encoded>
					
					<wfw:commentRss>/build/feed/</wfw:commentRss>
			<slash:comments>6</slash:comments>
		
		
			</item>
	</channel>
</rss>
