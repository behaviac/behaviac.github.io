<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>概念 &#8211; behaviac</title>
	<atom:link href="/language/zh/tag/%E6%A6%82%E5%BF%B5/feed/" rel="self" type="application/rss+xml" />
	<link>/</link>
	<description>Tencent behaviac, Game AI, Behavior Tree, Finite State Machine, Hierarchical Task Network, BT FSM HTN, 腾讯开源, 游戏AI, 行为树,有限状态机,分层任务网络</description>
	<lastBuildDate>Tue, 08 Aug 2017 03:19:05 +0000</lastBuildDate>
	<language>zh-CN</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>https://wordpress.org/?v=5.4.1</generator>
	<item>
		<title>behaviac到底是什么</title>
		<link>/what_is_behaviac/</link>
					<comments>/what_is_behaviac/#respond</comments>
		
		<dc:creator><![CDATA[jonygli]]></dc:creator>
		<pubDate>Mon, 11 Apr 2016 10:02:27 +0000</pubDate>
				<category><![CDATA[文章]]></category>
		<category><![CDATA[概念]]></category>
		<guid isPermaLink="false">/?p=170</guid>

					<description><![CDATA[简述 behaviac是游戏AI的开发框架组件，也是游戏原型的快速设计工具。支持全平台，适用于客户端和服务器，助力游戏快速迭代开发 。 编辑器可以运行在PC上，<a class="moretag" href="/what_is_behaviac/">Read More...</a>]]></description>
										<content:encoded><![CDATA[<h2 id="section"><span class="ez-toc-section" id="i">简述</span></h2>
<p>behaviac是游戏AI的开发框架组件，也是游戏原型的快速设计工具。支持全平台，适用于客户端和服务器，助力游戏快速迭代开发 。</p>
<p>编辑器可以运行在PC上，操作方便直观可靠，支持实时和离线调试；编辑器可以导出xml，bson等多种格式，更可以导出C++、C#源码，提供最高效率。</p>
<p>运行时支持全平台，有C++和C#两个版本，原生支持Unity。</p>
<p>已被多款知名游戏及更多其他预研项目使用。</p>
<p>所有代码，包括编辑器和运行时<a href="https://github.com/Tencent/behaviac">全部开源https://github.com/Tencent/behaviac</a></p>
<h2 id="section-1"><span class="ez-toc-section" id="i-2">编辑器和运行时</span></h2>
<p>behaviac作为游戏AI的开发框架组件，有编辑器和运行时两个部分，这两个部分通过类型信息（描述AI实例属性和能力方法的信息）交换信息。<br />
<img class="aligncenter size-full wp-image-1406" src="/wp-content/uploads/2016/12/architecture-2.png" alt="" width="687" height="603" srcset="/wp-content/uploads/2016/12/architecture-2.png 687w, /wp-content/uploads/2016/12/architecture-2-300x263.png 300w" sizes="(max-width: 687px) 100vw, 687px" /></p>
<h3 id="section-2"><span class="ez-toc-section" id="i-3">类型信息</span></h3>
<p>类型信息用来描述类型的属性和方法。在3.5及之前的旧版本通过运行时端导出类型信息，3.6及之后的新版本通过编辑器创建类型信息，如下所示。编辑器中，该类型信息作为基本的语法单位用来创建行为树。</p>
<pre class="brush: cpp; title: ; notranslate">&lt;agent classfullname=&quot;framework::GameObject&quot; base=&quot;behaviac::Agent&quot; inherited=&quot;true&quot; DisplayName=&quot;&quot; Desc=&quot;&quot; IsRefType=&quot;true&quot;&gt;
&lt;Member Name=&quot;HP&quot; DisplayName=&quot;&quot; Desc=&quot;&quot; Type=&quot;uint&quot; Class=&quot;framework::GameObject&quot; /&gt;
&lt;Member Name=&quot;age&quot; DisplayName=&quot;&quot; Desc=&quot;&quot; Type=&quot;long&quot; Class=&quot;framework::GameObject&quot; /&gt;
&lt;Method Name=&quot;GoStraight&quot; DisplayName=&quot;&quot; Desc=&quot;&quot; Class=&quot;framework::GameObject&quot; ReturnType=&quot;void&quot;&gt;
&lt;Param DisplayName=&quot;speed&quot; Desc=&quot;speed&quot; Type=&quot;int&quot; /&gt;
&lt;/Method&gt;
&lt;Method Name=&quot;TurnTowardsTarget&quot; DisplayName=&quot;&quot; Desc=&quot;&quot; Class=&quot;framework::GameObject&quot; ReturnType=&quot;int&quot;&gt;
&lt;Param DisplayName=&quot;turnSpeed&quot; Desc=&quot;turnSpeed&quot; Type=&quot;float&quot; /&gt;
&lt;/Method&gt;
&lt;Method Name=&quot;alignedWithPlayer&quot; DisplayName=&quot;&quot; Desc=&quot;&quot; Class=&quot;framework::GameObject&quot; ReturnType=&quot;bool&quot; /&gt;
&lt;Method Name=&quot;playerIsAligned&quot; DisplayName=&quot;&quot; Desc=&quot;&quot; Class=&quot;framework::GameObject&quot; ReturnType=&quot;bool&quot; /&gt;
&lt;Method Name=&quot;projectileNearby&quot; DisplayName=&quot;&quot; Desc=&quot;&quot; Class=&quot;framework::GameObject&quot; ReturnType=&quot;bool&quot;&gt;
&lt;Param DisplayName=&quot;radius&quot; Desc=&quot;radius&quot; Type=&quot;float&quot; /&gt;
&lt;/Method&gt;
&lt;Method Name=&quot;distanceToPlayer&quot; DisplayName=&quot;&quot; Desc=&quot;&quot; Class=&quot;framework::GameObject&quot; ReturnType=&quot;float&quot; /&gt;
&lt;/agent&gt;</pre>
<p>在3.x版本之前的版本中，类型信息必须通过运行时来导出，策划需要新的属性或方法时，必须等待程序员更新代码重现导出类型信息后才能使用。而在3.x版本中，可以直接在编辑器中创建一个类型，并且创建它的属性和方法，而且可以导出类型的c++或c#源码，这极大的加速了迭代的过程，从而把编辑器作为一个原型设计工具。</p>
<h3 id="section-3"><span class="ez-toc-section" id="i-4">编辑器</span></h3>
<p>编辑器是一个可以运行在Windows平台上的编辑工具。<br />
<img src="/img/whatisbehaviac/designer.png" alt="designer" /><br />
在编辑器内，使用鼠标或快捷键，可以添加、编辑、配置、修改行为树（包括FSM，或HTN），也可以实时或离线调试游戏的行为，既可以设断点，也可以查看或修改变量的值。</p>
<h3 id="section-4"><span class="ez-toc-section" id="i-5">运行时</span></h3>
<p>运行时有C++和C#两个版本，Unity使用C#的实现，像是cocos等使用C++的引擎或平台使用C++的实现。其具体逻辑是一致的，即加载编辑器中导出的行为树，解释运行之。</p>
<pre class="brush: cpp; title: ; notranslate">

g_player = behaviac::Agent::Create&lt;CBTPlayer&gt;();

bool bRet = false;
bRet = g_player-&gt;btload(pszTreeName);
assert(bRet);

g_player-&gt;btsetcurrent(pszTreeName);

behaviac::EBTStatus status = behaviac::BT_RUNNING;

while (status == behaviac::BT_RUNNING)
{
status = g_player-&gt;btexec();
}</pre>
<div class="highlighter-rouge"></div>
<h3 id="section-5"><span class="ez-toc-section" id="i-6">导出和调试</span></h3>
<p>在编辑器内创建好行为后，需要导出，然后运行时才可以加载运行。编辑器支持导出多种格式：</p>
<ol>
<li>xml</li>
<li>bson</li>
<li>cpp</li>
<li>c#</li>
</ol>
<p>其中xml和bson作为数据，可以被加载，而cpp或c#作为源码直接编辑链接进程序，用户可以根据需要选择使用最合适的格式。</p>
<h2 id="behaviac"><span class="ez-toc-section" id="behaviac">behaviac能解决什么问题</span></h2>
<ul>
<li>behaviac作为游戏AI的开发框架组件，主要是用来开发游戏AI。</li>
<li>behaviac的编辑器使用图形化的界面（Visual scripting）和操作，操作直观方便。</li>
<li>游戏中的NPC，小怪，老怪等等的游戏逻辑都可以通过behaviac来创建和开发。</li>
<li>behaviac并不限于开发游戏AI的游戏逻辑，也可以用来开发组队逻辑（Squad Logic），策略AI（Strategy AI），玩家Avatar，甚至关卡设计等各种游戏场景。</li>
<li>behaviac还可以用作原型设计工具，策划只是使用behaviac编辑器来设计类型安全的，表达严谨的游戏逻辑。</li>
<li>C#版本的运行时原生支持unity，behaviac可以在unity内开发游戏AI</li>
<li>在iOS平台，作为热更新的一种手段</li>
<li>C++版本支持全平台，不仅可以用在客户端，也可以用在服务器端。一套逻辑，可以根据情况分别在客户端，服务器运行，避免重复开发。</li>
</ul>
<h2 id="behaviac-1"><span class="ez-toc-section" id="behaviac-2">behaviac有哪些主要特性</span></h2>
<ul>
<li>behaviac是游戏AI的开发框架组件，也是游戏原型的快速设计工具</li>
<li>支持持行为树（BT），状态机（FSM），层次任务网络（HTN）等多种范式</li>
<li>编辑器可以运行在PC上，操作方便直观可靠</li>
<li>编辑器可以导出xml，bson等多种格式，更可以导出C++，C#源码，提供最高效率</li>
<li>支持实时和离线调试，可以设断点，查看或修改变量</li>
<li>编辑器通过socket和游戏连接实现实时调试，支持远程实时调试</li>
<li>运行时支持全平台（Windows/Linux/iOS/Android等），有C++和C#两个版本，原生支持Unity。适用于客户端和服务器，助力游戏快速迭代开发</li>
<li>支持热加载，可以不用重启游戏就更新行为树</li>
<li>中英文界面可选，类型信息可以提供中英文显示信息</li>
<li>支持预制件（Prefab）、子树，方便重用共享</li>
<li>支持自定义数据类型，支持已有第3方库中的自定义类型</li>
<li>支持扩展节点类型</li>
</ul>
<hr />
<p><a href="/docs/zh/articles/overview/">可以继续阅读behaviac概述 →</a></p>
]]></content:encoded>
					
					<wfw:commentRss>/what_is_behaviac/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>Agent实例的用法</title>
		<link>/instance/</link>
					<comments>/instance/#respond</comments>
		
		<dc:creator><![CDATA[admin]]></dc:creator>
		<pubDate>Fri, 13 May 2016 02:44:53 +0000</pubDate>
				<category><![CDATA[3.5]]></category>
		<category><![CDATA[上手]]></category>
		<category><![CDATA[概念]]></category>
		<guid isPermaLink="false">/?p=313</guid>

					<description><![CDATA[在编辑器的节点属性窗口中，为了给某个节点选择和配置属性，首先需要选择一个实例（instance），然后再选择该实例的属性或方法，如下图所示： 这些实例主要来自于<a class="moretag" href="/instance/">Read More...</a>]]></description>
										<content:encoded><![CDATA[<p>在编辑器的节点属性窗口中，为了给某个节点选择和配置属性，首先需要选择一个实例（instance），然后再选择该实例的属性或方法，如下图所示：</p>
<p><img class="aligncenter" src="/img/tutorials/tutorial17/instance_list.png" alt="" /></p>
<p>这些实例主要来自于如下三个方面：</p>
<ul>
<li>Self：表示当前行为树根节点所配置的Agent类型的实例，类似于程序语言中的this。</li>
<li>成员实例：当前行为树根节点所配置的Agent类型的成员属性、自定义属性或局部变量，也是Agent或其子类类型。</li>
<li>全局实例：运行时端（游戏端）注册和导出的各种Agent或其子类的全局实例。</li>
</ul>
<p>其中，成员实例无需编写额外代码来进行注册和导出，behaviac组件会自动根据当前行为树根节点所配置的Agent类型，列举出所有的成员实例以供选择。但在使用该成员实例之前，需要确保该实例已经赋过值，不是空指针/引用。</p>
<p>对于全局实例，在运行时端（游戏端）的各种Agent或其子类实例的名字注册和绑定的设计意图，主要是为了支持单件（Singleton）或者类似确定的全局性的实例（同一个类可能会有若干个实例而不是仅仅有一个实例），例如：player，camera，director等。</p>
<p>注意：只有通过RegisterInstanceName注册过的“名字”才在导出元信息时被导出；而BindInstance和Create等与实例相关的函数在执行行为树的时候才需要，如果只是导出元信息则不需要。</p>
<h3 id="c">C++中全局实例的注册</h3>
<p>Agent::RegisterInstanceName可以注册一个名字，该名字表示游戏中某个Agent类的实例，如下代码所示：</p>
<div class="highlighter-rouge">
<pre class="highlight"><code>
<span class="n">behaviac</span><span class="o">::</span><span class="n">Agent</span><span class="o">::</span><span class="n">RegisterInstanceName</span><span class="o">&lt;</span><span class="n">AgentNodeTest</span><span class="o">&gt;</span><span class="p">();</span>
<span class="n">behaviac</span><span class="o">::</span><span class="n">Agent</span><span class="o">::</span><span class="n">RegisterInstanceName</span><span class="o">&lt;</span><span class="n">behaviac</span><span class="o">::</span><span class="n">Agent</span><span class="o">&gt;</span><span class="p">(</span><span class="s">"Name_Agent_0"</span><span class="p">);</span>

</code></pre>
</div>
<p>需要说明的是，游戏中需要调用Agent::Create或Agent::BindInstance创建实例并且绑定到该名字。如果指定的名字没有注册或注册的类型不同或该名字已经绑定，则调用Agent::Create的时候会有runtime的错误。</p>
<p>当调用Agent::RegisterInstanceName和Agent::Create而没有指定名字的时候，该Agent类型的名字将作为实例的名字被注册和绑定，如下代码所示：</p>
<div class="highlighter-rouge">
<pre class="highlight"><code>
<span class="n">behaviac</span><span class="o">::</span><span class="n">Agent</span><span class="o">*</span> <span class="n">testAgentA</span> <span class="o">=</span> <span class="n">behaviac</span><span class="o">::</span><span class="n">Agent</span><span class="o">::</span><span class="n">Create</span><span class="o">&lt;</span><span class="n">behaviac</span><span class="o">::</span><span class="n">Agent</span><span class="o">&gt;</span><span class="p">(</span><span class="s">"Name_Agent_0"</span><span class="p">);</span>
<span class="n">AgentNodeTest</span><span class="o">*</span> <span class="n">testAgentB</span> <span class="o">=</span> <span class="n">behaviac</span><span class="o">::</span><span class="n">Agent</span><span class="o">::</span><span class="n">Create</span><span class="o">&lt;</span><span class="n">AgentNodeTest</span><span class="o">&gt;</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>

<span class="n">behaviac</span><span class="o">::</span><span class="n">Agent</span><span class="o">*</span> <span class="n">testAgent_0</span> <span class="o">=</span> <span class="n">behaviac</span><span class="o">::</span><span class="n">Agent</span><span class="o">::</span><span class="n">GetInstance</span><span class="o">&lt;</span><span class="n">behaviac</span><span class="o">::</span><span class="n">Agent</span><span class="o">&gt;</span><span class="p">(</span><span class="s">"Name_Agent_0"</span><span class="p">);</span>
<span class="n">AgentNodeTest</span><span class="o">*</span> <span class="n">testAgent_1</span> <span class="o">=</span> <span class="n">behaviac</span><span class="o">::</span><span class="n">Agent</span><span class="o">::</span><span class="n">GetInstance</span><span class="o">&lt;</span><span class="n">AgentNodeTest</span><span class="o">&gt;</span><span class="p">();</span>

<span class="n">behaviac</span><span class="o">::</span><span class="n">Agent</span><span class="o">::</span><span class="n">BindInstance</span><span class="p">(</span><span class="n">testAgent_0</span><span class="p">,</span> <span class="s">"Name_Agent_0"</span><span class="p">);</span>
<span class="n">behaviac</span><span class="o">::</span><span class="n">Agent</span><span class="o">::</span><span class="n">BindInstance</span><span class="p">(</span><span class="n">testAgent_1</span><span class="p">,</span> <span class="err">“</span><span class="n">AgentNodeTest</span><span class="err">”</span><span class="p">);</span>

<span class="n">CHECK_EQUAL</span><span class="p">(</span><span class="n">testAgent_0</span><span class="p">,</span> <span class="n">testAgentA</span><span class="p">);</span>
<span class="n">CHECK_EQUAL</span><span class="p">(</span><span class="n">testAgent_1</span><span class="p">,</span> <span class="n">testAgentB</span><span class="p">);</span>

<span class="n">behaviac</span><span class="o">::</span><span class="n">Agent</span><span class="o">::</span><span class="n">UnbindInstance</span><span class="p">(</span><span class="s">"Name_Agent_0"</span><span class="p">);</span>
<span class="n">behaviac</span><span class="o">::</span><span class="n">Agent</span><span class="o">::</span><span class="n">UnbindInstance</span><span class="p">(</span><span class="s">"AgentNodeTest"</span><span class="p">);</span>

</code></pre>
</div>
<p>更多细节可以参考behaviac组件C++源码中附带的test工程的<a href="https://github.com/Tencent/behaviac/blob/master/test/btunittest/Others/btloadtest.cpp">btloadtest.cpp</a>文件。</p>
<h3 id="c-">C# 中全局实例的注册</h3>
<p>类似的，在C#中实例的注册和绑定相关代码如下：</p>
<pre><span class="n">behaviac</span><span class="p">.</span><span class="n">Agent</span><span class="p">.</span><span class="n">RegisterInstanceName</span><span class="p">&lt;</span><span class="n">AgentNodeTest</span><span class="p">&gt;();</span> <span class="n">behaviac</span><span class="p">.</span><span class="n">Agent</span><span class="p">.</span><span class="n">RegisterInstanceName</span><span class="p">&lt;</span><span class="n">behaviac</span><span class="p">.</span><span class="n">Agent</span><span class="p">&gt;(</span><span class="s">"Name_Agent_0"</span><span class="p">);</span> 

<span class="n">behaviac</span><span class="p">.</span><span class="n">Agent</span><span class="p">.</span><span class="nf">BindInstance</span><span class="p">(</span><span class="n">parTestAgent</span><span class="p">,</span> <span class="s">"Name_Agent_0"</span><span class="p">);</span> <span class="n">behaviac</span><span class="p">.</span><span class="n">Agent</span><span class="p">.</span><span class="nf">BindInstance</span><span class="p">(</span><span class="n">nodeTestAgent</span><span class="p">,</span> <span class="s">"AgentNodeTest"</span><span class="p">);

</span><span class="n">behaviac</span><span class="p">.</span><span class="n">Agent</span> <span class="n">testAgent_0</span> <span class="p">=</span> <span class="n">behaviac</span><span class="p">.</span><span class="n">Agent</span><span class="p">.</span><span class="n">GetInstance</span><span class="p">&lt;</span><span class="n">behaviac</span><span class="p">.</span><span class="n">Agent</span><span class="p">&gt;(</span><span class="s">"Name_Agent_0"</span><span class="p">);
</span><span class="n">AgentNodeTest</span> <span class="n">testAgent_1</span> <span class="p">=</span> <span class="n">behaviac</span><span class="p">.</span><span class="n">Agent</span><span class="p">.</span><span class="n">GetInstance</span><span class="p">&lt;</span><span class="n">AgentNodeTest</span><span class="p">&gt;();</span> 
<span class="n">AgentNodeTest</span> <span class="n">testAgent_3</span> <span class="p">=</span> <span class="n">behaviac</span><span class="p">.</span><span class="n">Agent</span><span class="p">.</span><span class="nf">GetAgent</span><span class="p">(</span><span class="s">"AgentNodeTest"</span><span class="p">)</span> <span class="k">as</span> <span class="n">AgentNodeTest</span><span class="p">;

</span><span class="n">Assert</span><span class="p">.</span><span class="nf">AreEqual</span><span class="p">(</span><span class="n">testAgent_0</span><span class="p">,</span> <span class="n">parTestAgent</span><span class="p">);
</span><span class="n">Assert</span><span class="p">.</span><span class="nf">AreEqual</span><span class="p">(</span><span class="n">testAgent_1</span><span class="p">,</span> <span class="n">nodeTestAgent</span><span class="p">);
</span><span class="n">Assert</span><span class="p">.</span><span class="nf">AreEqual</span><span class="p">(</span><span class="n">testAgent_1</span><span class="p">,</span> <span class="n">testAgent_3</span><span class="p">);

</span><span class="n">Assert</span><span class="p">.</span><span class="nf">NotNull</span><span class="p">(</span><span class="n">testAgent_0</span><span class="p">);
</span><span class="n">Assert</span><span class="p">.</span><span class="nf">NotNull</span><span class="p">(</span><span class="n">testAgent_1</span><span class="p">);

</span><span class="n">behaviac</span><span class="p">.</span><span class="n">Agent</span><span class="p">.</span><span class="nf">UnbindInstance</span><span class="p">(</span><span class="s">"Name_Agent_0"</span><span class="p">);
</span><span class="n">behaviac</span><span class="p">.</span><span class="n">Agent</span><span class="p">.</span><span class="nf">UnbindInstance</span><span class="p">(</span><span class="s">"AgentNodeTest"</span><span class="p">);</span></pre>
<p>更多细节可以参考behaviac组件C#源码中附带的integration/unity工程的<a href="https://github.com/Tencent/behaviac/blob/master/integration/unity/Assets/Scripts/behaviac/BehaviacUnitTest/Editor/ParUnitTest/OtherUnitTest.cs">OtherUnitTest.cs</a>文件。</p>
<div class="section-nav"></div>
]]></content:encoded>
					
					<wfw:commentRss>/instance/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>事件处理</title>
		<link>/tutorial11_event/</link>
					<comments>/tutorial11_event/#respond</comments>
		
		<dc:creator><![CDATA[admin]]></dc:creator>
		<pubDate>Fri, 13 May 2016 02:40:42 +0000</pubDate>
				<category><![CDATA[3.5]]></category>
		<category><![CDATA[事件]]></category>
		<category><![CDATA[概念]]></category>
		<guid isPermaLink="false">/?p=302</guid>

					<description><![CDATA[事件处理 执行行为树的过程中，当状态、条件发生变化或发生事件（Event）时，如何响应或打断当前的执行是个重要的问题。 目前behaviac组件支持三种方式来处<a class="moretag" href="/tutorial11_event/">Read More...</a>]]></description>
										<content:encoded><![CDATA[<h3><span class="ez-toc-section" id="i">事件处理</span></h3>
<p id="section">执行行为树的过程中，当状态、条件发生变化或发生事件（Event）时，如何响应或打断当前的执行是个重要的问题。</p>
<p>目前behaviac组件支持三种方式来处理状态变化或事件发生：并行节点、选择监测节点、事件附件等。</p>
<p>简而言之，并行和选择监测节点的工作方式是采用“轮询”的方式，每次执行时需要重新评估所有子节点，而不是像其他节点会保留上一次正在执行的子节点以便在下一次执行时继续执行。事件附件是在游戏逻辑发出事件时，才按需得到响应。</p>
<h3 id="section-1"><span class="ez-toc-section" id="i-2">并行节点</span></h3>
<p>依靠并行（Parallel）节点处理事件，需要把事件用条件的形式表达并且需要监控该条件，当该条件不满足的时候就退出。这种方式在概念上不太清晰，使用起来也比较繁琐，如下图所示：</p>
<p><img class="aligncenter" src="/img/overview/parallel.png" alt="" /></p>
<h3 id="section-2"><span class="ez-toc-section" id="i-3">选择监测节点</span></h3>
<p>选择监测（SelectorMonitor）和监测分支（WithPrecondition）节点作为对传统行为树的扩展，可以很自然的处理事件和状态的改变。选择监测和监测分支节点只能配对使用，即选择监测只能添加监测分支作为它的子节点，监测分支也只能作为选择监测的子节点被添加，如下图所示：</p>
<ul>
<li>选择监测节点是一个动态的选择节点，和选择（Selector）节点相同的是，它选择第一个返回成功的子节点，但不同的是，它不是只选择一次，而是每次执行时都对其子节点重新进行选择。</li>
<li>监测分支节点有条件分支子树和动作分支子树。只有条件分支子树返回成功的时候，动作分支子树才能够被执行。</li>
</ul>
<p><img class="aligncenter" src="/img/overview/selectormonitor.png" alt="" /></p>
<h3><span class="ez-toc-section" id="i-4">事件附件</span></h3>
<p>事件（Event）作为一种附件，是behaviac组件的一大特色。事件主要用于在游戏逻辑发出事件时，得到响应后打断当前正在执行的行为树，并切换到所设置的另一个行为树。</p>
<p>用一个具体例子来说明事件的原理和用法：</p>
<ul>
<li>首先，在编辑器中为AgentNodeTest类添加了event_test_int_bool(int val_int, bool val_bool)这个任务（Task）或者更形象的称之为“接口”（Interface），如下图所示：</li>
</ul>
<p><img class="aligncenter" src="/img/overview/task.png" alt="" /></p>
<ul>
<li>其次，为行为树event_subtree_2添加一个任务节点，并作为根节点的第一个子节点，为该任务节点选择一个任务，这里我们直接选择event_test_int_bool，如下图所示。类似于编程语言中的函数参数为函数体的代码提供了局部变量，任务节点中的接口参数为当前的行为树提供了局部变量，这些局部变量可以根据需要用于该行为树所有子节点。</li>
</ul>
<p><img class="aligncenter" src="/img/overview/settask.png" alt="" /></p>
<ul>
<li>再次，将上面的行为树event_subtree_2通过鼠标拖拽到行为树event_ut_1中的第一个序列节点上，这样该序列节点就有了一个事件的附件，如下图所示：</li>
</ul>
<p><img src="/img/overview/addevent.png" alt="" /></p>
<ul>
<li>然后，为该事件设置参数，如下图所示：<img src="/img/overview/eventparam.png" alt="" /><br />
其中，“触发一次”表示该事件是否只触发一次就不再起作用。“触发模式”控制该事件触发后对当前行为树的影响以及被触发的子树结束时应该如何恢复，有转移（Transfer）和返回（Return）两个选项：</p>
<ul>
<li>转移：当子树结束时，当前行为树被中断和重置，该子树将被设置为当前行为树。</li>
<li>返回：当子树结束时，返回控制到之前打断的地方继续执行。当前行为树直接“压”到执行堆栈上而不被中断和重置，该子树被设置为当前行为树，当该子树结束时，原本的那棵行为树从执行堆栈上“弹出”，并从当初的节点恢复执行。</li>
</ul>
</li>
<li>最后，在游戏代码端通过如下代码，将事件“event_test_int_bool”发出，并指定所需的参数（这里是15和true两个值）。</li>
</ul>
<figure class="highlight">
<pre><code class="language-cs" data-lang="cs"><span class="n">testAgent</span><span class="p">.</span><span class="nf">FireEvent</span><span class="p">(</span><span class="err">“</span><span class="n">event_test_int_bool</span><span class="err">”</span><span class="p">,</span> <span class="m">15</span><span class="p">,</span> <span class="k">true</span><span class="p">);</span></code></pre>
</figure>
<p>这样，在执行行为树event_ut_1时，如果接收到事件“event_test_int_bool”，那么行为树中的事件附件将得到响应和处理，行为树的执行就会从当前的event_ut_1跳转到event_subtree_2。</p>
<p>调用FireEvent的时候，只有处于running状态的节点才响应事件。这样子是是为了事件的灵活性的考虑。这个设计是为了允许不同的分支不同的时机同样的事件可以触发不同的行为。比如同样是BeingHit，你受伤的时候，或者逃跑的时候可以对应不同的行为。如果不需要根据不同的节点相应不同的行为，只是需要响应事件，可以把事件配置在根节点上（根节点同样需要是running状态，非running状态的节点没有机会相应事件）。</p>
<p>另外需要补充说明的是，行为树event_subtree_2带有任务节点，我们也可以直接将该行为树拖拽到行为树event_ut_1中，如下图所示：</p>
<p><img class="aligncenter" src="/img/overview/eventsubtree.png" alt="" /></p>
<p>这样在行为树event_ut_1中，选中引用节点event_test_int_bool后，就可以直接配置该子树执行时所需的参数（这里是val_int和val_bool），如下图所示：</p>
<p><img class="aligncenter" src="/img/overview/subtreeparam.png" alt="" /></p>
<p>行为树的任务及其参数可以类比编程语言中的函数及其参数，因此event_test_int_bool这个“函数”有两个“形式参数”val_int和val_bool，而上图中所选择的5和true值就是event_test_int_bool函数执行时所用到的“实际参数”。</p>
<p>只有根节点是Task的子树才能被拖拽到另一个符合要求的树上生成事件。</p>
<p>可以查看 <a href="https://github.com/Tencent/behaviac/blob/master/test/btunittest/NodeTest/EventUnitTest.cpp">test/btunittest/NodeTest/EventUnitTest.cpp</a></p>
]]></content:encoded>
					
					<wfw:commentRss>/tutorial11_event/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>behaviac概述</title>
		<link>/overview/</link>
					<comments>/overview/#comments</comments>
		
		<dc:creator><![CDATA[admin]]></dc:creator>
		<pubDate>Mon, 11 Apr 2016 10:00:46 +0000</pubDate>
				<category><![CDATA[3.5]]></category>
		<category><![CDATA[概念]]></category>
		<guid isPermaLink="false">/?p=166</guid>

					<description><![CDATA[1 项目概况 behaviac是游戏AI的开发框架组件，也是游戏原型的快速设计工具。支持全平台，适用于客户端和服务器，助力游戏快速迭代开发。 编辑器可以运行在P<a class="moretag" href="/overview/">Read More...</a>]]></description>
										<content:encoded><![CDATA[<h2 id="section"><span class="ez-toc-section" id="1">1 项目概况</span></h2>
<ul>
<li>behaviac是游戏AI的开发框架组件，也是游戏原型的快速设计工具。支持全平台，适用于客户端和服务器，助力游戏快速迭代开发。</li>
<li>编辑器可以运行在PC上，操作方便直观可靠，支持实时和离线调试；编辑器可以导出xml/bson等多种格式，更可以导出C++/C#源码，提供最高效率。</li>
<li>运行时支持全平台，有C++/C#两个版本，原生支持Unity。</li>
<li>已被多款知名游戏及更多其他预研项目使用。</li>
<li>所有代码（包括编辑器和运行时）已经全部开源：<a href="https://github.com/Tencent/behaviac">https://github.com/Tencent/behaviac</a></li>
</ul>
<h2 id="section-1"><span class="ez-toc-section" id="2">2 背景</span></h2>
<p>游戏AI的目标之一就是要找到一种简单并可扩展的开发逻辑的方案，常用的技术包括有限状态机（FSM）、层次化有限状态机（HFSM）、面向目标的动作规划（GOAP）、层次化任务网络（HTN）等。</p>
<p>行为树作为次时代的AI技术，距其原型提出也约有10年左右，像Halo、Spore、Crysis等大作已经采用。目前，很多知名的游戏引擎也已整合或提供了自己的行为树组件，例如Unreal4、Unity引擎等。</p>
<h3 id="section-2"><span class="ez-toc-section" id="21">2.1 有限状态机</span></h3>
<p>提到有限状态机（Finite State Machine，FSM），很多程序员都相当熟悉。状态机技术在游戏开发中也已变得很成熟和流行，它反映了从系统开始到现在的输入变化。</p>
<ul>
<li>动作（Action）：指在给定时刻要进行的活动的描述。</li>
<li>状态（State）：指对象的某种形态，在当前形态下可能会拥有不同的行为和属性。</li>
<li>转换（Transition）：表示状态变更，并且必须满足确使转移发生的条件来执行。</li>
<li>状态机（State Machine）：控制对象状态的管理器。对象的状态不会无端的改变，它需要在某种条件下才会变换。状态会在某个事件触发之后变更，不同的状态也有可能决定了对象的不同属性和行为。</li>
</ul>
<p>如下图2.1所示，有限状态机维护了一张图，图的节点是一个个的状态，节点和节点的连线是状态间根据一定规则所执行的状态转换，每一个状态内的逻辑都可以简要描述为：</p>
<ul>
<li>如果满足条件1，则跳转到状态1；</li>
<li>如果满足条件2，则跳转到状态2；</li>
<li>…；</li>
<li>否则，不做任何跳转，维持当前状态。</li>
</ul>
<p><img src="/img/overview/fsm.png" alt="" /></p>
<p>图2.1 有限状态机</p>
<p>有限状态机有着简单的优势，采用状态机来实现AI更符合思维的朴素表达。对于一些简单的AI，用状态机更加便捷，但是面对一些复杂的AI逻辑就会显得比较繁杂。</p>
<p>同时，当需要对现有行为逻辑进行扩展的时候，代码上会显得比较吃力，因为要维护的状态量会成倍增加。</p>
<p>对于大型的系统，分层有限状态机（HFSM）也支持状态间切换的重用。但是状态机需要用转换连接状态，从而状态失去了模块性。</p>
<h3 id="section-3"><span class="ez-toc-section" id="22">2.2 行为树</span></h3>
<p>行为树（Behavior Tree，BT），使得实现AI的过程变得更加需要技巧。框架设计者较为全面的考虑了可能会遇到的种种情况，把每种情况都抽象成了某个类型的节点，而游戏开发者要做的就是按照规范把各种节点连接成一棵所需的行为树。这样，行为树更加具有面向对象的特征，行为模块间的藕合度相对较低。</p>
<p>概念上，行为树就是一段脚本，以树的形式展现给用户。节点的执行结果由其父节点来管理，决定接下来做什么。由于节点间不再有转换，因此不再称为状态，节点只是行为。</p>
<p>行为树的基本结构如图2.2所示，行为树由叶子节点和中间节点组成，从左到右依次是父子关系的节点：叶子节点主要是一些动作、条件和赋值等原子操作节点，包含了最基本的行为（如跑动、攻击等），当一个叶子节点被选择后，就会激活其对应的基本行为；中间节点主要是一些组合节点，代表逻辑单元，用于管理子节点如何执行等。</p>
<p><img src="/img/overview/bt.png" alt="" /></p>
<p>图2.2 行为树</p>
<p>叶子节点和中间节点主要分为五大类节点或附件：动作、条件、组合、修饰、附件等。其中，动作、条件节点为叶子节点，组合、修饰节点为中间节点，附件必须附属在这四类节点上面而不能独立存在。</p>
<p>每个节点执行结束后，都必须将其返回值提供给父节点。节点的返回值包括三种：成功（Success）、失败（Failure）以及正在执行（Running）。最基本的行为（叶子节点）可能执行成功也可能失败，高等级的行为（中间节点）是否执行成功依赖于子节点是否执行成功，子节点执行失败可能导致其父节点选择另一个子节点。<br />
行为树中最常用的节点包括：</p>
<ul>
<li>动作节点（Action）：属于叶子节点，用于描述一个最终执行的动作。</li>
<li>条件节点（Condition）：属于叶子节点，用于描述一个条件是否成立。</li>
<li>选择节点（Selector）：属于组合节点，用于顺序执行子节点，只要它的一个子节点返回成功，则整个分支返回成功，反之返回失败，类似程序中的逻辑或（OR）。</li>
<li>顺序节点（Sequence）：属于组合节点，用于顺序执行子节点，只要它的一个子节点返回失败，则整个分支返回失败，反之返回成功，类似程序中的逻辑与（AND）。</li>
</ul>
<p>行为树的执行通过帧循环的更新来驱动，不一定是每帧都需要更新，但是需要周期性的执行。基于效率的考虑，行为树的执行有点类似于协程（Coroutine）的概念。如果有返回正在执行的节点，那么在行为树下一次执行的时候会接着执行。否则，一个返回成功或失败也就是已经结束了的行为树，下一次执行就会从根节点重新开始。</p>
<p>一棵行为树首先需要设置一个Agent类型，Agent也就是游戏中的AI角色。在这棵行为树中的所有节点（主要是叶子节点），可以进一步选择Agent的属性、方法以及其他变量等进行配置。这些Agent的类型、属性、方法等信息，称之为类型信息，后文会更详细的对其进行介绍。</p>
<p>行为树的优势如下：</p>
<ul>
<li>行为逻辑和状态数据分离，任何节点都可以反复利用。</li>
<li>重用性高，可用通过重组不同的节点来实现不同的行为树。</li>
<li>呈线性的方式布局，易扩展。</li>
<li>可配置，把工作交给策划。</li>
</ul>
<h2 id="behaviac"><span class="ez-toc-section" id="3_behaviac">3 behaviac组件</span></h2>
<p>behaviac组件包括编辑器（Designer）和运行时（Runtime）两大部分：编辑器主要用于编辑行为树，运行时库主要用于解释和执行编辑并导出过的行为树，运行时库需要整合到自己的游戏项目中去。<br />
编辑器和运行时之间通过类型信息（Meta）进行交互，如图3.1所示：</p>
<p><img src="/img/overview/meta.png" alt="" /></p>
<p>图3.1 基于类型信息的编辑器和运行时端的交互</p>
<h3 id="section-4"><span class="ez-toc-section" id="31">3.1 类型信息</span></h3>
<p>类型信息是behaviac组件的核心，包括Agent的类型、属性、方法以及类的实例名称等信息。游戏中负责运行行为的实体称谓Agent，每个Agent都存有自己的数据或者能执行自己的动作，这样的数据被称为属性（Property），这样的动作被称为方法（Method）。所谓的类型信息就是对一个Agent的描述，包括其属性和方法等。</p>
<p>运行时库产生一个描述Agent类型信息的XML文件。注意图3.1中类型信息的双向箭头，“双向”表示运行时端可以导出类型信息给编辑器使用，在编辑器中也可以编辑并导出类型信息到运行时端。</p>
<p>在运行时端，也即游戏代码端，通过注册（C++通过宏的方式，C#通过标记Attribute的方式，如代码段3.1.1和3.1.2所示）并导出供行为树引擎和编辑器使用的XML类型信息。运行时端主要是由程序员编写Agent子类及其属性和方法，然后调用相关接口将这些类型信息导出，就可以在编辑器中对这些类型信息进行使用。</p>
<div class="highlighter-rouge">
<pre class="highlight"><code>
<span class="n">BEGIN_PROPERTIES_DESCRIPTION</span><span class="p">(</span><span class="n">AgentNodeTest</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">//CLASS_DISPLAYNAME(L"测试behaviac::Agent")
</span>    <span class="c1">//CLASS_DESC(L"测试behaviac::Agent的说明")
</span>    <span class="n">REGISTER_PROPERTY</span><span class="p">(</span><span class="n">testVar_0</span><span class="p">);</span>
    <span class="n">REGISTER_PROPERTY</span><span class="p">(</span><span class="n">testVar_1</span><span class="p">).</span><span class="n">DISPLAYNAME</span><span class="p">(</span><span class="s">L"testVar_1"</span><span class="p">).</span><span class="n">DESC</span><span class="p">(</span><span class="s">L"testVar_1 property"</span><span class="p">).</span><span class="n">RANGE</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
    <span class="n">REGISTER_PROPERTY</span><span class="p">(</span><span class="n">testVar_2</span><span class="p">);</span>
    <span class="n">REGISTER_PROPERTY</span><span class="p">(</span><span class="n">testVar_3</span><span class="p">);</span>
    <span class="n">REGISTER_PROPERTY</span><span class="p">(</span><span class="n">waiting_timeout_interval</span><span class="p">);</span>
    <span class="n">REGISTER_PROPERTY</span><span class="p">(</span><span class="n">testVar_str_0</span><span class="p">);</span>

    <span class="n">REGISTER_METHOD</span><span class="p">(</span><span class="n">setEventVarInt</span><span class="p">);</span>
    <span class="n">REGISTER_METHOD</span><span class="p">(</span><span class="n">setEventVarBool</span><span class="p">);</span>
    <span class="n">REGISTER_METHOD</span><span class="p">(</span><span class="n">setEventVarFloat</span><span class="p">);</span>
    <span class="n">REGISTER_METHOD</span><span class="p">(</span><span class="n">setEventVarAgent</span><span class="p">);</span>
    <span class="n">REGISTER_METHOD</span><span class="p">(</span><span class="n">getConstOne</span><span class="p">);</span>
    <span class="n">REGISTER_METHOD</span><span class="p">(</span><span class="n">setTestVar_0</span><span class="p">);</span>
    <span class="n">REGISTER_METHOD</span><span class="p">(</span><span class="n">setTestVar_1</span><span class="p">);</span>
    <span class="n">REGISTER_METHOD</span><span class="p">(</span><span class="n">setTestVar_2</span><span class="p">);</span>
    <span class="n">REGISTER_METHOD</span><span class="p">(</span><span class="n">setTestVar_0_2</span><span class="p">);</span>
    <span class="n">REGISTER_METHOD</span><span class="p">(</span><span class="n">setTestVar_R</span><span class="p">);</span>
    <span class="n">REGISTER_METHOD</span><span class="p">(</span><span class="n">setTestVar_3</span><span class="p">);</span>
    <span class="n">REGISTER_METHOD</span><span class="p">(</span><span class="n">enter_action_0</span><span class="p">);</span>
    <span class="n">REGISTER_METHOD</span><span class="p">(</span><span class="n">exit_action_0</span><span class="p">);</span>
    <span class="n">REGISTER_METHOD</span><span class="p">(</span><span class="n">enter_action_1</span><span class="p">);</span>
    <span class="n">REGISTER_METHOD</span><span class="p">(</span><span class="n">exit_action_1</span><span class="p">);</span>
    <span class="n">REGISTER_METHOD</span><span class="p">(</span><span class="n">enter_action_2</span><span class="p">);</span>
    <span class="n">REGISTER_METHOD</span><span class="p">(</span><span class="n">exit_action_2</span><span class="p">);</span>
    <span class="n">REGISTER_METHOD</span><span class="p">(</span><span class="n">createGameObject</span><span class="p">);</span>
    <span class="n">REGISTER_METHOD</span><span class="p">(</span><span class="n">testGameObject</span><span class="p">);</span>
    <span class="n">REGISTER_METHOD</span><span class="p">(</span><span class="n">createExtendedNode</span><span class="p">);</span>
    <span class="n">REGISTER_METHOD</span><span class="p">(</span><span class="n">testExtendedRefType</span><span class="p">);</span>
    <span class="n">REGISTER_METHOD</span><span class="p">(</span><span class="n">testExtendedStruct</span><span class="p">);</span>
    <span class="n">REGISTER_METHOD</span><span class="p">(</span><span class="n">switchRef</span><span class="p">);</span>

    <span class="n">REGISTER_METHOD</span><span class="p">(</span><span class="n">CanSeeEnemy</span><span class="p">);</span>
    <span class="n">REGISTER_METHOD</span><span class="p">(</span><span class="n">Move</span><span class="p">);</span>
    <span class="n">REGISTER_METHOD</span><span class="p">(</span><span class="n">MoveToTarget</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">END_PROPERTIES_DESCRIPTION</span><span class="p">()</span>

</code></pre>
</div>
<p>代码3.1.1 在C++中通过宏注册类型信息</p>
<figure class="highlight">
<pre><code class="language-cs" data-lang="cs"><span class="na">[behaviac.TypeMetaInfo()]</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">AgentNodeTest</span> <span class="p">:</span> <span class="n">behaviac</span><span class="p">.</span><span class="n">Agent</span>
<span class="p">{</span>
    <span class="p">[</span><span class="n">behaviac</span><span class="p">.</span><span class="nf">MemberMetaInfo</span><span class="p">()]</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">testVar_0</span> <span class="p">=</span> <span class="p">-</span><span class="m">1</span><span class="p">;</span>

    <span class="p">[</span><span class="n">behaviac</span><span class="p">.</span><span class="nf">MemberMetaInfo</span><span class="p">(</span><span class="s">"testVar_1"</span><span class="p">,</span> <span class="s">"testVar_1 property"</span><span class="p">,</span> <span class="m">100</span><span class="p">)]</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">testVar_1</span> <span class="p">=</span> <span class="p">-</span><span class="m">1</span><span class="p">;</span>

    <span class="p">[</span><span class="n">behaviac</span><span class="p">.</span><span class="nf">MemberMetaInfo</span><span class="p">()]</span>
    <span class="k">public</span> <span class="kt">float</span> <span class="n">testVar_2</span> <span class="p">=</span> <span class="p">-</span><span class="m">1.0f</span><span class="p">;</span>

    <span class="p">[</span><span class="n">behaviac</span><span class="p">.</span><span class="nf">MemberMetaInfo</span><span class="p">()]</span>
    <span class="k">public</span> <span class="kt">float</span> <span class="n">testVar_3</span> <span class="p">=</span> <span class="p">-</span><span class="m">1.0f</span><span class="p">;</span>

    <span class="p">[</span><span class="n">behaviac</span><span class="p">.</span><span class="nf">MemberMetaInfo</span><span class="p">()]</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">waiting_timeout_interval</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>

    <span class="p">[</span><span class="n">behaviac</span><span class="p">.</span><span class="nf">MemberMetaInfo</span><span class="p">()]</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">testVar_str_0</span> <span class="p">=</span> <span class="kt">string</span><span class="p">.</span><span class="n">Empty</span><span class="p">;</span>

    <span class="p">[</span><span class="n">behaviac</span><span class="p">.</span><span class="nf">MemberMetaInfo</span><span class="p">()]</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">testVar_str_1</span> <span class="p">=</span> <span class="kt">string</span><span class="p">.</span><span class="n">Empty</span><span class="p">;</span>

    <span class="k">public</span> <span class="kt">bool</span> <span class="n">m_bCanSee</span> <span class="p">=</span> <span class="k">false</span><span class="p">;</span>

    <span class="k">public</span> <span class="kt">int</span> <span class="n">event_test_var_int</span> <span class="p">=</span> <span class="p">-</span><span class="m">1</span><span class="p">;</span>
    <span class="k">public</span> <span class="kt">bool</span> <span class="n">event_test_var_bool</span> <span class="p">=</span> <span class="k">false</span><span class="p">;</span>
    <span class="k">public</span> <span class="kt">float</span> <span class="n">event_test_var_float</span> <span class="p">=</span> <span class="p">-</span><span class="m">1.0f</span><span class="p">;</span>
    <span class="k">public</span> <span class="n">AgentNodeTest</span> <span class="n">event_test_var_agent</span> <span class="p">=</span> <span class="k">null</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</figure>
<p>代码3.1.2 在C#中通过Attribute标记类型信息</p>
<p>此外，behaviac组件的特色之一就是编辑器中也可以创建和编辑类型信息。编辑器主要交给策划编辑行为树，也可以编辑类型信息。策划在项目开始初期，也就是程序员还没把代码写出来之前，策划就可以自己手动的创建一些Agent类型、属性和方法等类型信息。这样可以加速游戏原型的创建，也就是策划不用等程序员，就可以进行游戏原型的编辑。</p>
<p>如图3.1.3所示，打开编辑器中提供的类型信息浏览器，可以查看或新建Agent类型。选中其中一个Agent类型之后，可以查看它的属性、方法等信息，并可以扩展Agent类型的成员属性和方法等，还支持新建枚举和结构体类型等。</p>
<p><img src="/img/overview/metabrowser.png" alt="" /></p>
<p>图3.1.3 在类型信息浏览器中查看和编辑类型信息</p>
<h4 id="section-5"><span class="ez-toc-section" id="311">3.1.1 类型</span></h4>
<p>类型（Type）分为Agent、枚举和结构体等。</p>
<ul>
<li>Agent类：作为行为树的基本组成元素，是供其他游戏类派生的基类，在图3.1.3所示的类型信息浏览器中，我们可以查看所有导出和创建的Agent类型，这些Agent类型又包含变量和方法两大部分。可以在类型信息浏览器中添加自己的Agent子类，为其添加成员属性和方法，但方法的实现需要另外编写需要的逻辑代码。</li>
<li>枚举：游戏端的用到枚举类型会导出在类型信息文件中，也可以在类型信息浏览器中添加自己的枚举类型，并可以导出生成C++或C#源码，再添加到游戏端代码中。</li>
<li>结构体：游戏端的用到结构体类型会导出在类型信息文件中，也可以在类型信息浏览器中添加自己的结构体类型，但只能为其增加成员属性，不能添加成员方法，可以导出生成C++或C#源码，添加到游戏端代码中。</li>
</ul>
<p>如图3.1.1.1所示，在新建一棵行为树时，首先需要为根节点选择一种Agent类型，以表明当前新建的行为树是用的哪种Agent，该行为树的所有叶子节点将可以使用该Agent类型的属性和方法。</p>
<p><img src="/img/articles/agenttype_selector.png" alt="" /></p>
<p><img src="/img/overview/agenttype.png" alt="" /></p>
<p>图3.1.1.1 为根节点设置Agent类型</p>
<h4 id="section-6"><span class="ez-toc-section" id="312">3.1.2 实例</span></h4>
<p>上面已经提及了一棵行为树需要设置它的Agent类型，以便于所有叶子节点使用该Agent类型的属性和方法。对于这种情况，我们称之为使用自身（Self）的属性和方法。</p>
<p>另一方面，某个节点的参数可能会用到不是自身的属性或方法，这时就需要首先选择实例（Instance），然后再选择该实例所属的Agent类型的属性或方法，如图3.1.2.1所示。</p>
<p>所有Agent类的实例在运行时端需要通过注册并导出到类型信息文件中，这样编辑器拿到所有的实例列表后就可以一一列举出来以供选择，具体注册方法详见使用手册。</p>
<p><img src="/img/overview/properties.png" alt="" /></p>
<p>图3.1.2.1 为条件节点设置左参数</p>
<h4 id="section-7"><span class="ez-toc-section" id="313">3.1.3 变量</span></h4>
<p>变量分为成员字段（Field）、属性（Property）、自定义的属性以及局部变量等。</p>
<ul>
<li>成员字段：也即面向对象编程（C++/C#）中类的字段。</li>
<li>成员属性：也即C#中类的属性，带有getter和setter。</li>
<li>自定义的属性：主要是在编辑器中为Agent类型新建出来的成员属性。在变量前有一个‘*’星号标识。如下图。</li>
<li>局部变量：在变量前有一个‘-’减号标识。相对于成员属性和自定义的属性这些全局属性而言。为什么称之为全局属性？在整个游戏项目中，可能会有很多棵行为树，我们称之为工作区来管理所有的行为树。每一种Agent类型的成员属性和自定义的属性是可以供这个工作区中的所有行为树选择使用的，而局部变量只是针对某一棵行为树，局限于在这一棵行为树中所使用的变量。</li>
</ul>
<p><img src="/img/overview/variable_indicator.png" alt="" /></p>
<p>behaviac组件支持变量的只读（Readonly）特性，这样在编辑器中只可以对该属性进行读取，但不能为其赋值。局部变量不仅支持int、float、bool、枚举等基本的数据类型，也支持复杂的指针或引用类型。</p>
<h4 id="section-8"><span class="ez-toc-section" id="314">3.1.4 方法</span></h4>
<p>方法包括成员方法、自定义的方法、任务（Task）等。</p>
<ul>
<li>成员方法：也即面向对象编程中类的成员方法。</li>
<li>自定义的方法：在编辑器中创建出来的方法。自定义的方法只是作为占位符，允许设计人员可以继续工作。使用了自定义方法的行为树不允许导出。只有当程序员实现了该方法后，自定义方法变成了成员方法后该行为树才允许被导出。这个设定是为了保证导出的行为树是可以执行的。</li>
<li>任务：用于描述子树所需的接口，包括接口名和参数列表，跟方法的定义类似。后文将结合子树的概念，对任务的用法进行更详细的说明。</li>
</ul>
<p>最后，在编辑器中就可以根据导出和创建的类型信息，对行为树进行编辑。在行为树的每个节点上可以根据需要选择或设置属性、方法及其参数等，如图3.1.4.1所示。</p>
<p><img src="/img/overview/action.png" alt="" /></p>
<p>图3.1.4.1 编辑节点的属性</p>
<h3 id="section-9"><span class="ez-toc-section" id="32">3.2 工作区</span></h3>
<p>采用behaviac组件开始项目时，首先需要在编辑器中创建一个工作区（Workspace）。</p>
<p>工作区文件以.workspace.xml为后缀名，是管理游戏项目中所有行为树文件的配置文件，如图3.2.1所示：</p>
<p><img src="/img/overview/workspace.png" alt="" /></p>
<p>图3.2.1 工作区文件</p>
<p>该配置文件可以指定XML类型信息文件、行为树源文件的路径、导出文件的路径等，可以通过编辑器中的“新建工作区”或“编辑工作区”工具编辑相关设置，如图3.2.2所示：</p>
<p><img src="/img/overview/editworkspace.png" alt="" /></p>
<p>图3.2.2 编辑工作区</p>
<p>行为树源文件和导出文件的区别在于，行为树源文件是在编辑器中供策划编辑使用的初始源文件（XML格式），包含了很多冗余的信息，比如UI显示所需的属性等。而导出文件是一种精简版的行为树文件，只是给运行时端使用的一种高效的执行文件。</p>
<p>源文件就像那些Raw Data，必须导出后才能在运行时中使用，而导出文件就像那些处理过并在游戏中直接使用的Game Data。工作区文件、源文件、类型信息文件等在游戏中都不再需要，游戏中只需要导出的文件。</p>
<p>目前支持XML、BSON、C++和C#四种导出格式。其中，XML/BSON主要用于开发阶段，C++/C#主要用于最后的发布。C++/C#的内存和性能明显要优于XML/BSON的格式，所以我们建议在最后的发布过程，使用C++/C#的行为树导出文件。</p>
<h3 id="section-10"><span class="ez-toc-section" id="33">3.3 行为树</span></h3>
<p>behaviac组件提供了数量繁多、功能齐全的节点和附件，并支持扩展自己所需的节点类型。此外，behaviac组件还支持子树、事件、预制等高级用法，下面将一一进行介绍。</p>
<h4 id="section-11"><span class="ez-toc-section" id="331">3.3.1 节点与附件</span></h4>
<p>前面已经介绍，行为树的节点主要分为五大类节点或附件：动作、条件、组合、修饰、附件等，如图3.3.1所示。其中，动作、条件节点为叶子节点，组合、修饰节点为中间节点，附件必须附属在这四类节点上面而不能独立存在。</p>
<p>behaviac组件还支持扩展新的节点类型，具体用法可以详见使用手册中的介绍。</p>
<p><img src="/img/overview/nodes.png" alt="" /></p>
<p>图3.3.1.1 行为树的节点和附件</p>
<p>为了支持子树（Subtree）的功能，behaviac组件还提供了引用节点（ReferencedBehavior）类型，后文将对子树和引用节点详细介绍。</p>
<p>节点可以具有前置（Preaction）和后置（Postaction）等附件，如图3.3.2所示。前置可以表示执行某个条件或者某个操作，如果是条件，那么前置必须返回成功后才能继续执行所在的节点，否则直接返回到父节点。而后置只用于表示该节点执行完毕后继续执行的操作。</p>
<p><img src="/img/overview/attachments.png" alt="" /></p>
<p>图3.3.1.2 节点上的前置和后置</p>
<p>还有一种附件比较特殊，也即事件（Event）。事件是将一棵行为树作为另一棵行为树中某个节点（一般为根节点）的附件，用于响应事件发生时行为树的切换。后文将对事件进行更详细的说明。</p>
<p>为了支持某些特殊应用，behaviac组件还为序列（Sequence）、选择（Selector）等组合节点添加了中断条件（Interrupted Condition），如图3.3.1.3所示。增加中断条件是为了让序列节点（或其他组合节点）在依次执行每个子节点的时候，都需要根据该中断条件的执行结果，来判断是否需要执行当前子节点。也即，所有的子节点有一个统一的中断条件被打断执行。</p>
<p><img src="/img/overview/interupt.png" alt="" /></p>
<p>图3.3.1.3 中断条件</p>
<p>在编辑器中，可以通过鼠标拖拽这些节点到新建的行为树中，或拖拽前置和后置附件到某个节点上。</p>
<h4 id="section-12"><span class="ez-toc-section" id="332">3.3.2 预制</span></h4>
<p>为了方便或加速行为树的编辑，behaviac编辑器提供了预制（Prefab）的功能，以便利于复用已经编辑好的行为树。</p>
<p>behaviac组件的预制跟Unity引擎中的预制工作机制类似，如果在用到预制的地方改变了预制中某个节点的属性，那么就会在所在的行为树中创建一份该预制的实例（Instance）。如果没有改变预制中任何节点的属性，则直接跟预制母体的属性保持一致，也即修改了预制中任何节点的属性，用到该预制的其他行为树也跟着同步改变。</p>
<p>在编辑器中，可以将已经编辑好的行为树另存为预制，这些预制会组织在Prefabs目录下，以便区分于项目所需的行为树（归类在Behaviors目录下），如图3.3.2.1所示。</p>
<p><img src="/img/overview/behaviors.png" alt="" /></p>
<p>图3.3.2.1 行为树与预制</p>
<p>如图3.3.2.2所示，先构建了一个预制行为树“Prefab_安全的随机移动”。</p>
<p><img src="/img/overview/prefab.png" alt="" /></p>
<p>图3.3.2.2 预制</p>
<p>如图3.3.2.3所示，再将该行为树拖拽进行为树Tank_SafeWander_RandomFire中，可以看到该预制行为树会得到展开并复制过去，这加速了行为树的编辑，提高了开发工作的效率。</p>
<p><img src="/img/overview/prefabinstance.png" alt="" /></p>
<p>图3.3.2.3 使用预制的行为树</p>
<h4 id="section-13"><span class="ez-toc-section" id="333">3.3.3 子树与递归</span></h4>
<p>在编辑器中，可以通过鼠标拖拽一棵行为树到另一棵行为树中，并作为引用节点（ReferencedBehavior）添加到另一棵行为树上。如图3.3.3.1所示，action_ut_0就是action_ut_1的子树，action_ut_0所在的节点是一个引用节点。</p>
<p><img src="/img/overview/subtree.png" alt="" /></p>
<p>图3.3.3.1 子树</p>
<p>有了子树的功能，behaviac组件自然也支持了“递归”的功能，只要将当前行为树作为自己的子树即可。形成递归的时候需要注意不要造成死循环，这可以通过变量的使用来避免。</p>
<p>如图3.3.3.2所示，利用testVar_0来避免死循环：第一次进入的时候testVar_0 == 0，所以可以执行下面的序列，先把testVar_0赋值为1，那么在下面的递归重入的时候由于testVar_0 == 1，所以testVar_0 == 0的条件不满足，所以下面的序列不会进入从而避免了死循环。</p>
<p><img src="/img/overview/reverse.png" alt="" /></p>
<p>图3.3.3.2 递归</p>
<h4 id="section-14"><span class="ez-toc-section" id="334">3.3.4 事件处理</span></h4>
<p>执行行为树的过程中，当状态、条件发生变化或发生事件（Event）时如何响应或打断当前的执行是个重要的问题。</p>
<p>请详看文档《<a href="/docs/zh/tutorials/tutorial11_event/">事件处理</a>》。</p>
<h4 id="section-15"><span class="ez-toc-section" id="335">3.3.5 热加载</span></h4>
<p>behaviac组件中的编辑器和运行时库都支持热加载，但是只针对XML/BSON格式的行为树文件。</p>
<p>在编辑器中，只要当前打开的行为树文件在编辑器外由于某种原因得到修改（例如通过项目中的文件版本管理系统强制同步行为树文件，或者通过文本编辑器强制修改行为树XML文件等），那么都可以自动的在编辑器中得到刷新。</p>
<p>对于运行时端（或游戏端），只要在编辑器中修改了行为树文件并重新导出，那么在游戏运行过程中不用退出游戏，最新导出的行为树可以自动进行加载，这样就可以及时查看行为树最新的效果。</p>
<p>请详看文档《<a href="/docs/zh/tutorials/tutorial12_hotreload/">热加载</a>》。</p>
<h3 id="section-16"><span class="ez-toc-section" id="34">3.4 有限状态机</span></h3>
<p>除了上面提及的行为树，behaviac组件还支持传统的有限状态机（FSM）。在前面的2.1章节已经说明，有限状态机主要由状态（State）和转换（Transition）构成，如图3.4.1所示。</p>
<p><img src="/img/overview/fsm.png" alt="" /></p>
<p>图3.4.1 有限状态机</p>
<p>类似于前面提及的行为树子树的概念，behaviac组件的一大特色就是支持将编辑好的一个有限状态机整体作为另一个有限状态机的“子树”，甚至有限状态机还可以跟行为树交替引用，互相作为彼此的子树，也即一个有限状态机可以整体作为一棵行为树的“引用节点”，同时一棵行为树也可以整体作为一个有限状态机中的“引用状态”。</p>
<p>在behaviac编辑器中，状态是作为类似行为树的节点一样独立存在，而转换是为类似行为树中的附件一样挂在某个状态上。有限状态机的编辑也很简单，只需要通过鼠标拖拽“状态”节点和“转换”附件到新建的有限状态机中，如图3.4.2所示。</p>
<p><img src="/img/overview/states.png" alt="" /></p>
<p>图3.4.2 有限状态机的状态和转换</p>
<p>类似于行为树中的节点，还可以为有限状态机中的状态节点添加前置和后置附件，以表示执行到当前状态节点时，所需要执行的前置条件和后置操作。</p>
<h3 id="section-17"><span class="ez-toc-section" id="35">3.5 调试</span></h3>
<p>编辑器支持跟游戏端进行连调，如图3.5.1所示。</p>
<p><img src="/img/overview/connect.png" alt="" /></p>
<p>图3.5.1 连接游戏</p>
<p>支持查看属性的变化（图3.5.2）、在节点上设置断点（图3.5.3）、高亮显示行为树的执行路径（图3.5.3）以及记录每帧信息以便后续查看等功能。</p>
<p><img src="/img/overview/agentproperties.png" alt="" /></p>
<p>图3.5.2 查看Agent的属性</p>
<p><img src="/img/overview/breakpoints.png" alt="" /></p>
<p>图3.5.3 设置断点以及高亮显示执行路径</p>
<h3 id="demo"><span class="ez-toc-section" id="36">3.6 单元测试与</span></h3>
<p>为了方便入门，behaviac组件提供了C++和C#两种编程语言的单元测试以及游戏Demo，可以通过编辑器中的菜单项“帮助”-&gt;“控制说明” 进入，然后点击快速打开所需的单元测试或游戏Demo所用到的工作区，如图3.6.1所示。</p>
<p><img src="/img/overview/demo.png" alt="" /></p>
<p>图3.6.1 单元测试与Demo</p>
<h3 id="section-18"><span class="ez-toc-section" id="37">3.7 开源</span></h3>
<p>behaviac组件已在github上开源，网址是<a href="https://github.com/Tencent/behaviac">https://github.com/Tencent/behaviac</a>，可以下载最新的安装包、源码以及相关文档等。</p>
<p>另外，behaviac视频讲解的链接为：<a href="http://gad.qq.com/tool/detail/2">http://gad.qq.com/tool/detail/2</a></p>
]]></content:encoded>
					
					<wfw:commentRss>/overview/feed/</wfw:commentRss>
			<slash:comments>2</slash:comments>
		
		
			</item>
		<item>
		<title>行为树的基本概念及进阶</title>
		<link>/concepts/</link>
					<comments>/concepts/#comments</comments>
		
		<dc:creator><![CDATA[jonygli]]></dc:creator>
		<pubDate>Mon, 11 Apr 2016 09:56:50 +0000</pubDate>
				<category><![CDATA[文章]]></category>
		<category><![CDATA[概念]]></category>
		<guid isPermaLink="false">/?p=158</guid>

					<description><![CDATA[前言 开发游戏AI的目标之一就是要找到一个简单，可扩展的编辑逻辑的方案，从而加速游戏开发的迭代速度。在“行为系统图”中，行为系统（Behavior System<a class="moretag" href="/concepts/">Read More...</a>]]></description>
										<content:encoded><![CDATA[<h2><span class="ez-toc-section" id="i">前言</span></h2>
<p>开发游戏AI的目标之一就是要找到一个简单，可扩展的编辑逻辑的方案，从而加速游戏开发的迭代速度。在“行为系统图”中，行为系统（Behavior System）响应游戏中的各种信息，进行决策以挑选接下来将要执行的行动并且监控该行动的执行。<br />
<img src="/img/concepts/architecture.png" alt="行为系统图" /></p>
<p>知识模型（Knowledge Model）是对游戏世界中各种信息的抽象。</p>
<p>在行为系统中，有限状态机（FSM，Finite State Machine）最为经典，FSM模型的优势之一是简单。但是FSMs需要用转换（Transition）连接状态（State），因此，状态（State）失去了模块性（Modularity）。</p>
<p><img src="/img/concepts/fsm.png" alt="FSM" /></p>
<h2 id="section"><span class="ez-toc-section" id="i-2">什么是行为树</span></h2>
<p>行为树，英文是Behavior Tree，简称BT，是由行为节点组成的树状结构：<br />
<img src="/img/concepts/whatisbt.png" alt="什么是行为树" /></p>
<p>对于FSM，每个节点表示一个状态，而对于BT，每个节点表示一个行为。同样是由节点连接而成，BT有什么优势呢？</p>
<p>在BT中，节点是有层次（Hierarchical）的，子节点由其父节点来控制。每个节点的执行都有一个结果（成功Success，失败Failure或运行Running），该节点的执行结果都由其父节点来管理，从而决定接下来做什么，父节点的类型决定了不同的控制类型。节点不需要维护向其他节点的转换，节点的模块性（Modularity）被大大增强了。实际上，在BT里，由于节点不再有转换，它们不再是状态（State），而是行为（Behavior）。</p>
<p>由此可见，BT的主要优势之一就是其更好的封装性和模块性，让游戏逻辑更直观，开发者不会被那些复杂的连线绕晕。</p>
<h2 id="section-1"><span class="ez-toc-section" id="i-3">一个例子</span></h2>
<p><img src="/img/concepts/example1.png" alt="例子1" /><br />
上图中，3号Sequence节点有3个子节点，分别是：<br />
&#8211; 4号Condition节点<br />
&#8211; 5号Action节点<br />
&#8211; 6号Wait节点</p>
<p>而3号节点的父节点是2号的Loop节点。</p>
<p>先补充下各节点类型的执行逻辑（详见<a href="/intro/">节点说明</a>）：</p>
<ul>
<li>序列（Sequence）节点：顺序执行所有子节点返回成功，如果某个子节点失败返回失败。</li>
<li>循环（Loop）节点：循环执行子节点到指定次数后返回成功，如果循环次数为-1，则无限循环。</li>
<li>条件（Condition）节点：根据条件的比较结果，返回成功或失败。</li>
<li>动作（Action）节点：根据动作结果返回成功，失败，或运行。</li>
<li>等待（Wait）节点：当指定的时间过去后返回成功。</li>
</ul>
<h3 id="section-2"><span class="ez-toc-section" id="i-4">执行说明</span></h3>
<ul>
<li>如果4号条件节点的执行结果是成功，其父节点3号节点则继续执行5号节点，如果5号动作节点返回成功，则执行6号等待节点，如果6号节点返回成功，则3号节点全部执行完毕且会返回成功，那么2号节点继续下个迭代。</li>
<li>如果4号条件节点的执行结果是失败，其父节点3号节点则返回失败不再继续执行子节点，并且2号节点继续下个迭代。</li>
</ul>
<h2 id="section-3"><span class="ez-toc-section" id="i-5">进阶</span></h2>
<p>聪明的读者可能会问，上面的例子中只讲了成功或失败的情况，但如果动作要持续一段时间呢？如果5号节点，Fire需要持续一段时间呢？</p>
<ul>
<li>节点的执行结果可以是“成功”，“失败”，或“运行”。</li>
<li>对于持续运行一段时间的Fire动作，其执行结果持续返回“运行”，结束的时候返回“成功”。</li>
<li>对于持续运行一段时间的Wait动作，其执行结果持续返回“运行”，当等待时间到达的时候返回“成功”。</li>
</ul>
<p>当节点持续返回“运行”的时候，BT树的内部“知道”该节点是在持续“运行”的，从而在后续的执行过程中“直接”继续执行该节点，而不需要从头开始执行，直到该运行状态的节点返回“成功”或“失败”，从而继续后续的节点。从外面看，就像“阻塞”在了那个“运行”的节点上，其父节点就像不再管理，要一直等运行的子节点结束的时候，其父节点才再次接管</p>
<p>（请注意，这一段说明只是从概念上这样讲，概念上可以这样理解，实际上即使运行状态的节点每次执行也是要返回的，只是其返回值是运行，其父节点对于返回值是运行状态的节点，将使其继续，所以看上去好像父节点不再管理。）。</p>
<h2 id="a-nameanotherexample-a"><span class="ez-toc-section" id="i-6">另一个例子</span></h2>
<p><img src="/img/concepts/example2.png" alt="例子2" /><br />
如上图，为了清晰说明运行状态，来看另一个例子。在这个例子中，Condition，Action1，Action3是3个函数。</p>
<ul>
<li>0号节点是个Loop节点，循环3次。</li>
<li>1号节点是个Sequence节点</li>
<li>2号节点模拟一个条件，直接返回成功。</li>
<li>3号节点Action1是一个动作，直接返回成功。</li>
<li>4号节点Action3同样是一个动作，返回3次运行，然后返回成功。</li>
</ul>
<p>其代码如下：</p>
<div class="highlighter-rouge">
<pre class="highlight"><code><span class="n">bool</span> <span class="n">CBTPlayer</span><span class="o">::</span><span class="n">Condition</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">m_Frames</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\t</span><span class="s">Condition</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">behaviac</span><span class="o">::</span><span class="n">EBTStatus</span> <span class="n">CBTPlayer</span><span class="o">::</span><span class="n">Action1</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\t</span><span class="s">Action1</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">behaviac</span><span class="o">::</span><span class="n">BT_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">behaviac</span><span class="o">::</span><span class="n">EBTStatus</span> <span class="n">CBTPlayer</span><span class="o">::</span><span class="n">Action3</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\t</span><span class="s">Action3</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="n">m_Frames</span><span class="o">++</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">m_Frames</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">behaviac</span><span class="o">::</span><span class="n">BT_SUCCESS</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">behaviac</span><span class="o">::</span><span class="n">BT_RUNNING</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>
<p>而执行该BT树的C++代码如下：</p>
<div class="highlighter-rouge">
<pre class="highlight"><code>    <span class="kt">int</span> <span class="n">frames</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">behaviac</span><span class="o">::</span><span class="n">EBTStatus</span> <span class="n">status</span> <span class="o">=</span> <span class="n">behaviac</span><span class="o">::</span><span class="n">BT_RUNNING</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="n">behaviac</span><span class="o">::</span><span class="n">BT_RUNNING</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="err">\</span><span class="s">" frame "</span> <span class="o">&lt;&lt;</span> <span class="o">++</span><span class="n">frames</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="n">status</span> <span class="o">=</span> <span class="n">g_player</span><span class="o">-&gt;</span><span class="n">btexec</span><span class="p">();</span>

        <span class="c1">//other codes
</span>    <span class="p">}</span>
</code></pre>
</div>
<p>上面的执行行为树的代码就如同游戏更新部分。<code class="highlighter-rouge">status = g_player-&gt;btexec()</code>是在游戏的更新函数（update或tick）里，需要每帧调用。<br />
特别的，对于运行状态，即使运行状态概念上讲是“阻塞”在节点，但是依然是每帧需要调用<code class="highlighter-rouge">btexec</code>，也就是说，其节点依然是每帧都在运行，只是下一帧是继续上一帧，从而表现的是运行状态，在其结束之前，其父节点不会把控制转移给其他后续节点。这里的“阻塞”并非真的被阻塞，并非后续的代码(上面的<code class="highlighter-rouge">other codes</code>部分)不会被执行。<code class="highlighter-rouge">status = g_player-&gt;btexec()</code>后面如果有代码，依然被执行。</p>
<p>执行结果会是个什么样的输出呢？</p>
<p><img src="/img/concepts/result.png" alt="结果" /></p>
<p>第1帧：<br />
2号节点Condition返回“成功”，继续执行3号Action1节点，同样返回“成功”，接续执行4号Action3，返回“运行”。</p>
<p><img src="/img/concepts/frame1.png" alt="frame1" /></p>
<p>第2帧：<br />
由于上一帧4号Action3返回“运行”，直接继续执行4号Action3节点。</p>
<p><img src="/img/concepts/frame2.png" alt="frame2" /></p>
<p>第3帧：<br />
由于上一帧4号Action3返回“运行”，直接继续执行4号Action3节点。</p>
<p><img src="/img/concepts/frame3.png" alt="frame3" /></p>
<p>同样需要注意的是，2号Condition节点不再被执行。</p>
<p>而且，本次Action3返回“成功”，1号Sequence节点返回成功。0号Loop节点结束第1次迭代。<br />
第4帧：<br />
Loop的第2次迭代开始，就像第1帧的执行。</p>
<p><img src="/img/concepts/frame4.png" alt="frame4" /></p>
<h2 id="section-4"><span class="ez-toc-section" id="i-7">再进阶</span></h2>
<p>又有聪明的读者要问了，持续返回“运行”状态的节点固然优化了执行，但其结果就像“阻塞”了BT的执行一样，如果发生了其他“重要”的事情需要处理怎么办？</p>
<p>在behaviac里至少有多种办法。</p>
<h3 id="httpwwwbehaviaccomdocszhreferencesattachment"><span class="ez-toc-section" id="i-8">使用<a href="/docs/zh/references/attachment/">前置</a></span></h3>
<p><img src="/img/references/preaction.png" alt="" /></p>
<p>每个节点都可以添加<a href="/docs/zh/references/attachment/">前置</a>附件或<a href="/docs/zh/references/attachment/">后置</a>附件。<br />
上图的action节点添加了一个前置，两个后置。</p>
<p>可以添加<a href="/docs/zh/references/attachment/">前置</a>附件，并且“执行时机”设为Update或Both，则在每次执行之前都会先执行前置里配置的条件。</p>
<h3 id="parallelhttpwwwbehaviaccomdocszhreferencesparallel"><span class="ez-toc-section" id="Parallel">使用<a href="/docs/zh/references/parallel/">Parallel</a>节点</span></h3>
<p><img src="/img/concepts/parallel.png" alt="parallel" /></p>
<p>如上图，可以使用Parallel节点来“一边检查条件，一边执行动作”，该条件作为该动作的“Guard”条件。当该条件失败的时候来结束该处于持续运行状态的动作节点。</p>
<h3 id="selectormonitorhttpwwwbehaviaccomdocszhreferencesselectormonitor"><span class="ez-toc-section" id="SelectorMonitor">使用<a href="/docs/zh/references/selectormonitor/">SelectorMonitor</a>节点</span></h3>
<p><img src="/img/concepts/selectormonitor.png" alt="selectormonitor" /></p>
<ul>
<li>SelectorMonitor是一个动态的选择节点，和Selector相同的是，它选择第一个success的节点，但不同的是，它不是只选择一次，而是每次执行的时候都对其子节点进行选择。如上图所示，假若它选择了下面有True条件的那个节点（节点7）并且下面的1号Sequence节点在运行状态，下一次它执行的时候，它依然会去检查上面的那个8号条件的子树，如果该条件为真，则终止下面的运行节点而执行9号节点。</li>
<li>WithPrecondition有precondition子树和action子树。只有precondition子树返回success的时候，action子树才能够被执行。</li>
</ul>
<h3 id="event"><span class="ez-toc-section" id="Event">使用Event子树</span></h3>
<p>任何一个BT都可以作为事件子树，作为event附加到任何的一个节点上(用鼠标拖动BT到节点)。当运行该BT的时候，如果发生了某个事件，可以通过Agent::FireEvent来触发该事件，则处于running状态的节点，<strong>从下到上</strong>都有机会检查是否需要响应该事件，如果有该事件配置，则相应的事件子树就会被触发。请参考behaviac的相关文档获取详细信息。</p>
<h2 id="section-5"><span class="ez-toc-section" id="i-9">总结</span></h2>
<p>行为树的基本概念：</p>
<ul>
<li>执行每个节点都会有一个结果（成功，失败或运行）</li>
<li>子节点的执行结果由其父节点控制和管理</li>
<li>返回运行结果的节点被视作处于运行状态，处于运行状态的节点将被持续执行一直到其返回结束（成功或失败）。在其结束前，其父节点不会把控制转移到后续节点。</li>
</ul>
<p>其中理解运行状态是理解行为树的关键，也是使用好行为树的关键。</p>
<h2 id="section-6"><span class="ez-toc-section" id="i-10">其他</span></h2>
<p>上文<a href="/docs/zh/articles/concepts/#anotherexample">另一个例子</a>中“demo_running”的例子在安装包及源码里都有提供。最好查看源码，编译运行，自行尝试体会。<br />
可以查看<a href="/docs/zh/articles/directory/">目录说明</a></p>
<p><img src="/img/concepts/demo_running_project.png" alt="demo_running_project" /></p>
<p>请指定demo_running作为参数或不指定任何参数运行demo_running：</p>
<p><img src="/img/concepts/demo_running_exec.jpg" alt="demo_running_exec" /></p>
<p><a href="https://github.com/Tencent/behaviac">源码及示例下载地址</a></p>
<div class="section-nav"></div>
]]></content:encoded>
					
					<wfw:commentRss>/concepts/feed/</wfw:commentRss>
			<slash:comments>1</slash:comments>
		
		
			</item>
		<item>
		<title>热加载</title>
		<link>/tutorial12_hotreload/</link>
					<comments>/tutorial12_hotreload/#respond</comments>
		
		<dc:creator><![CDATA[admin]]></dc:creator>
		<pubDate>Fri, 13 May 2016 02:41:28 +0000</pubDate>
				<category><![CDATA[文章]]></category>
		<category><![CDATA[概念]]></category>
		<category><![CDATA[编辑器]]></category>
		<category><![CDATA[运行时]]></category>
		<guid isPermaLink="false">/?p=304</guid>

					<description><![CDATA[behaviac组件中的编辑器和运行时库都支持热加载，但是只针对XML/BSON格式的行为树文件。 在编辑器中，只要当前打开的行为树文件在编辑器外由于某种原因得<a class="moretag" href="/tutorial12_hotreload/">Read More...</a>]]></description>
										<content:encoded><![CDATA[<p id="section">behaviac组件中的编辑器和运行时库都支持热加载，但是只针对XML/BSON格式的行为树文件。</p>
<p>在编辑器中，只要当前打开的行为树文件在编辑器外由于某种原因得到修改（例如，通过项目中的文件版本管理系统强制同步行为树文件，或者通过文本编辑器强制修改行为树XML文件等），那么都可以自动的在编辑器中得到刷新。</p>
<p>对于运行时端（或程序端），只要在编辑器中修改了行为树文件并重新导出，那么在游戏运行过程中不用退出游戏，最新导出的行为树就可以自动进行加载。这样可以及时查看或使用行为树最新的修改效果。</p>
<p>行为树的更新执行流程请参考<a href="/docs/zh/tutorials/tutorial13_updateloop/">更新流程</a>。</p>
<p>为了启动热加载功能，需要确保在运行时端直接或间接调用了Workspace::DebugUpdate()函数，有两种方式：</p>
<ul>
<li>如果Agent的行为树是通过调用Workspace::Update()来集中执行的，则无需额外调用Workspace::DebugUpdate()函数</li>
<li>如果Agent的行为树是通过调用Agent::btexec()来执行的，则需要游戏每次更新时调用Workspace::DebugUpdate()函数</li>
</ul>
]]></content:encoded>
					
					<wfw:commentRss>/tutorial12_hotreload/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>共享资源和实例数据</title>
		<link>/memory_shared/</link>
					<comments>/memory_shared/#comments</comments>
		
		<dc:creator><![CDATA[jonygli]]></dc:creator>
		<pubDate>Mon, 11 Apr 2016 09:59:42 +0000</pubDate>
				<category><![CDATA[文章]]></category>
		<category><![CDATA[概念]]></category>
		<guid isPermaLink="false">/?p=164</guid>

					<description><![CDATA[每个行为树都只有一份单独的数据作为资源被加载。 每个使用行为树的对象（Agent）依据这个共享的资源创建独立的实例数据，例如对于Sequence节点，实例数据中<a class="moretag" href="/memory_shared/">Read More...</a>]]></description>
										<content:encoded><![CDATA[<p>每个行为树都只有一份单独的数据作为资源被加载。</p>
<p>每个使用行为树的对象（Agent）依据这个共享的资源创建独立的实例数据，例如对于Sequence节点，实例数据中只是存储更新到哪个子树，至于Sequence节点的配置信息等则被共享。</p>
<p><img src="/img/faq/memory_shared.png" alt="memory_shared" /></p>
<hr />
<ul>
<li>加载行为树请使用<code>Workspace::Load</code>或<code>Agent::btload</code></li>
<li>卸载行为树请使用<code>Workspace::UnLoad</code>或<code>Agent::btunload</code></li>
<li><code>Workspace::CreateBehaviorTreeTask</code>用来根据加载的行为树资源创建实例数据，而它配套的是<code>Workspace::DestroyBehaviorTreeTask</code></li>
<li>一般情况下，不需要<strong>显式</strong>调用<code>Workspace::CreateBehaviorTreeTask</code>和<code>Workspace::DestroyBehaviorTreeTask</code>
<ul>
<li>初始化的时候调用<code>Workspace::Load</code>或<code>Agent::btload</code>加载可能会用到的行为树</li>
<li>游戏循环的时候，根据需要，调用<code>Agent::btsetcurrent</code>指定该Agent当前的行为树，后续<code>Agent::btexec</code>更新的就是当前行为树，除非再次调用<code>Agent::btsetcurrent</code>修改当前行为树</li>
<li>退出的时候，调用<code>Workspace::UnLoad</code>或<code>Agent::btunload</code>，或<code>Workspace::UnLoadAll</code>卸载行为树资源。而行为树实例是在<code>Agent::btsetcurrent</code>的时候被创建的，释放Agent的时候被Agent负责释放</li>
</ul>
</li>
<li>C#代码是同名类型里的同名函数，如<code>Workspace.Load</code>和<code>Agent.btload</code></li>
</ul>
]]></content:encoded>
					
					<wfw:commentRss>/memory_shared/feed/</wfw:commentRss>
			<slash:comments>3</slash:comments>
		
		
			</item>
	</channel>
</rss>
