<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>文章 &#8211; behaviac</title>
	<atom:link href="/language/zh/category/文档/%E6%96%87%E7%AB%A0/feed/" rel="self" type="application/rss+xml" />
	<link>/</link>
	<description>Tencent behaviac, Game AI, Behavior Tree, Finite State Machine, Hierarchical Task Network, BT FSM HTN, 腾讯开源, 游戏AI, 行为树,有限状态机,分层任务网络</description>
	<lastBuildDate>Tue, 08 Aug 2017 03:19:05 +0000</lastBuildDate>
	<language>zh-CN</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>https://wordpress.org/?v=5.4.1</generator>
	<item>
		<title>原理和流程</title>
		<link>/workflow/</link>
					<comments>/workflow/#comments</comments>
		
		<dc:creator><![CDATA[cainhuang]]></dc:creator>
		<pubDate>Mon, 16 Jan 2017 07:38:46 +0000</pubDate>
				<category><![CDATA[文章]]></category>
		<guid isPermaLink="false">/?p=1456</guid>

					<description><![CDATA[本文档有视频和文字说明。两者内容是一致的，以便您按需查看。 本文档描述的是3.6及以后版本。对于3.5及以前的老版本请参考分类“3.5”。 behaviac整套<a class="moretag" href="/workflow/">Read More...</a>]]></description>
										<content:encoded><![CDATA[<pre>本文档有视频和文字说明。两者内容是一致的，以便您按需查看。
本文档描述的是3.6及以后版本。对于3.5及以前的老版本请参考分类“3.5”。</pre>
<h2 align="center"><video src="http://dlied5.qq.com/behaviac/tutorial_0_0.mp4" controls="controls" width="640" height="480" data-mce-fragment="1"></video></h2>
<p style="text-align: left;" align="center">behaviac整套组件分为编辑器和运行时库，编辑器是独立运行的程序，运行时库需要整合到自己的项目中，各模块的关系如下图所示：</p>
<p><img class="aligncenter size-full wp-image-1406" src="/wp-content/uploads/2016/12/architecture-2.png" sizes="(max-width: 687px) 100vw, 687px" srcset="/wp-content/uploads/2016/12/architecture-2.png 687w, /wp-content/uploads/2016/12/architecture-2-300x263.png 300w" alt="architecture" width="687" height="603" /></p>
<ul>
<li>工作区用于管理整个项目，包括类型信息和行为树文件等</li>
<li>类型信息包括Agent类及其成员属性、成员方法和实例等，以及枚举和结构体类型</li>
<li>行为树描述了指定的Agent类型的行为，利用各种节点和类型信息来创建行为树</li>
<li>运行时端根据编辑器导出的类型信息，执行导出的行为树</li>
</ul>
<p>整个组件的工作流程如下图所示：</p>
<p><img class="aligncenter size-full wp-image-1404" src="/wp-content/uploads/2016/12/workflow-2.png" sizes="(max-width: 872px) 100vw, 872px" srcset="/wp-content/uploads/2016/12/workflow-2.png 872w, /wp-content/uploads/2016/12/workflow-2-300x225.png 300w, /wp-content/uploads/2016/12/workflow-2-768x577.png 768w" alt="workflow" width="872" height="655" /></p>
<pre>“胶水”代码：是指编辑器自动生成的代码文件，用于注册类型信息，可用于程序端执行时通过名字或ID调用类的成员属性或方法。</pre>
]]></content:encoded>
					
					<wfw:commentRss>/workflow/feed/</wfw:commentRss>
			<slash:comments>1</slash:comments>
		
		
			</item>
		<item>
		<title>behaviac到底是什么</title>
		<link>/what_is_behaviac/</link>
					<comments>/what_is_behaviac/#respond</comments>
		
		<dc:creator><![CDATA[jonygli]]></dc:creator>
		<pubDate>Mon, 11 Apr 2016 10:02:27 +0000</pubDate>
				<category><![CDATA[文章]]></category>
		<category><![CDATA[概念]]></category>
		<guid isPermaLink="false">/?p=170</guid>

					<description><![CDATA[简述 behaviac是游戏AI的开发框架组件，也是游戏原型的快速设计工具。支持全平台，适用于客户端和服务器，助力游戏快速迭代开发 。 编辑器可以运行在PC上，<a class="moretag" href="/what_is_behaviac/">Read More...</a>]]></description>
										<content:encoded><![CDATA[<h2 id="section"><span class="ez-toc-section" id="i">简述</span></h2>
<p>behaviac是游戏AI的开发框架组件，也是游戏原型的快速设计工具。支持全平台，适用于客户端和服务器，助力游戏快速迭代开发 。</p>
<p>编辑器可以运行在PC上，操作方便直观可靠，支持实时和离线调试；编辑器可以导出xml，bson等多种格式，更可以导出C++、C#源码，提供最高效率。</p>
<p>运行时支持全平台，有C++和C#两个版本，原生支持Unity。</p>
<p>已被多款知名游戏及更多其他预研项目使用。</p>
<p>所有代码，包括编辑器和运行时<a href="https://github.com/Tencent/behaviac">全部开源https://github.com/Tencent/behaviac</a></p>
<h2 id="section-1"><span class="ez-toc-section" id="i-2">编辑器和运行时</span></h2>
<p>behaviac作为游戏AI的开发框架组件，有编辑器和运行时两个部分，这两个部分通过类型信息（描述AI实例属性和能力方法的信息）交换信息。<br />
<img class="aligncenter size-full wp-image-1406" src="/wp-content/uploads/2016/12/architecture-2.png" alt="" width="687" height="603" srcset="/wp-content/uploads/2016/12/architecture-2.png 687w, /wp-content/uploads/2016/12/architecture-2-300x263.png 300w" sizes="(max-width: 687px) 100vw, 687px" /></p>
<h3 id="section-2"><span class="ez-toc-section" id="i-3">类型信息</span></h3>
<p>类型信息用来描述类型的属性和方法。在3.5及之前的旧版本通过运行时端导出类型信息，3.6及之后的新版本通过编辑器创建类型信息，如下所示。编辑器中，该类型信息作为基本的语法单位用来创建行为树。</p>
<pre class="brush: cpp; title: ; notranslate">&lt;agent classfullname=&quot;framework::GameObject&quot; base=&quot;behaviac::Agent&quot; inherited=&quot;true&quot; DisplayName=&quot;&quot; Desc=&quot;&quot; IsRefType=&quot;true&quot;&gt;
&lt;Member Name=&quot;HP&quot; DisplayName=&quot;&quot; Desc=&quot;&quot; Type=&quot;uint&quot; Class=&quot;framework::GameObject&quot; /&gt;
&lt;Member Name=&quot;age&quot; DisplayName=&quot;&quot; Desc=&quot;&quot; Type=&quot;long&quot; Class=&quot;framework::GameObject&quot; /&gt;
&lt;Method Name=&quot;GoStraight&quot; DisplayName=&quot;&quot; Desc=&quot;&quot; Class=&quot;framework::GameObject&quot; ReturnType=&quot;void&quot;&gt;
&lt;Param DisplayName=&quot;speed&quot; Desc=&quot;speed&quot; Type=&quot;int&quot; /&gt;
&lt;/Method&gt;
&lt;Method Name=&quot;TurnTowardsTarget&quot; DisplayName=&quot;&quot; Desc=&quot;&quot; Class=&quot;framework::GameObject&quot; ReturnType=&quot;int&quot;&gt;
&lt;Param DisplayName=&quot;turnSpeed&quot; Desc=&quot;turnSpeed&quot; Type=&quot;float&quot; /&gt;
&lt;/Method&gt;
&lt;Method Name=&quot;alignedWithPlayer&quot; DisplayName=&quot;&quot; Desc=&quot;&quot; Class=&quot;framework::GameObject&quot; ReturnType=&quot;bool&quot; /&gt;
&lt;Method Name=&quot;playerIsAligned&quot; DisplayName=&quot;&quot; Desc=&quot;&quot; Class=&quot;framework::GameObject&quot; ReturnType=&quot;bool&quot; /&gt;
&lt;Method Name=&quot;projectileNearby&quot; DisplayName=&quot;&quot; Desc=&quot;&quot; Class=&quot;framework::GameObject&quot; ReturnType=&quot;bool&quot;&gt;
&lt;Param DisplayName=&quot;radius&quot; Desc=&quot;radius&quot; Type=&quot;float&quot; /&gt;
&lt;/Method&gt;
&lt;Method Name=&quot;distanceToPlayer&quot; DisplayName=&quot;&quot; Desc=&quot;&quot; Class=&quot;framework::GameObject&quot; ReturnType=&quot;float&quot; /&gt;
&lt;/agent&gt;</pre>
<p>在3.x版本之前的版本中，类型信息必须通过运行时来导出，策划需要新的属性或方法时，必须等待程序员更新代码重现导出类型信息后才能使用。而在3.x版本中，可以直接在编辑器中创建一个类型，并且创建它的属性和方法，而且可以导出类型的c++或c#源码，这极大的加速了迭代的过程，从而把编辑器作为一个原型设计工具。</p>
<h3 id="section-3"><span class="ez-toc-section" id="i-4">编辑器</span></h3>
<p>编辑器是一个可以运行在Windows平台上的编辑工具。<br />
<img src="/img/whatisbehaviac/designer.png" alt="designer" /><br />
在编辑器内，使用鼠标或快捷键，可以添加、编辑、配置、修改行为树（包括FSM，或HTN），也可以实时或离线调试游戏的行为，既可以设断点，也可以查看或修改变量的值。</p>
<h3 id="section-4"><span class="ez-toc-section" id="i-5">运行时</span></h3>
<p>运行时有C++和C#两个版本，Unity使用C#的实现，像是cocos等使用C++的引擎或平台使用C++的实现。其具体逻辑是一致的，即加载编辑器中导出的行为树，解释运行之。</p>
<pre class="brush: cpp; title: ; notranslate">

g_player = behaviac::Agent::Create&lt;CBTPlayer&gt;();

bool bRet = false;
bRet = g_player-&gt;btload(pszTreeName);
assert(bRet);

g_player-&gt;btsetcurrent(pszTreeName);

behaviac::EBTStatus status = behaviac::BT_RUNNING;

while (status == behaviac::BT_RUNNING)
{
status = g_player-&gt;btexec();
}</pre>
<div class="highlighter-rouge"></div>
<h3 id="section-5"><span class="ez-toc-section" id="i-6">导出和调试</span></h3>
<p>在编辑器内创建好行为后，需要导出，然后运行时才可以加载运行。编辑器支持导出多种格式：</p>
<ol>
<li>xml</li>
<li>bson</li>
<li>cpp</li>
<li>c#</li>
</ol>
<p>其中xml和bson作为数据，可以被加载，而cpp或c#作为源码直接编辑链接进程序，用户可以根据需要选择使用最合适的格式。</p>
<h2 id="behaviac"><span class="ez-toc-section" id="behaviac">behaviac能解决什么问题</span></h2>
<ul>
<li>behaviac作为游戏AI的开发框架组件，主要是用来开发游戏AI。</li>
<li>behaviac的编辑器使用图形化的界面（Visual scripting）和操作，操作直观方便。</li>
<li>游戏中的NPC，小怪，老怪等等的游戏逻辑都可以通过behaviac来创建和开发。</li>
<li>behaviac并不限于开发游戏AI的游戏逻辑，也可以用来开发组队逻辑（Squad Logic），策略AI（Strategy AI），玩家Avatar，甚至关卡设计等各种游戏场景。</li>
<li>behaviac还可以用作原型设计工具，策划只是使用behaviac编辑器来设计类型安全的，表达严谨的游戏逻辑。</li>
<li>C#版本的运行时原生支持unity，behaviac可以在unity内开发游戏AI</li>
<li>在iOS平台，作为热更新的一种手段</li>
<li>C++版本支持全平台，不仅可以用在客户端，也可以用在服务器端。一套逻辑，可以根据情况分别在客户端，服务器运行，避免重复开发。</li>
</ul>
<h2 id="behaviac-1"><span class="ez-toc-section" id="behaviac-2">behaviac有哪些主要特性</span></h2>
<ul>
<li>behaviac是游戏AI的开发框架组件，也是游戏原型的快速设计工具</li>
<li>支持持行为树（BT），状态机（FSM），层次任务网络（HTN）等多种范式</li>
<li>编辑器可以运行在PC上，操作方便直观可靠</li>
<li>编辑器可以导出xml，bson等多种格式，更可以导出C++，C#源码，提供最高效率</li>
<li>支持实时和离线调试，可以设断点，查看或修改变量</li>
<li>编辑器通过socket和游戏连接实现实时调试，支持远程实时调试</li>
<li>运行时支持全平台（Windows/Linux/iOS/Android等），有C++和C#两个版本，原生支持Unity。适用于客户端和服务器，助力游戏快速迭代开发</li>
<li>支持热加载，可以不用重启游戏就更新行为树</li>
<li>中英文界面可选，类型信息可以提供中英文显示信息</li>
<li>支持预制件（Prefab）、子树，方便重用共享</li>
<li>支持自定义数据类型，支持已有第3方库中的自定义类型</li>
<li>支持扩展节点类型</li>
</ul>
<hr />
<p><a href="/docs/zh/articles/overview/">可以继续阅读behaviac概述 →</a></p>
]]></content:encoded>
					
					<wfw:commentRss>/what_is_behaviac/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>目录结构</title>
		<link>/directory/</link>
					<comments>/directory/#respond</comments>
		
		<dc:creator><![CDATA[jonygli]]></dc:creator>
		<pubDate>Mon, 11 Apr 2016 09:58:37 +0000</pubDate>
				<category><![CDATA[文章]]></category>
		<category><![CDATA[上手]]></category>
		<category><![CDATA[概述]]></category>
		<guid isPermaLink="false">/?p=162</guid>

					<description><![CDATA[首先说明的是从下载链接获取的BehaviacSetup*.exe是安装包，内含可执行的编辑器及示例。 如果编辑器不能正常启动，需要下载安装Microsoft V<a class="moretag" href="/directory/">Read More...</a>]]></description>
										<content:encoded><![CDATA[<p>首先说明的是从<a href="/language/zh/downloads/">下载链接</a>获取的BehaviacSetup*.exe是安装包，内含可执行的编辑器及示例。</p>
<p>如果编辑器不能正常启动，需要下载安装<a href="https://support.microsoft.com/en-us/kb/2977003">Microsoft Visual C++ 运行库</a>及<a href="https://www.microsoft.com/en-US/download/details.aspx?id=21">.net框架</a>。</p>
<p>可以从<a href="/language/zh/downloads/">下载链接</a>下载或从<a href="https://github.com/Tencent/behaviac">github</a>克隆源码，这里介绍的是源码的目录结构。</p>
<h3 id="section">目录结构图示</h3>
<p><img class="aligncenter size-full wp-image-1411" src="/wp-content/uploads/2016/04/directory.png" alt="directory" width="177" height="346" srcset="/wp-content/uploads/2016/04/directory.png 177w, /wp-content/uploads/2016/04/directory-153x300.png 153w" sizes="(max-width: 177px) 100vw, 177px" /></p>
<h3 id="section-1">目录结构说明</h3>
<ul>
<li>build：构建脚本，使用CMake构建。可以参考文档<a href="/language/zh/how_to_build/">《如何编译构建》</a>。</li>
<li>docs：文档，目前只有behaviac.chm，以后访问文档需要访问<a href="/">API</a></li>
<li>inc：运行时库的C++头文件</li>
<li>integration：Unity平台的实现及示例
<ul>
<li>demo_running：一个简单demo</li>
<li>unity：unity的实现及unittest</li>
</ul>
</li>
<li>projects：C++项目文件，用于打开unit test和tutorials等项目。这里的项目文件是预提供的，仅支持vs及make。如果需要其他平台，可以参考build目录下的构建脚本。</li>
<li>src：运行时库的C++源码</li>
<li>test：测试，C++
<ul>
<li>btperformance：简单的性能测试</li>
<li>btremotetest,：简单的连调测试</li>
<li>btunittest：C++ unit test</li>
<li>demo_running：简单的测试，适合少量修改，体会<a href="/docs/zh/articles/concepts/">行为树的概念</a></li>
<li>usertest：简单的测试，适合少量修改，做出自己的测试</li>
</ul>
</li>
<li>tools：编辑器的C#源码
<ul>
<li>designer</li>
</ul>
</li>
<li>tutorials：教程相关的源码，配合<a href="/language/zh/category/文档/教程/">教程相关文档</a>使用，方便上手</li>
</ul>
]]></content:encoded>
					
					<wfw:commentRss>/directory/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>如何编译构建</title>
		<link>/how_to_build/</link>
					<comments>/how_to_build/#comments</comments>
		
		<dc:creator><![CDATA[admin]]></dc:creator>
		<pubDate>Fri, 13 May 2016 02:43:18 +0000</pubDate>
				<category><![CDATA[文章]]></category>
		<category><![CDATA[上手]]></category>
		<category><![CDATA[编译构建]]></category>
		<guid isPermaLink="false">/?p=308</guid>

					<description><![CDATA[如何编译构建 请首先到/language/zh/downloads/下载或克隆源码。 C++运行时库的构建 请参考<a class="moretag" href="/how_to_build/">Read More...</a>]]></description>
										<content:encoded><![CDATA[<h2><span class="ez-toc-section" id="i">如何编译构建</span></h2>
<p id="section">请首先到<a href="/language/zh/downloads/#https://github.com/Tencent/behaviac">/language/zh/downloads/</a>下载或克隆源码。</p>
<h3 id="c"><span class="ez-toc-section" id="C">C++运行时库的构建</span></h3>
<p>请参考文档《<a href="/docs/zh/articles/build/">使用cmake构建C++版运行时库</a>》。</p>
<h4><span class="ez-toc-section" id="i-2">项目文件</span></h4>
<p>从3.6.33版本，我们提供了预先生成的项目文件，如下图：</p>
<p id="NgRlqmF"><img class="alignnone size-full wp-image-2062 " src="/wp-content/uploads/2017/07/img_5976b5154fe90.png" alt="" srcset="/wp-content/uploads/2017/07/img_5976b5154fe90.png 558w, /wp-content/uploads/2017/07/img_5976b5154fe90-300x110.png 300w" sizes="(max-width: 558px) 100vw, 558px" /></p>
<h3><span class="ez-toc-section" id="CUnity">C#和Unity运行时库的构建</span></h3>
<p>安装目录中的/integration/unity是基于Unity C#的单元测试项目。</p>
<p>自己的C#项目需要将目录/integration/unity/Assets/Scripts/behaviac/runtime下的所有源码直接复制过去，如下图所示：</p>
<p><img class="aligncenter size-full wp-image-1365" src="/wp-content/uploads/2016/05/unity_runtime.png" alt="unity_runtime" width="453" height="579" srcset="/wp-content/uploads/2016/05/unity_runtime.png 453w, /wp-content/uploads/2016/05/unity_runtime-235x300.png 235w" sizes="(max-width: 453px) 100vw, 453px" /></p>
<p>如果是Unity平台下的C#开发，还可以在Unity编辑器中导入/integration/behaviac.unitypackage包（安装完发布的BehaviacSetup_***.exe后，会在安装目录中的/integration文件夹中找到该behaviac.unitypackage包）。</p>
<h3><span class="ez-toc-section" id="i-3">编辑器的构建</span></h3>
<p>编辑器的源码目录结构，如下图所示：<br />
<img src="/img/faq/source_designer_path.png" alt="source_designer_path.png" /></p>
<p>请使用vs2010或以上打开并构建<code class="highlighter-rouge">tools/designer/BehaviacDesigner.sln</code>。</p>
]]></content:encoded>
					
					<wfw:commentRss>/how_to_build/feed/</wfw:commentRss>
			<slash:comments>6</slash:comments>
		
		
			</item>
		<item>
		<title>VS项目中使用behaviac组件</title>
		<link>/cpp_include/</link>
					<comments>/cpp_include/#comments</comments>
		
		<dc:creator><![CDATA[admin]]></dc:creator>
		<pubDate>Fri, 13 May 2016 02:44:04 +0000</pubDate>
				<category><![CDATA[文章]]></category>
		<category><![CDATA[上手]]></category>
		<category><![CDATA[C++]]></category>
		<category><![CDATA[编译构建]]></category>
		<category><![CDATA[运行时]]></category>
		<guid isPermaLink="false">/?p=311</guid>

					<description><![CDATA[下载完behaviac组件的全部源码后，整个组件的目录结构，如下图所示： 将behaviac组件整合到自己的项目中时，可以通过两种方式使用behaviac组件：<a class="moretag" href="/cpp_include/">Read More...</a>]]></description>
										<content:encoded><![CDATA[<p id="cbehaviac">下载完behaviac组件的全部源码后，整个组件的目录结构，如下图所示：</p>
<p><img src="/img/tutorials/tutorial16/sourceFolder.png" alt="" /></p>
<p>将behaviac组件整合到自己的项目中时，可以通过两种方式使用behaviac组件：</p>
<ul>
<li>将全部源码（包括behaviac组件的所有<a href="https://github.com/Tencent/behaviac/blob/master/inc/behaviac">.h</a>和<a href="https://github.com/Tencent/behaviac/blob/master/src">.cpp</a>文件）全部复制到自己的游戏项目中。</li>
<li>单独编译behaviac组件库，生成lib文件，然后自己的项目包含.h文件和生成的.lib文件。</li>
</ul>
<p>对于上面的第二种用法，请先参考<a href="/docs/zh/tutorials/how_to_build/">如何编译构建</a>文档来编译构建behavaic组件。</p>
<p>在Windows平台，如果是使用VS来管理项目的，需要在VS的项目“Property Pages”-&gt;“Configuration Properties”-&gt;“C/C++”-&gt;“General”中的“Additional Include Directories”项中添加behaviac组件头文件（即图1中的inc文件夹）所在的路径，如下图所示：</p>
<p><img src="/img/tutorials/tutorial16/includeHeaderSettings.png" alt="" /></p>
<p>再在VS的项目“Property Pages”-&gt;“Configuration Properties”-&gt;“Linker”-&gt;“General”中的“Additional Library Directories”项中添加自己编译出的behaviac lib文件（即图1中的lib文件夹）所在的路径，如下图所示：</p>
<p><img src="/img/tutorials/tutorial16/includeLibSettings.png" alt="" /></p>
<p>最后在VS的项目“Property Pages”-&gt;“Configuration Properties”-&gt;“Linker”-&gt;“Input”中的“Additional Dependencies”项中添加自己编译出的behaviac lib文件，如下图所示：</p>
<p><img src="/img/tutorials/tutorial16/addLibSettings.png" alt="" /></p>
<p>注意：上图中的behaviac_debugdll_win32_vs2010.lib文件是用VS2010编译出来的，说明游戏项目也需要用VS2010来编译。如果你的游戏项目使用其他版本的VS，则编译behaviac组件也需要用相应版本的VS来编译。</p>
]]></content:encoded>
					
					<wfw:commentRss>/cpp_include/feed/</wfw:commentRss>
			<slash:comments>3</slash:comments>
		
		
			</item>
		<item>
		<title>运行时端的执行流程</title>
		<link>/tutorial13_updateloop/</link>
					<comments>/tutorial13_updateloop/#comments</comments>
		
		<dc:creator><![CDATA[admin]]></dc:creator>
		<pubDate>Fri, 13 May 2016 02:42:05 +0000</pubDate>
				<category><![CDATA[文章]]></category>
		<category><![CDATA[unity]]></category>
		<category><![CDATA[上手]]></category>
		<category><![CDATA[C++]]></category>
		<guid isPermaLink="false">/?p=306</guid>

					<description><![CDATA[在运行时端（下面以C++版来加以说明，C#版基本类似），整个组建的更新可以通过Workspace::Update()函数来执行，该函数主要包括两大功能： 调用D<a class="moretag" href="/tutorial13_updateloop/">Read More...</a>]]></description>
										<content:encoded><![CDATA[<p id="section">在运行时端（下面以C++版来加以说明，C#版基本类似），整个组建的更新可以通过Workspace::Update()函数来执行，该函数主要包括两大功能：</p>
<ul>
<li>调用DebugUpdate()函数来更新一些连调和热加载相关的功能。</li>
<li>根据m_bExecAgents来判断是否需要执行所有Agent实例的btexec()函数，可以通过接口Workspace::SetIsExecAgents(bool bExecAgents)对m_bExecAgents进行设置。</li>
</ul>
<p>具体执行逻辑如下代码所示：</p>
<div class="highlighter-rouge">
<pre class="highlight"><code><span class="kt">void</span> <span class="n">Workspace</span><span class="o">::</span><span class="n">DebugUpdate</span><span class="p">()</span>
<span class="p">{</span>
<span class="k">    this</span><span class="o">-&gt;</span><span class="n">LogFrames</span><span class="p">();</span>
<span class="k">    this</span><span class="o">-&gt;</span><span class="n">HandleRequests</span><span class="p">();</span>

<span class="k">    if</span> <span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">GetAutoHotReload</span><span class="p">())</span>
<span class="p">    {</span>
<span class="k">        this</span><span class="o">-&gt;</span><span class="n">HotReload</span><span class="p">();</span>
<span class="p">    }</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">Workspace</span><span class="o">::</span><span class="n">Update</span><span class="p">()</span>
<span class="p">{
</span><span class="k">    this</span><span class="o">-&gt;</span><span class="n">DebugUpdate</span><span class="p">();</span>

    <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">m_bExecAgents</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">contextId</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

        <span class="n">Context</span><span class="o">::</span><span class="n">execAgents</span><span class="p">(</span><span class="n">contextId</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>
<p>对于C++版，行为树的执行可以调用behaviac::Workspace::GetInstance()-&gt;Update()来执行所有Agent实例的行为树，也可以单独调用Agent的接口btexec()来执行单个实例的行为树。</p>
<p>其中，Workspace::Update()会遍历所有的Agent实例并依次执行btexec()，但在自己的游戏项目中，可能在一帧中需要对某些Agent多次调用btexec()，而另一些Agent只需调用一次，这时候就需要单独调用Agent::btexec()，而不是统一调用Workspace::Update()。</p>
<p>Workspace::Update()在调用Agent::btexec()之前，会检查Agent::IsActive()是否为true，如果为false，那么btexec()就不会被调用。</p>
<p>此外，为了支持连调和热加载，请务必保证在自己游戏的更新函数中调用了DebugUpdate()函数。如果已经调用了behaviac::Workspace::GetInstance()-&gt;Update()，那么就不需要再单独调用DebugUpdate()。</p>
<p>上述示例代码虽然是C++，但对于C#，也都是同名的。</p>
<p>特别注意：对于C#版，behaviac.Workspace.IsExecAgents默认设为false。</p>
<ul>
<li>如果将behaviac.Workspace.IsExecAgents设为true，使用behaviac.Workspace.Instance.Update()集中进行更新，Agent自己的更新就不需要调用btexec()了。</li>
<li>如果将behaviac.Workspace.IsExecAgents设为false，则不使用behaviac.Workspace.Instance.Update()集中进行更新，Agent自己的更新就需要调用btexec()了。</li>
</ul>
]]></content:encoded>
					
					<wfw:commentRss>/tutorial13_updateloop/feed/</wfw:commentRss>
			<slash:comments>3</slash:comments>
		
		
			</item>
		<item>
		<title>行为树的基本概念及进阶</title>
		<link>/concepts/</link>
					<comments>/concepts/#comments</comments>
		
		<dc:creator><![CDATA[jonygli]]></dc:creator>
		<pubDate>Mon, 11 Apr 2016 09:56:50 +0000</pubDate>
				<category><![CDATA[文章]]></category>
		<category><![CDATA[概念]]></category>
		<guid isPermaLink="false">/?p=158</guid>

					<description><![CDATA[前言 开发游戏AI的目标之一就是要找到一个简单，可扩展的编辑逻辑的方案，从而加速游戏开发的迭代速度。在“行为系统图”中，行为系统（Behavior System<a class="moretag" href="/concepts/">Read More...</a>]]></description>
										<content:encoded><![CDATA[<h2><span class="ez-toc-section" id="i">前言</span></h2>
<p>开发游戏AI的目标之一就是要找到一个简单，可扩展的编辑逻辑的方案，从而加速游戏开发的迭代速度。在“行为系统图”中，行为系统（Behavior System）响应游戏中的各种信息，进行决策以挑选接下来将要执行的行动并且监控该行动的执行。<br />
<img src="/img/concepts/architecture.png" alt="行为系统图" /></p>
<p>知识模型（Knowledge Model）是对游戏世界中各种信息的抽象。</p>
<p>在行为系统中，有限状态机（FSM，Finite State Machine）最为经典，FSM模型的优势之一是简单。但是FSMs需要用转换（Transition）连接状态（State），因此，状态（State）失去了模块性（Modularity）。</p>
<p><img src="/img/concepts/fsm.png" alt="FSM" /></p>
<h2 id="section"><span class="ez-toc-section" id="i-2">什么是行为树</span></h2>
<p>行为树，英文是Behavior Tree，简称BT，是由行为节点组成的树状结构：<br />
<img src="/img/concepts/whatisbt.png" alt="什么是行为树" /></p>
<p>对于FSM，每个节点表示一个状态，而对于BT，每个节点表示一个行为。同样是由节点连接而成，BT有什么优势呢？</p>
<p>在BT中，节点是有层次（Hierarchical）的，子节点由其父节点来控制。每个节点的执行都有一个结果（成功Success，失败Failure或运行Running），该节点的执行结果都由其父节点来管理，从而决定接下来做什么，父节点的类型决定了不同的控制类型。节点不需要维护向其他节点的转换，节点的模块性（Modularity）被大大增强了。实际上，在BT里，由于节点不再有转换，它们不再是状态（State），而是行为（Behavior）。</p>
<p>由此可见，BT的主要优势之一就是其更好的封装性和模块性，让游戏逻辑更直观，开发者不会被那些复杂的连线绕晕。</p>
<h2 id="section-1"><span class="ez-toc-section" id="i-3">一个例子</span></h2>
<p><img src="/img/concepts/example1.png" alt="例子1" /><br />
上图中，3号Sequence节点有3个子节点，分别是：<br />
&#8211; 4号Condition节点<br />
&#8211; 5号Action节点<br />
&#8211; 6号Wait节点</p>
<p>而3号节点的父节点是2号的Loop节点。</p>
<p>先补充下各节点类型的执行逻辑（详见<a href="/intro/">节点说明</a>）：</p>
<ul>
<li>序列（Sequence）节点：顺序执行所有子节点返回成功，如果某个子节点失败返回失败。</li>
<li>循环（Loop）节点：循环执行子节点到指定次数后返回成功，如果循环次数为-1，则无限循环。</li>
<li>条件（Condition）节点：根据条件的比较结果，返回成功或失败。</li>
<li>动作（Action）节点：根据动作结果返回成功，失败，或运行。</li>
<li>等待（Wait）节点：当指定的时间过去后返回成功。</li>
</ul>
<h3 id="section-2"><span class="ez-toc-section" id="i-4">执行说明</span></h3>
<ul>
<li>如果4号条件节点的执行结果是成功，其父节点3号节点则继续执行5号节点，如果5号动作节点返回成功，则执行6号等待节点，如果6号节点返回成功，则3号节点全部执行完毕且会返回成功，那么2号节点继续下个迭代。</li>
<li>如果4号条件节点的执行结果是失败，其父节点3号节点则返回失败不再继续执行子节点，并且2号节点继续下个迭代。</li>
</ul>
<h2 id="section-3"><span class="ez-toc-section" id="i-5">进阶</span></h2>
<p>聪明的读者可能会问，上面的例子中只讲了成功或失败的情况，但如果动作要持续一段时间呢？如果5号节点，Fire需要持续一段时间呢？</p>
<ul>
<li>节点的执行结果可以是“成功”，“失败”，或“运行”。</li>
<li>对于持续运行一段时间的Fire动作，其执行结果持续返回“运行”，结束的时候返回“成功”。</li>
<li>对于持续运行一段时间的Wait动作，其执行结果持续返回“运行”，当等待时间到达的时候返回“成功”。</li>
</ul>
<p>当节点持续返回“运行”的时候，BT树的内部“知道”该节点是在持续“运行”的，从而在后续的执行过程中“直接”继续执行该节点，而不需要从头开始执行，直到该运行状态的节点返回“成功”或“失败”，从而继续后续的节点。从外面看，就像“阻塞”在了那个“运行”的节点上，其父节点就像不再管理，要一直等运行的子节点结束的时候，其父节点才再次接管</p>
<p>（请注意，这一段说明只是从概念上这样讲，概念上可以这样理解，实际上即使运行状态的节点每次执行也是要返回的，只是其返回值是运行，其父节点对于返回值是运行状态的节点，将使其继续，所以看上去好像父节点不再管理。）。</p>
<h2 id="a-nameanotherexample-a"><span class="ez-toc-section" id="i-6">另一个例子</span></h2>
<p><img src="/img/concepts/example2.png" alt="例子2" /><br />
如上图，为了清晰说明运行状态，来看另一个例子。在这个例子中，Condition，Action1，Action3是3个函数。</p>
<ul>
<li>0号节点是个Loop节点，循环3次。</li>
<li>1号节点是个Sequence节点</li>
<li>2号节点模拟一个条件，直接返回成功。</li>
<li>3号节点Action1是一个动作，直接返回成功。</li>
<li>4号节点Action3同样是一个动作，返回3次运行，然后返回成功。</li>
</ul>
<p>其代码如下：</p>
<div class="highlighter-rouge">
<pre class="highlight"><code><span class="n">bool</span> <span class="n">CBTPlayer</span><span class="o">::</span><span class="n">Condition</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">m_Frames</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\t</span><span class="s">Condition</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">behaviac</span><span class="o">::</span><span class="n">EBTStatus</span> <span class="n">CBTPlayer</span><span class="o">::</span><span class="n">Action1</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\t</span><span class="s">Action1</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">behaviac</span><span class="o">::</span><span class="n">BT_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">behaviac</span><span class="o">::</span><span class="n">EBTStatus</span> <span class="n">CBTPlayer</span><span class="o">::</span><span class="n">Action3</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\t</span><span class="s">Action3</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="n">m_Frames</span><span class="o">++</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">m_Frames</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">behaviac</span><span class="o">::</span><span class="n">BT_SUCCESS</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">behaviac</span><span class="o">::</span><span class="n">BT_RUNNING</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>
<p>而执行该BT树的C++代码如下：</p>
<div class="highlighter-rouge">
<pre class="highlight"><code>    <span class="kt">int</span> <span class="n">frames</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">behaviac</span><span class="o">::</span><span class="n">EBTStatus</span> <span class="n">status</span> <span class="o">=</span> <span class="n">behaviac</span><span class="o">::</span><span class="n">BT_RUNNING</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="n">behaviac</span><span class="o">::</span><span class="n">BT_RUNNING</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="err">\</span><span class="s">" frame "</span> <span class="o">&lt;&lt;</span> <span class="o">++</span><span class="n">frames</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="n">status</span> <span class="o">=</span> <span class="n">g_player</span><span class="o">-&gt;</span><span class="n">btexec</span><span class="p">();</span>

        <span class="c1">//other codes
</span>    <span class="p">}</span>
</code></pre>
</div>
<p>上面的执行行为树的代码就如同游戏更新部分。<code class="highlighter-rouge">status = g_player-&gt;btexec()</code>是在游戏的更新函数（update或tick）里，需要每帧调用。<br />
特别的，对于运行状态，即使运行状态概念上讲是“阻塞”在节点，但是依然是每帧需要调用<code class="highlighter-rouge">btexec</code>，也就是说，其节点依然是每帧都在运行，只是下一帧是继续上一帧，从而表现的是运行状态，在其结束之前，其父节点不会把控制转移给其他后续节点。这里的“阻塞”并非真的被阻塞，并非后续的代码(上面的<code class="highlighter-rouge">other codes</code>部分)不会被执行。<code class="highlighter-rouge">status = g_player-&gt;btexec()</code>后面如果有代码，依然被执行。</p>
<p>执行结果会是个什么样的输出呢？</p>
<p><img src="/img/concepts/result.png" alt="结果" /></p>
<p>第1帧：<br />
2号节点Condition返回“成功”，继续执行3号Action1节点，同样返回“成功”，接续执行4号Action3，返回“运行”。</p>
<p><img src="/img/concepts/frame1.png" alt="frame1" /></p>
<p>第2帧：<br />
由于上一帧4号Action3返回“运行”，直接继续执行4号Action3节点。</p>
<p><img src="/img/concepts/frame2.png" alt="frame2" /></p>
<p>第3帧：<br />
由于上一帧4号Action3返回“运行”，直接继续执行4号Action3节点。</p>
<p><img src="/img/concepts/frame3.png" alt="frame3" /></p>
<p>同样需要注意的是，2号Condition节点不再被执行。</p>
<p>而且，本次Action3返回“成功”，1号Sequence节点返回成功。0号Loop节点结束第1次迭代。<br />
第4帧：<br />
Loop的第2次迭代开始，就像第1帧的执行。</p>
<p><img src="/img/concepts/frame4.png" alt="frame4" /></p>
<h2 id="section-4"><span class="ez-toc-section" id="i-7">再进阶</span></h2>
<p>又有聪明的读者要问了，持续返回“运行”状态的节点固然优化了执行，但其结果就像“阻塞”了BT的执行一样，如果发生了其他“重要”的事情需要处理怎么办？</p>
<p>在behaviac里至少有多种办法。</p>
<h3 id="httpwwwbehaviaccomdocszhreferencesattachment"><span class="ez-toc-section" id="i-8">使用<a href="/docs/zh/references/attachment/">前置</a></span></h3>
<p><img src="/img/references/preaction.png" alt="" /></p>
<p>每个节点都可以添加<a href="/docs/zh/references/attachment/">前置</a>附件或<a href="/docs/zh/references/attachment/">后置</a>附件。<br />
上图的action节点添加了一个前置，两个后置。</p>
<p>可以添加<a href="/docs/zh/references/attachment/">前置</a>附件，并且“执行时机”设为Update或Both，则在每次执行之前都会先执行前置里配置的条件。</p>
<h3 id="parallelhttpwwwbehaviaccomdocszhreferencesparallel"><span class="ez-toc-section" id="Parallel">使用<a href="/docs/zh/references/parallel/">Parallel</a>节点</span></h3>
<p><img src="/img/concepts/parallel.png" alt="parallel" /></p>
<p>如上图，可以使用Parallel节点来“一边检查条件，一边执行动作”，该条件作为该动作的“Guard”条件。当该条件失败的时候来结束该处于持续运行状态的动作节点。</p>
<h3 id="selectormonitorhttpwwwbehaviaccomdocszhreferencesselectormonitor"><span class="ez-toc-section" id="SelectorMonitor">使用<a href="/docs/zh/references/selectormonitor/">SelectorMonitor</a>节点</span></h3>
<p><img src="/img/concepts/selectormonitor.png" alt="selectormonitor" /></p>
<ul>
<li>SelectorMonitor是一个动态的选择节点，和Selector相同的是，它选择第一个success的节点，但不同的是，它不是只选择一次，而是每次执行的时候都对其子节点进行选择。如上图所示，假若它选择了下面有True条件的那个节点（节点7）并且下面的1号Sequence节点在运行状态，下一次它执行的时候，它依然会去检查上面的那个8号条件的子树，如果该条件为真，则终止下面的运行节点而执行9号节点。</li>
<li>WithPrecondition有precondition子树和action子树。只有precondition子树返回success的时候，action子树才能够被执行。</li>
</ul>
<h3 id="event"><span class="ez-toc-section" id="Event">使用Event子树</span></h3>
<p>任何一个BT都可以作为事件子树，作为event附加到任何的一个节点上(用鼠标拖动BT到节点)。当运行该BT的时候，如果发生了某个事件，可以通过Agent::FireEvent来触发该事件，则处于running状态的节点，<strong>从下到上</strong>都有机会检查是否需要响应该事件，如果有该事件配置，则相应的事件子树就会被触发。请参考behaviac的相关文档获取详细信息。</p>
<h2 id="section-5"><span class="ez-toc-section" id="i-9">总结</span></h2>
<p>行为树的基本概念：</p>
<ul>
<li>执行每个节点都会有一个结果（成功，失败或运行）</li>
<li>子节点的执行结果由其父节点控制和管理</li>
<li>返回运行结果的节点被视作处于运行状态，处于运行状态的节点将被持续执行一直到其返回结束（成功或失败）。在其结束前，其父节点不会把控制转移到后续节点。</li>
</ul>
<p>其中理解运行状态是理解行为树的关键，也是使用好行为树的关键。</p>
<h2 id="section-6"><span class="ez-toc-section" id="i-10">其他</span></h2>
<p>上文<a href="/docs/zh/articles/concepts/#anotherexample">另一个例子</a>中“demo_running”的例子在安装包及源码里都有提供。最好查看源码，编译运行，自行尝试体会。<br />
可以查看<a href="/docs/zh/articles/directory/">目录说明</a></p>
<p><img src="/img/concepts/demo_running_project.png" alt="demo_running_project" /></p>
<p>请指定demo_running作为参数或不指定任何参数运行demo_running：</p>
<p><img src="/img/concepts/demo_running_exec.jpg" alt="demo_running_exec" /></p>
<p><a href="https://github.com/Tencent/behaviac">源码及示例下载地址</a></p>
<div class="section-nav"></div>
]]></content:encoded>
					
					<wfw:commentRss>/concepts/feed/</wfw:commentRss>
			<slash:comments>1</slash:comments>
		
		
			</item>
		<item>
		<title>编辑类型信息</title>
		<link>/edit_types/</link>
					<comments>/edit_types/#respond</comments>
		
		<dc:creator><![CDATA[cainhuang]]></dc:creator>
		<pubDate>Fri, 03 Mar 2017 06:24:02 +0000</pubDate>
				<category><![CDATA[文章]]></category>
		<guid isPermaLink="false">/?p=1707</guid>

					<description><![CDATA[在类型信息浏览器中，管理了所有创建的类型信息。 创建完类型信息之后，我们可能需要在类型信息浏览器中继续修改、删除之前创建的类型信息，比如类和成员属性、方法等。 <a class="moretag" href="/edit_types/">Read More...</a>]]></description>
										<content:encoded><![CDATA[<p>在类型信息浏览器中，管理了所有创建的类型信息。</p>
<p>创建完类型信息之后，我们可能需要在类型信息浏览器中继续修改、删除之前创建的类型信息，比如类和成员属性、方法等。</p>
<h2><span class="ez-toc-section" id="i">类型</span></h2>
<p>类型分为三种：Agent、Struct和Enum，在新加一个类型的时候，可以相应的选择，如下图所示：</p>
<p><img class="aligncenter size-full wp-image-1589" src="/wp-content/uploads/2017/02/add_types.png" alt="" width="368" height="268" srcset="/wp-content/uploads/2017/02/add_types.png 368w, /wp-content/uploads/2017/02/add_types-300x218.png 300w" sizes="(max-width: 368px) 100vw, 368px" /></p>
<p>在类型信息浏览器左侧的“类型列表”中选择所要编辑的Agent子类，在右侧的“类型”属性框中，可以修改相关的参数，如下图所示：</p>
<p><img class="aligncenter size-full wp-image-1590" src="/wp-content/uploads/2017/02/edit_types.png" alt="" width="591" height="206" srcset="/wp-content/uploads/2017/02/edit_types.png 591w, /wp-content/uploads/2017/02/edit_types-300x105.png 300w" sizes="(max-width: 591px) 100vw, 591px" /></p>
<p>“类型”框中的各个参数说明如下：</p>
<ul>
<li><strong>生成代码：</strong>表示该类型是否需要在点击右下方的“应用”按钮时，生成源代码文件</li>
<li><strong>名称：</strong>该类型的名字，跟C++/C#的变量命名要求一致，不能输入非法字符</li>
<li><strong>命名空间：</strong>该类型的命名空间，跟C++/C#的命名空间一致</li>
<li><strong>基类：</strong>该类型的基类</li>
<li><strong>引用类型：</strong>该类型是否为引用类型，主要提供给结构体类型使用。若是引用类型，则表示在编辑器中使用时，只能作为引用或指针使用，不能展开配置其成员属性。Agent子类都是引用类型，结构体类型可以选择为引用或非引用类型，枚举类型都是非引用类型</li>
<li><strong>生成位置：</strong>一般不用设置，默认会统一使用工作区中配置的“代码生成位置”。但如果设置了该参数，表示当前类型会生成在指定的目录</li>
<li><strong>显示名：</strong>用于在编辑器中显示该类型的名字，可以用中文</li>
<li><strong>描述：</strong>用于在编辑器中显示该类型的描述内容，可以用中文</li>
</ul>
<p>右上方的按钮说明如下：</p>
<ul>
<li><strong>新增：</strong>用于添加一个新的类型</li>
<li><strong>删除：</strong>用于删除选中的类型</li>
<li><strong>预览原型代码：</strong>用于预览生成的代码内容。如果没有勾选上述“类型”框中的“生成代码”选项，可以点击该按钮打开原型代码文件后，复制相关的内容到自己的代码中</li>
<li><strong>设置头文件：</strong>在编辑器自动生成的代码中，可能需要包含项目中的头文件，这时就需要点击该按钮，弹出“C++导出设置”窗口添加需要的头文件，如下图所示：</li>
</ul>
<p><img class="aligncenter size-full wp-image-1591" src="/wp-content/uploads/2017/02/add_included_files.png" alt="" width="524" height="271" srcset="/wp-content/uploads/2017/02/add_included_files.png 524w, /wp-content/uploads/2017/02/add_included_files-300x155.png 300w" sizes="(max-width: 524px) 100vw, 524px" /></p>
<h2><span class="ez-toc-section" id="i-2">实例</span></h2>
<p>在类型信息浏览器中部位置的“实例名称”列表中，列举了当前选中的Agent子类的所有全局实例名。</p>
<p>在其右侧的“新增”按钮用于添加一个实例名，“删除”按钮用于删除当前选中的实例名，如下图所示：</p>
<p><img class="aligncenter size-full wp-image-1592" src="/wp-content/uploads/2017/02/add_instances.png" alt="" width="590" height="30" srcset="/wp-content/uploads/2017/02/add_instances.png 590w, /wp-content/uploads/2017/02/add_instances-300x15.png 300w" sizes="(max-width: 590px) 100vw, 590px" /></p>
<p>在文档《<a href="/tutorial_3_agent_instance/">教程三：Agent实例</a>》中，有对实例的详细使用说明。</p>
<h2><span class="ez-toc-section" id="i-3">成员</span></h2>
<p>在类型信息浏览器中下部位置的“成员类型”分为Property、Method和Task：</p>
<ul>
<li><strong>Property：</strong>成员属性</li>
<li><strong>Method：</strong>成员方法</li>
<li><strong>Task：</strong>任务，用于定义子树调用的接口原型</li>
</ul>
<h3><span class="ez-toc-section" id="i-4">属性</span></h3>
<p>“成员列表”根据上面选择的“成员类型”，列出了所有的成员；“筛选字符”用于列举自己指定字符的所有成员，即快速检索自己所需的成员，如下图所示：</p>
<p><img class="aligncenter size-full wp-image-1593" src="/wp-content/uploads/2017/02/member_property.png" alt="" width="590" height="376" srcset="/wp-content/uploads/2017/02/member_property.png 590w, /wp-content/uploads/2017/02/member_property-300x191.png 300w" sizes="(max-width: 590px) 100vw, 590px" /></p>
<p>选择某个属性后，就可以在下面的“属性”框中查看该属性的各种参数了：</p>
<ul>
<li><strong>名字：</strong>该属性的名字，跟C++/C#的变量命名要求一致，不能输入非法字符</li>
<li><strong>类型：</strong>该属性的类型。如果勾选了后面的“数组？”，则表示该类型为数组类型</li>
<li><strong>公开：</strong>该属性是否为public，跟C++/C#中的概念一致</li>
<li><strong>静态：</strong>该属性是否为static，跟C++/C#中的概念一致</li>
<li><strong>只读：</strong>该属性是否只读。如果为只读，那么在赋值节点中，不能作为左值被赋值，只能读取该值</li>
<li><strong>局部变量：</strong>表示该属性是否为局部变量。如果是局部变量，那么只在当前打开的行为树中使用，否则，是普通的成员属性，隶属于当前Agent子类，可用于任何行为树</li>
<li><strong>默认值：</strong>该属性的默认初始值，会自动生成在类型的构造函数中</li>
<li><strong>显示名：</strong>用于在编辑器中显示该属性的名字，可以用中文</li>
<li><strong>描述：</strong>用于在编辑器中显示该属性的描述内容，可以用中文</li>
</ul>
<p>右侧的“新增”按钮用于添加新的属性，“删除”按钮用于删除选中的属性，“往上”和“往下”按钮用于调整选中属性的相对位置。</p>
<h3><span class="ez-toc-section" id="i-5">方法</span></h3>
<p>在类型信息浏览器中，将“成员类型”选择为“Method”，则在“成员列表”中列出了所有的成员方法，如下图所示：</p>
<p><img class="aligncenter size-full wp-image-1594" src="/wp-content/uploads/2017/02/member_method.png" alt="" width="612" height="735" srcset="/wp-content/uploads/2017/02/member_method.png 612w, /wp-content/uploads/2017/02/member_method-250x300.png 250w" sizes="(max-width: 612px) 100vw, 612px" /></p>
<p>选择某个方法后，就可以在下面的“属性”框中查看该方法的各种参数了：</p>
<ul>
<li><strong>名字：</strong>该方法的名字，跟C++/C#的变量命名要求一致，不能输入非法字符</li>
<li><strong>返回值类型：</strong>该方法的返回值类型。如果勾选了后面的“数组？”，则表示该类型为数组类型</li>
<li><strong>公开：</strong>该方法是否为public，跟C++/C#中的概念一致</li>
<li><strong>静态：</strong>该方法是否为static，跟C++/C#中的概念一致</li>
<li><strong>显示名：</strong>用于在编辑器中显示该方法的名字，可以用中文</li>
<li><strong>描述：</strong>用于在编辑器中显示该方法的描述内容，可以用中文</li>
<li><strong>参数：</strong>该方法的参数列表，可以添加和删除</li>
</ul>
<h3><span class="ez-toc-section" id="i-6">任务</span></h3>
<p>在类型信息浏览器中，将“成员类型”选择为“Task”，则在“成员列表”中列出了所有的任务，如下图所示：</p>
<p><img class="aligncenter size-full wp-image-1595" src="/wp-content/uploads/2017/02/member_task.png" alt="" width="612" height="735" srcset="/wp-content/uploads/2017/02/member_task.png 612w, /wp-content/uploads/2017/02/member_task-250x300.png 250w" sizes="(max-width: 612px) 100vw, 612px" /></p>
<p>任务的编辑跟成员方法的编辑相同，任务只是定义了一个接口原型，用于事件的参数传递。关于事件的更多用法，请参考文章《<a href="/tutorial11_event/">事件处理</a>》。</p>
<p>最后，编辑类型信息的过程中，不要忘记点击右下方的“应用”按钮，保存和生成类型信息。</p>
<h2><span class="ez-toc-section" id="i-7">生成代码</span></h2>
<p>编辑完类型信息之后，点击右下方的“应用按钮”生成类型信息相关的源码文件。</p>
<p>如果对上面的Agent类型“FirstAgent”勾选了“生成代码”选项，那么在其“生成位置”中，会自动生成该类型的源码文件（点击左下方的“打开代码生成位置”按钮），如下图所示：</p>
<p><img class="aligncenter size-full wp-image-1653" src="/wp-content/uploads/2017/02/generated_internal2.png" alt="" width="256" height="265" /></p>
<p>还有一种情况就是对Agent类型没有勾选“生成代码”选项，或者是老版本的用法，都是程序员手工编写的Agent类型。那么在点击右下方的“应用”按钮后，需要在程序端手工添加在类型信息浏览器中添加的成员属性或方法的代码。</p>
<p>为了提高手工编写代码的效率和准确性，点击“预览原型代码”按钮，如下图所示：</p>
<p><img class="aligncenter size-full wp-image-1654" src="/wp-content/uploads/2017/02/preview.png" alt="" width="610" height="187" srcset="/wp-content/uploads/2017/02/preview.png 610w, /wp-content/uploads/2017/02/preview-300x92.png 300w" sizes="(max-width: 610px) 100vw, 610px" /></p>
<p>可以看到当前Agent类的原型代码如下所示，可以复制粘贴需要的成员属性或方法的定义到自己的代码中：</p>
<p><img class="aligncenter size-full wp-image-1655" src="/wp-content/uploads/2017/02/prototype_codes.png" alt="" width="562" height="423" srcset="/wp-content/uploads/2017/02/prototype_codes.png 562w, /wp-content/uploads/2017/02/prototype_codes-300x226.png 300w" sizes="(max-width: 562px) 100vw, 562px" /></p>
<p>如果忘记了在程序端添加相应的成员属性或方法，编译的时候也会报错找不到这些在编辑器中新加的成员属性或方法，这时候就需要手工添加一下。</p>
]]></content:encoded>
					
					<wfw:commentRss>/edit_types/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>热加载</title>
		<link>/tutorial12_hotreload/</link>
					<comments>/tutorial12_hotreload/#respond</comments>
		
		<dc:creator><![CDATA[admin]]></dc:creator>
		<pubDate>Fri, 13 May 2016 02:41:28 +0000</pubDate>
				<category><![CDATA[文章]]></category>
		<category><![CDATA[概念]]></category>
		<category><![CDATA[编辑器]]></category>
		<category><![CDATA[运行时]]></category>
		<guid isPermaLink="false">/?p=304</guid>

					<description><![CDATA[behaviac组件中的编辑器和运行时库都支持热加载，但是只针对XML/BSON格式的行为树文件。 在编辑器中，只要当前打开的行为树文件在编辑器外由于某种原因得<a class="moretag" href="/tutorial12_hotreload/">Read More...</a>]]></description>
										<content:encoded><![CDATA[<p id="section">behaviac组件中的编辑器和运行时库都支持热加载，但是只针对XML/BSON格式的行为树文件。</p>
<p>在编辑器中，只要当前打开的行为树文件在编辑器外由于某种原因得到修改（例如，通过项目中的文件版本管理系统强制同步行为树文件，或者通过文本编辑器强制修改行为树XML文件等），那么都可以自动的在编辑器中得到刷新。</p>
<p>对于运行时端（或程序端），只要在编辑器中修改了行为树文件并重新导出，那么在游戏运行过程中不用退出游戏，最新导出的行为树就可以自动进行加载。这样可以及时查看或使用行为树最新的修改效果。</p>
<p>行为树的更新执行流程请参考<a href="/docs/zh/tutorials/tutorial13_updateloop/">更新流程</a>。</p>
<p>为了启动热加载功能，需要确保在运行时端直接或间接调用了Workspace::DebugUpdate()函数，有两种方式：</p>
<ul>
<li>如果Agent的行为树是通过调用Workspace::Update()来集中执行的，则无需额外调用Workspace::DebugUpdate()函数</li>
<li>如果Agent的行为树是通过调用Agent::btexec()来执行的，则需要游戏每次更新时调用Workspace::DebugUpdate()函数</li>
</ul>
]]></content:encoded>
					
					<wfw:commentRss>/tutorial12_hotreload/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>扩展生成节点的行为树代码</title>
		<link>/tutorial4_4_generate_node/</link>
					<comments>/tutorial4_4_generate_node/#respond</comments>
		
		<dc:creator><![CDATA[admin]]></dc:creator>
		<pubDate>Fri, 13 May 2016 02:30:59 +0000</pubDate>
				<category><![CDATA[文章]]></category>
		<category><![CDATA[扩展]]></category>
		<category><![CDATA[编辑器]]></category>
		<guid isPermaLink="false">/?p=288</guid>

					<description><![CDATA[生成C++或C#的相关代码放在behaviac编辑器项目的PluginBehaviac工程中，具体代码可以用VS打开该项目进行查看或修改。 这里介绍用于生成C+<a class="moretag" href="/tutorial4_4_generate_node/">Read More...</a>]]></description>
										<content:encoded><![CDATA[<p id="section">生成C++或C#的相关代码放在behaviac编辑器项目的PluginBehaviac工程中，具体代码可以用VS打开该项目进行查看或修改。</p>
<p>这里介绍用于生成C++代码的相关类和接口（与生成C#代码基本相同）：</p>
<ul>
<li>从基类Exporter派生出子类ExporterCpp用于管理和发起C++代码的生成。在模块初始化的地方调用如下代码，编辑器将会支持导出C++代码：<br />
Plugin.Exporters.Add(new ExporterInfo(typeof(PluginBehaviac.Exporters.ExporterCpp), “cpp”, “C++ Behavior Exporter”, true, true));</li>
<li>在DataExporters/Cpp文件夹中，维护了一组导出Variable、Par、Property、Method、Enum、Struct、Array等基本数据结构的Utility类。</li>
<li>从基类NodeExporter派生出子类NodeCppExporter，该子类定义了GenerateClass()、GenerateInstance()、GetGeneratedClassName()、ShouldGenerateClass()、GenerateConstructor()、GenerateMember()、GenerateMethod()等虚函数，用于生成某个具体的节点类。</li>
<li>在NodeExporters/Cpp文件夹中，维护了各种节点类的辅助导出类，例如类Action对应的类ActionCppExporter等等，这些类分别实现了上面的虚函数，用于导出特定节点类的类型、属性和方法等信息。</li>
</ul>
<p>更多细节可以参考behaviac组件编辑器源码中附带的<a href="https://github.com/Tencent/behaviac/blob/master/tools/designer/Plugins/PluginBehaviac/NodeExporters/Cpp">NodeExporters</a>文件夹。</p>
]]></content:encoded>
					
					<wfw:commentRss>/tutorial4_4_generate_node/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>behaviac与Behavior Designer的对比</title>
		<link>/bd_vs_behaviac/</link>
					<comments>/bd_vs_behaviac/#comments</comments>
		
		<dc:creator><![CDATA[admin]]></dc:creator>
		<pubDate>Mon, 11 Apr 2016 09:52:11 +0000</pubDate>
				<category><![CDATA[文章]]></category>
		<category><![CDATA[竞品分析]]></category>
		<guid isPermaLink="false">/?p=154</guid>

					<description><![CDATA[简介 众所周知，行为树技术已经在游戏开发过程中逐渐变得流行起来。目前业界有两款知名度相对比较高的行为树组件——Behavior Designer（后面简称BD）<a class="moretag" href="/bd_vs_behaviac/">Read More...</a>]]></description>
										<content:encoded><![CDATA[<h3><span class="ez-toc-section" id="i">简介</span></h3>
<p>众所周知，行为树技术已经在游戏开发过程中逐渐变得流行起来。目前业界有两款知名度相对比较高的行为树组件——Behavior Designer（后面简称BD）和behaviac。本文将重点剖析这两款行为树组件的特点和差异。</p>
<p>BD是独立游戏工作室Opsive开发的一款集成在Unity引擎中的行为树插件（<a href="http://www.opsive.com/">www.opsive.com</a>），提供了让程序员、策划、美术等方便使用的可视化编辑器，以及丰富的API以便轻松的创建任务，并无缝集成类似uScript和PlayMaker等第三方的Unity插件。</p>
<p>behaviac是腾讯公司提供的一款行为树解决方案（<a href="/">www.behaviac.com</a>），是游戏AI的开发框架和组件。支持全平台，适用于客户端和服务器，助力游戏快速迭代开发，提供了功能强大的编辑器和API。</p>
<p>目前已有多款游戏分别采用了这两款组件。</p>
<p>那么，这两款行为树组件究竟有什么特点和差异？本文通过重点分析BD组件的特色，本着“人无我有，人有我优”的目标，期待将behaviac组件实现的更加完善。</p>
<p>首先给出behaviac与BD的对比表，如下表所示，后面将详细介绍。</p>
<p><img src="/img/articles/bd_vs_behaviac.png" alt="bd_vs_behaviac" /></p>
<h3 id="section"><span class="ez-toc-section" id="i-2">费用</span></h3>
<p>BD是Unity Asset Store中的付费组件，可以获得到运行时的源码，如下图所示：</p>
<p><img src="/img/articles/bd.png" alt="bd" /></p>
<p>behaviac完全免费使用, 已经在Github上全部开源，包括运行时和编辑器。</p>
<h3 id="section-1"><span class="ez-toc-section" id="i-3">平台</span></h3>
<p>BD是Unity引擎的插件，运行时只有C#语言实现，编辑器也整合在Unity的编辑器中。</p>
<p>behaviac的运行时支持全平台（Linux/Windows/Mac/Android/iOS等），有C++和C#两种版本，并在研发JS和LUA版本，原生支持Unity引擎，也可以整合Cocos引擎。编辑器运行在Windows上，是独立运行的exe，可以通过IP和端口跟游戏端（运行时）进行本机或远程连调。</p>
<h3 id="section-2"><span class="ez-toc-section" id="i-4">支持</span></h3>
<p>BD可以在其官网提供的论坛进行发帖咨询并得到答疑，提供了较为全面的文档、视频和示例，但目前只有全英文版。</p>
<p>behaviac在官网提供了论坛进行问题咨询和答疑，目前都为全中文版。此外，还提供了开发者QQ群（433547396），可以与组件研发人员进行实时沟通，以最快的速度交流使用中的问题，并及时修复使用者发现的bug。behaviac自带了相关游戏demo和单元测试的代码，提供的中文文档已经较为全面，但缺乏教学视频。</p>
<h3 id="section-3"><span class="ez-toc-section" id="i-5">技术点</span></h3>
<p>相比其他行为树组件，BD提供了很多实用的技术：</p>
<h4 id="section-4"><span class="ez-toc-section" id="i-6">节点类型</span></h4>
<p>BD提供了四种概念节点，都称之为任务（Task）：</p>
<ul>
<li>组合节点（Composite）：Sequence、Selector、Parallel等。</li>
<li>装饰节点（Decorator）：为仅有的一个子节点额外添加一些功能，比如让子节点一直运行直到其返回某个运行状态值，或者将子节点的返回值取反等。</li>
<li>动作节点（Action）：动作节点是真正做事的节点，其为叶节点。BD中自带了很多动作节点，如果不够用，也可以编写自己的动作节点。</li>
<li>条件节点（Conditional）：用于判断某条件是否成立。</li>
</ul>
<p>BD常用的任务包括动作和条件节点，这两个节点是用来派生出自己游戏所需的子类来进行脚本定制，特定的逻辑体现在派生出的动作或条件节点中，暴露一些属性在编辑器中以供配置和测试。</p>
<p>BD提供了覆盖整个Unity引擎API的各种任务，包括动画、声音、物理、角色控制、粒子系统等方面的常用类型（如下图所示），这样就允许非程序员（策划或美术）方便的创建自己的游戏AI，同时也让程序员尽量少的编写自定义的任务。</p>
<p><img src="/img/articles/bd_nodes.png" alt="bd_nodes" /></p>
<p>behaviac提供了丰富的节点类型（如下图所示），一般情况下，开发者无需扩展自己的节点就可以工作，并不需要派生自己的动作和条件节点。除了支持常用的节点外，behaviac还提供了很多快捷节点（例如，选择监控、条件执行、概率选择、随机选择等），每个节点上还可以支持添加附件（前置、后置和事件等）。</p>
<p><img src="/img/articles/behaviac_nodes.png" alt="behaviac_nodes" /></p>
<p>此外，behaviac还提供了有限状态机（FSM），并支持FSM跟行为树的嵌套使用。</p>
<p>behaviac是基于类型信息的工作方式，只需要实现Agent子类及其属性、方法，然后在编辑器中创建行为树时选用这些属性或方法。</p>
<h4 id="section-5"><span class="ez-toc-section" id="i-7">条件终止</span></h4>
<p>BD为了实现终止执行，引入了条件终止（Conditional Abort）的概念，也就是设置了终止的节点将在每次更新时都会进行条件测试，以免从头开始执行整个行为树。这类似于虚幻引擎4（UE4）中的观察者终止（Observer Abort）。</p>
<p>如下图所示，Sequence节点设置了“Abort”标记，那么当第一个叶子节点“Int Comparison”返回为true时，可以执行到后面的Wait节点。这里Wait节点会等待10秒中，在这10秒内如果之前的“Int Comparison”节点返回为false时，那么Sequence节点会被重新开始执行。</p>
<p>behaviac的实现方式跟BD有所区别，可以通过“前置”附件来实现该功能。该前置附件的“执行时机”只要设置为“Enter/Update”，就可以支持当前节点在每次进入或执行时都会检测该前置条件，来决定它的子节点是否会被执行。</p>
<p>behaviac的前置附件机制可能更为灵活和通用，接下来介绍的节点类型也能通过前置来实现。</p>
<h4 id="section-6"><span class="ez-toc-section" id="i-8">中断节点</span></h4>
<p>BD提供了中断（Interrupt）和执行中断（Perform Interruption）节点。</p>
<p>如果中断节点被触发，则它的所有子节点的执行被中断。中断命令被执行中断节点发起。中断节点在收到中断命令前，不会打断子节点的执行状态。如果子节点执行完毕还没有收到任何中断命令，则直接返回子节点的执行结果，如下图所示：</p>
<p>behaviac没有提供中断相关的节点，可以通过“前置”附件来实现该功能。该前置附件的“执行时机”只要设置为“Enter/Update”，就可以支持当前节点在每次进入或执行时都会检测该前置条件，来决定它的子节点是否会被执行。</p>
<h4 id="section-7"><span class="ez-toc-section" id="i-9">监控节点</span></h4>
<p>BD提供了监控任务（Guard Task）来保证多个节点执行的互斥性，类似于多线程编程中的信号量（Semaphore）。</p>
<p>比如有两个不同的任务，一个播放声音，另一个播放特效。这两个任务在行为树里是两个不同的分支，所以它们之间并不知道对方的状态，有可能同一时间这两个任务被同时执行。但可能并不希望这种情况发生。在这种情况下，通过使用监控任务来保证当前要么播放音效，要么播放特效。只有当第一个播放完毕，才会播放第二个。</p>
<p>behaviac没有提供监控节点，可以通过“前置”附件来实现该功能。该前置附件的“执行时机”只要设置为“Enter/Update”，就可以支持当前节点在每次进入或执行时都会检测该前置条件，来决定它的子节点是否会被执行。</p>
<h4 id="section-8"><span class="ez-toc-section" id="i-10">事件系统</span></h4>
<p>BD提供了一个内置的事件系统，可以通过代码（BehaviorTree.SendEvent函数）触发事件，也可以通过行为树的节点来触发（SendEvent节点）和监听（HasReceivedEvent节点）事件。</p>
<p>behaviac的事件跟BD有所区别，通过附件的方式，将另一棵行为树作为附件添加到当前行为树的某个节点上，在游戏端（运行时）发送事件时进行响应，并切换到另一棵行为树。behaviac未提供BD中的SendEvent和HasRecivedEvent节点，只能在代码端发送事件，行为树里监听和响应事件。</p>
<h4 id="section-9"><span class="ez-toc-section" id="i-11">性能</span></h4>
<p>BD和behaviac都存在着部分代码使用了C#的反射来进行方法的调用，会影响性能。</p>
<p>在BD中，行为树在启动的时候会获取每个任务的事件接口。事件定义在了Behavior.EventTypes里，包括OnCollisionEnter和Update等物理和更新事件。获取事件的时候由于用到了C#的反射，所以当任务节点很多的时候，这个过程会非常的慢。</p>
<p>在behaviac中，解决方案是通过生成C#源码的方式来绕开反射的使用，目前XML版行为树的执行还依赖于反射，需要改进。</p>
<h4 id="section-10"><span class="ez-toc-section" id="i-12">热更新</span></h4>
<p>BD的行为树的扩展节点全部基于C#写脚本实现，行为树可以保存为JSON格式，可以在iOS平台进行热更新。</p>
<p>behaviac采用XML版的行为树，这些XML文件可以作为配置文件在iOS平台上进行热更新。</p>
<h4 id="section-11"><span class="ez-toc-section" id="i-13">调试</span></h4>
<p>BD的编辑器嵌套在Unity编辑器中，调试可以无需跟游戏建立连接，就可以直接设置断点、查看执行路径、修改变量进行调试。</p>
<p>而behaviac的编辑器是独立的exe。当进行调试时，需要将游戏端（运行时）跟编辑器建立连接，然后游戏端将数据发到编辑器，编辑器进行相应的显示，编辑器这边也可以修改参数并发送给游戏端进行测试。</p>
<p>behaviac独立的编辑器可以方便的与布局在Linux服务器上的游戏端进行远程连调，这也是BD所不支持的优势。<br />
此外，behaviac还支持离线调试，也就是在游戏结束后可以加载游戏中的log数据，再以图形化的形式表现出来。</p>
<h4 id="section-12"><span class="ez-toc-section" id="i-14">预制</span></h4>
<p>BD的编辑器没有预制（Prefab）的功能。</p>
<p>behaviac的编辑器提供了预制的功能，可以将一棵行为树保存为预制，然后在其他的行为树中可以使用该预制进行编辑，大大提高了复用相同功能行为树的编辑效率。</p>
<h4 id="section-13"><span class="ez-toc-section" id="i-15">编辑与查看</span></h4>
<p>在编辑行为树的过程中，通过实时的错误检测器，BD会立即显示行为树中的节点错误，这样方便开发者快速找出错误而不用等到运行时。类似的，如果修改了行为树，BD会在游戏场景中立即使用修改后的行为树。</p>
<p>behaviac对行为树错误的检测是通过在编辑器中手动的点击“检查错误”按钮或开始导出行为树时，才开始检查行为树中的错误。此外，如果修改了行为树，也需要手动导出该行为树后，通过热加载，游戏端才会自动体现修改后的效果。</p>
<p>因此，behaviac在实时编辑和检查错误方面，可以稍微改进跟BD保持一致流畅的用户体验。</p>
<div class="section-nav"></div>
]]></content:encoded>
					
					<wfw:commentRss>/bd_vs_behaviac/feed/</wfw:commentRss>
			<slash:comments>8</slash:comments>
		
		
			</item>
		<item>
		<title>C++生成代码大小的说明</title>
		<link>/code_size/</link>
					<comments>/code_size/#respond</comments>
		
		<dc:creator><![CDATA[jonygli]]></dc:creator>
		<pubDate>Mon, 09 May 2016 03:15:17 +0000</pubDate>
				<category><![CDATA[文章]]></category>
		<category><![CDATA[编译构建]]></category>
		<guid isPermaLink="false">/?p=204</guid>

					<description><![CDATA[C++版本广泛的用到了template。 Code bloat occurs because compilers generate code for all t<a class="moretag" href="/code_size/">Read More...</a>]]></description>
										<content:encoded><![CDATA[<p>C++版本广泛的用到了template。</p>
<blockquote><p>Code bloat occurs because compilers generate code for all templated functions in each translation unit that use them. Back in the day the duplicate code was not consolidated resulting in “code bloat”. These days the duplicate code can be removed at link time.</p></blockquote>
<p>所以，在看到产生的代码的大小后不要过于惊慌。（另外，编译速度也会比较慢。）</p>
<p>在3.4.0后的版本里，behaviac已经支持了Link Time Optimization（LTO）。LTO可以极大的减少产生代码的大小以及优化产生代码的效率。</p>
<h3 id="gcc">gcc</h3>
<ul>
<li>如下所示，通过参数指定<code class="highlighter-rouge">Release</code>以及<code class="highlighter-rouge">ForeUseRelease</code>可以打开LTO（如果你的gcc支持的话）<br />
<code class="highlighter-rouge">cmake -G "Unix Makefiles" -DCMAKE_BUILD_TYPE=Release -DBEHAVIAC_VERSION_MODE=ForeUseRelease --build ../../../..</code></li>
<li>或者通过cmake gui设置<code class="highlighter-rouge">CMAKE_BUILD_TYPE</code>为<code class="highlighter-rouge">Release</code>和<code class="highlighter-rouge">BEHAVIAC_VERSION_MODE</code>为<code class="highlighter-rouge">ForeUseRelease</code></li>
<li>gcc版本需要是4.9以上，低版本不支持LTO</li>
<li>其他版本的gcc请参考相应文档设置LTO</li>
</ul>
<h3 id="msvc">msvc</h3>
<ul>
<li>在visual studio中可以参考打开编译选项/Gy, /GL及/OPT:ICF /OPT:REF /LTCG链接选项</li>
<li>指定<code class="highlighter-rouge">ForeUseRelease</code>的时候，cmake生成的项目文件，在Release下缺省的已经打开上述优化开关。</li>
<li>也可以考虑调整O1,O2或Ox编译选项</li>
</ul>
<p>请参考<a href="http://Tencent.github.io/behaviac/docs/zh/articles/build">构建说明</a></p>
]]></content:encoded>
					
					<wfw:commentRss>/code_size/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>关于性能优化的说明</title>
		<link>/opt_practice/</link>
					<comments>/opt_practice/#comments</comments>
		
		<dc:creator><![CDATA[jonygli]]></dc:creator>
		<pubDate>Thu, 23 Jun 2016 03:25:55 +0000</pubDate>
				<category><![CDATA[文章]]></category>
		<category><![CDATA[优化]]></category>
		<guid isPermaLink="false">/?p=717</guid>

					<description><![CDATA[概述 behaviac作为图形化的脚本，设计上是用来调用代码（c++，c#）提供的方法，在调用这些方法的时候会有些额外消耗，该消耗已经被充分优化，可以参考消耗。<a class="moretag" href="/opt_practice/">Read More...</a>]]></description>
										<content:encoded><![CDATA[<h2><span class="ez-toc-section" id="i">概述</span></h2>
<p>behaviac作为图形化的脚本，设计上是用来调用代码（c++，c#）提供的方法，在调用这些方法的时候会有些额外消耗，该消耗已经被充分优化，可以参考<a href="/language/zh/tutorial10_performence/">消耗</a>。</p>
<p>实践中，要尽量把需要计算的操作由代码实现，通过方法提供给behaviac，behaviac只是去<strong>选择</strong>这些方法，behaviac作为<strong>选择者</strong>，发挥behaviac灵活直观的优势。</p>
<h2><span class="ez-toc-section" id="i-2">设计</span></h2>
<p>要想高效的使用behaviac，首先要有好的设计，需要什么Agent，Agent需要有什么属性，什么方法，有一个好的接口。所谓好，是指不能太底层，也不能太高层。</p>
<ul>
<li>太底层，意味着需要进行很多小的计算</li>
<li>太高层，意外着失去了灵活性</li>
</ul>
<p>底层的计算要尽量在代码（c++或c#）实现。behaviac用来做策略选择。</p>
<p>behaviac虽然提供了Assignment，Compute，Compare，IfElse等节点，允许做一些“小的”计算，允许就像写代码一样进行if else的基本选择，但不鼓励这样做。鼓励使用Selector，Sequence，前置，后置等节点及附件。</p>
<h2><span class="ez-toc-section" id="i-3">持续运行的动作</span></h2>
<p>Agent提供的方法，最好是能够持续运行的方法，比如，播放动画，移动一段距离，都是持续很多帧的动作；而不是只是返回某个值，然后再需要在行为树里根据该值做比较，进行计算，再执行其他小的一帧触发的方法。</p>
<p>持续运行的节点在下一帧会被持续继续执行，behaviac不会愚蠢的每一帧都从根节点重新执行。但是，不好的行为树（只是简单的成功或失败，没有返回运行的节点）就会迫使behaviac每一帧都不得不从根节点重新选择。可以参考行为树的<a href="/language/zh/concepts/">基本概念及进阶</a>。</p>
<p>持续运行的动作往往需要大量计算，由代码（c++或c#）实现，behaviac只是在高层去选择使用它，避免大量的计算。这样子，利用behaviac的灵活直观的优势而不会有性能的损失。</p>
<h2><span class="ez-toc-section" id="i-4">并行及选择检测节点</span></h2>
<p><a href="/language/zh/selectormonitor/">选择监测节点</a>以及<a href="/language/zh/parallel/">并行</a>节点用起来很方便，但是需要提醒的是，相比其他节点，这两个节点比较费。</p>
<p><a href="/language/zh/parallel/">并行</a>节点每次更新都会更新它所有的子节点（子树），<a href="/language/zh/selectormonitor/">选择监测节点</a>也是如此。不仅如此，这两个节点还会导致接管所在树对处于运行状态节点的控制，形成多一级的控制。（不理解没关系，总之，比其他节点更费。）</p>
<p>不是说这两个节点不能用，但是使用起来请注意其性能，特别的不能滥用，最好不要嵌套这两个节点。</p>
<h2><span class="ez-toc-section" id="i-5">发布版</span></h2>
<p>当发布版本或测量性能的时候，可以定义宏BEHAVIAC_RELEASE关闭开发功能，这样子性能是最优的。或者可以保留开发功能但使用<a href="/language/zh/config/">功能开关</a>有选择的关闭或打开开发功能。</p>
<p>关于BEHAVIAC_RELEASE可以参考<a href="/language/zh/tutorial10_performence/">优化及性能</a></p>
]]></content:encoded>
					
					<wfw:commentRss>/opt_practice/feed/</wfw:commentRss>
			<slash:comments>1</slash:comments>
		
		
			</item>
		<item>
		<title>优化及性能</title>
		<link>/performence/</link>
					<comments>/performence/#comments</comments>
		
		<dc:creator><![CDATA[admin]]></dc:creator>
		<pubDate>Fri, 13 May 2016 02:39:39 +0000</pubDate>
				<category><![CDATA[文章]]></category>
		<category><![CDATA[连调]]></category>
		<category><![CDATA[优化]]></category>
		<category><![CDATA[编译构建]]></category>
		<category><![CDATA[运行时]]></category>
		<guid isPermaLink="false">/?p=300</guid>

					<description><![CDATA[优化及性能 宏BEHAVIAC_RELEASE定义的时候是最终版，BEHAVIAC_RELEASE没有定义的时候是为开发版。 在debug版中，BEHAVIAC<a class="moretag" href="/performence/">Read More...</a>]]></description>
										<content:encoded><![CDATA[<h2 id="section">优化及性能</h2>
<p>宏BEHAVIAC_RELEASE定义的时候是最终版，BEHAVIAC_RELEASE没有定义的时候是为开发版。</p>
<ul>
<li>在debug版中，BEHAVIAC_RELEASE缺省下没有定义的。诸如logging、socketing、热加载等开发功能是有效的。可以通过behaviac::Config::IsLogging和behaviac::Config::IsSocketing来控制是否要Log到文件或是否与编辑器的连接。</li>
<li>在release版中，BEHAVIAC_RELEASE缺省是有定义的。诸如logging、socketing、热加载等开发功能都是没有定义的。</li>
</ul>
<div class="note info">
<h5>BEHAVIAC_RELEASE缺省下是否定义的说明</h5>
</div>
<p>BEHAVIAC_RELEASE缺省下是否定义可以参考文章《<a href="/language/zh/build/">构建说明</a>》。</p>
<p>简单来说对于Cpp，当使用CMake的时候，BEHAVIAC_VERSION_MODE用来控制BEHAVIAC_RELEASE是否定义：</p>
<ol>
<li>Default：缺省模式是Debug下BEHAVIAC_RELEASE没有定义，而Release下BEHAVIAC_RELEASE有定义</li>
<li>ForceUseDev：强制不定义BEHAVIAC_RELEASE</li>
<li>ForceUseRelease：强制定义BEHAVIAC_RELEASE</li>
</ol>
<p>而当BEHAVIAC_RELEASE有定义的最终版里，logging和socketing是关闭的，也不支持连接编辑器。</p>
<p>具体可以参考文章《<a href="/language/zh/config/">开发功能开关</a>》。</p>
<p>总之，针对效率可以有下述选择：</p>
<ol>
<li>定义BEHAVIAC_RELEASE，从而不编译诸如logging、socketing、热加载等开发功能，提供最高效率，也不支持连调功能。
<ul>
<li>C++下，在_config.h中定义BEHAVIAC_RELEASE为1</li>
<li>C#下，在Assets目录下的smcs.rsp文件中，定义BEHAVIAC_RELEASE</li>
<li>如果想选择打开或关闭调试功能而不是完全的关闭，则不需要修改任何关于BEHAVIAC_RELEASE的定义，通过behaviac::Config::SetLogging和behaviac::Config::SetSocketing来控制是否打开logging和socketing。</li>
</ul>
</li>
<li>不使用xml或bson格式，而是使用C++或C#格式
<ul>
<li>C#下，还需要那些在行为树中使用到的Agent的成员都是public的（非public的成员即使通过C#代码访问也需要使用反射系统来进行，会导致GC Alloc以及性能损失）。</li>
</ul>
</li>
</ol>
<div class="note info">
<h5>overhead</h5>
</div>
<p>behaviac可以导出xml(bson)，或者源码（cpp/c#），源码的效率要优于数据（xml/bson）的执行效率。实际上这里的效率都是指的behaviac本身的overhead，如果提供的<code class="highlighter-rouge">方法</code>本身效率很低，运行很慢，behaviac本身的overhead就可以忽略不计了，无论是选用导出何种格式都遇事无补，这个时候，最需要解决的是优化方法的执行效率。</p>
<p><img src="/img/references/overhead.png" alt="overhead" /><br />
如上图，尽管xml格式是cpp格式的大约2倍，但这个overhead实际上是非常小的，只有0.0000269秒，0.0269毫秒。（具体数据会因为测试环境的不同有差异）。</p>
]]></content:encoded>
					
					<wfw:commentRss>/performence/feed/</wfw:commentRss>
			<slash:comments>3</slash:comments>
		
		
			</item>
		<item>
		<title>调试功能的说明</title>
		<link>/debugging_desc/</link>
					<comments>/debugging_desc/#comments</comments>
		
		<dc:creator><![CDATA[jonygli]]></dc:creator>
		<pubDate>Fri, 17 Jun 2016 07:50:54 +0000</pubDate>
				<category><![CDATA[文章]]></category>
		<category><![CDATA[连调]]></category>
		<guid isPermaLink="false">/?p=622</guid>

					<description><![CDATA[behaviac提供了离线调试以及连调功能。 离线调试 离线调试功能是指在编辑器里加载运行时产生的_behaviac_$_.log文件，如下图，可以加载_beh<a class="moretag" href="/debugging_desc/">Read More...</a>]]></description>
										<content:encoded><![CDATA[<p>behaviac提供了离线调试以及连调功能。</p>
<h2>离线调试</h2>
<p>离线调试功能是指在编辑器里加载运行时产生的_behaviac_$_.log文件，如下图，可以加载_behaviac_$_.log文件：</p>
<p><img class="alignnone size-medium wp-image-625" src="/wp-content/uploads/2016/06/offline-300x194.png" alt="offline" width="300" height="194" srcset="/wp-content/uploads/2016/06/offline-300x194.png 300w, /wp-content/uploads/2016/06/offline.png 328w" sizes="(max-width: 300px) 100vw, 300px" /></p>
<p>_behaviac_$_.log是运行游戏时产生的log文件。一般都是产生在exe所在的目录，对于Unity，是产生在Assets的同级目录。</p>
<p><img class="alignnone size-medium wp-image-626" src="/wp-content/uploads/2016/06/off-300x225.png" alt="off" width="300" height="225" srcset="/wp-content/uploads/2016/06/off-300x225.png 300w, /wp-content/uploads/2016/06/off-768x576.png 768w, /wp-content/uploads/2016/06/off.png 1024w" sizes="(max-width: 300px) 100vw, 300px" /></p>
<p>在离线调试里，可以模拟游戏的运行，甚至可以设断点，然后查看变量的当前值，可以查看树的执行情况。</p>
<p>文件_behaviac_$_.log只在开发版本下产生，或者是Config::IsLogging为true时产生。</p>
<p>可以参考：<a href="/language/zh/tutorial10_performence/">优化与性能</a>和<a href="/language/zh/config/">开发功能开关</a>。</p>
<h2>连调</h2>
<p>连调功能是指在游戏运行的时候，编辑器可以连上游戏，实时的查看树的运行情况，变量的当前值，可以设断点等。而离线调试实际上是回放运行时产生的log。</p>
<p>和上面离线调试时需要在开发版本下一样，连调同样需要游戏是开发版本，发布版本下没有连调的功能。可以参考：<a href="/language/zh/tutorial10_performence/">版本说明</a>和<a href="/language/zh/config/">开发功能开关</a>。</p>
<p>除此之外，还需要下面的事项：</p>
<ol>
<li>请检查Agent::SetIdMask 和 Agent::SetIdFlag的调用是否合适。IdFlag和IdMask都是int，IdMask是个公用的Mask，而IdFlag是设置给某个Agent实例的，当(IdFlag &amp; IdMask)!= 0的时候，该Agent才被调试。</li>
<li>请确保游戏确实在更新，具体可以参考<a href="/docs/zh/tutorials/tutorial13_updateloop/" target="_blank" rel="nofollow">更新流程</a>。Workspace::DebugUpdate需要被调用，如果只是调用Agent::btexec来更新，则连调功能不能正常工作。</li>
</ol>
<p>有问题可以参考<a href="http://bbs.behaviac.com/index.php/tag/%E8%BF%9E%E8%B0%83">连调相关常见问题</a></p>
]]></content:encoded>
					
					<wfw:commentRss>/debugging_desc/feed/</wfw:commentRss>
			<slash:comments>1</slash:comments>
		
		
			</item>
		<item>
		<title>版本号说明</title>
		<link>/version/</link>
					<comments>/version/#respond</comments>
		
		<dc:creator><![CDATA[jonygli]]></dc:creator>
		<pubDate>Mon, 09 May 2016 03:16:57 +0000</pubDate>
				<category><![CDATA[文章]]></category>
		<category><![CDATA[概述]]></category>
		<guid isPermaLink="false">/?p=206</guid>

					<description><![CDATA[在源码和安装包的根目录都提供了version.txt，unity的源码里也提供了version.txt。 version.txt中的版本号和安装包（如Behav<a class="moretag" href="/version/">Read More...</a>]]></description>
										<content:encoded><![CDATA[<p>在源码和安装包的根目录都提供了<a href="https://github.com/Tencent/behaviac/blob/master/version.txt">version.txt</a>，unity的源码里也提供了<a href="https://github.com/Tencent/behaviac/blob/master/integration/unity/Assets/Scripts/behaviac/runtime/version.txt">version.txt</a>。</p>
<ol>
<li>version.txt中的版本号和安装包（如BehaviacSetup_3.3.16.exe）的版本号以及编辑器的版本号是一致的。请使用相同版本号的编辑器和运行时。</li>
<li>version.txt的存在是用来表明该版本的版本号之用，出现了问题请提供该版本号。</li>
<li>version.txt只是从3.3.16版本后才提供，之前的版本中没有该文件。</li>
<li>Cpp版本中提供了函数<code class="highlighter-rouge">behaviac::GetVersionString()</code>来返回版本号，该版本号和version.txt中的版本号是一致的。</li>
<li>Cpp版本运行的时候，有下图所示的信息。<br />
<img class="aligncenter size-full wp-image-1275" src="/wp-content/uploads/2016/05/version.png" alt="version" width="583" height="138" srcset="/wp-content/uploads/2016/05/version.png 583w, /wp-content/uploads/2016/05/version-300x71.png 300w" sizes="(max-width: 583px) 100vw, 583px" /></p>
<ul>
<li>第一行就包含了版本信息。其中的debug，NRELEASE等信息是用来表明是否定义了宏<code class="highlighter-rouge">_DEBUG</code>或<code class="highlighter-rouge">DEBUG</code>,<code class="highlighter-rouge">BEHAVIAC_RELEASE</code></li>
<li>该信息在vs的输出窗口中有输出，在<code class="highlighter-rouge">_behaviac_$_$_.log</code>文件里也有输出</li>
</ul>
</li>
</ol>
]]></content:encoded>
					
					<wfw:commentRss>/version/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>开发功能开关</title>
		<link>/config/</link>
					<comments>/config/#comments</comments>
		
		<dc:creator><![CDATA[jonygli]]></dc:creator>
		<pubDate>Mon, 11 Apr 2016 09:57:37 +0000</pubDate>
				<category><![CDATA[文章]]></category>
		<category><![CDATA[连调]]></category>
		<category><![CDATA[概述]]></category>
		<category><![CDATA[编译构建]]></category>
		<guid isPermaLink="false">/?p=160</guid>

					<description><![CDATA[behaviac的运行时提供有核心的更新行为树的功能，在其之上，还有logging，热加载，连调等调试功能。这些调试功能只是‘开发’功能，在游戏发布后实际上是不<a class="moretag" href="/config/">Read More...</a>]]></description>
										<content:encoded><![CDATA[<p>behaviac的运行时提供有核心的更新行为树的功能，在其之上，还有logging，热加载，连调等调试功能。这些调试功能只是‘开发’功能，在游戏发布后实际上是不需要的。</p>
<p>除了可以在<code>config.h</code>中定义<code>BEHAVIAC_RELEASE</code>宏为1来完全使‘开发功能’不被编译外。也可以保留这些‘开发’功能但只是使用下面所列的‘开关’来关闭或者打开某些功能。</p>
<p>具体可以参考<a href="/language/zh/tutorial10_performence/">优化及性能</a></p>
<h2>Cpp</h2>
<pre class="brush: cpp; title: ; notranslate">namespace behaviac
{
class BEHAVIAC_API Config
{
public:
static bool IsProfiling();
static void SetProfiling(bool bEnabled);

//logging是否打开
static bool IsLogging();
static void SetLogging(bool bLogging);

//logging打开的情况下，是否每次logging的时候都Flush
static bool IsLoggingFlush();
static void SetLoggingFlush(bool bFlush);

//socket连接是否打开，只有打开socket连接，连调功能才会支持
static bool IsSocketing();
static void SetSocketing(bool bSocketing);

//是否是阻塞模式，当时阻塞模式的时候，游戏会阻塞，等待编辑器的连接，
//只有成功建立连接后，游戏才继续运行
static bool IsSocketBlocking();
static void SetSocketBlocking(bool bBlocking);

//游戏和编辑器建立连接的时候使用的端口
static void SetSocketPort(unsigned short port);
static unsigned short GetSocketPort();

//热加载是否打开
static bool IsHotReload();
static void SetHotReload(bool bHotReload);
};</pre>
<p>具体的代码可以查看<a href="{{site.repository}}/blob/master/inc/behaviac/base/workspace.h">behaviac/base/workspace.h</a></p>
<h2>Unity</h2>
<p>C#下同名函数的意义和Cpp一样，此外，<code>IsSuppressingNonPublicWarning</code>是个用来控制是否输出非public成员的警告。</p>
<p>当<code>IsSuppressingNonPublicWarning</code>为true的时候，Agent的成员（field，method，property）如果不是public的，则输出警告信息，从而可以修改其为public，这样的话，当使用导出格式为c#时其效率就是最高的，而且没有GC Alloc。</p>
<p>具体的代码请查看<a href="{{site.repository}}/blob/master/integration/unity/Assets/Scripts/behaviac/runtime/Workspace.cs">behaviac/runtime/workspace.cs</a></p>
]]></content:encoded>
					
					<wfw:commentRss>/config/feed/</wfw:commentRss>
			<slash:comments>4</slash:comments>
		
		
			</item>
		<item>
		<title>运行时端常用类的介绍</title>
		<link>/basic_classes/</link>
					<comments>/basic_classes/#respond</comments>
		
		<dc:creator><![CDATA[admin]]></dc:creator>
		<pubDate>Mon, 11 Apr 2016 09:49:47 +0000</pubDate>
				<category><![CDATA[文章]]></category>
		<category><![CDATA[上手]]></category>
		<category><![CDATA[运行时]]></category>
		<guid isPermaLink="false">/?p=152</guid>

					<description><![CDATA[在使用behaviac运行时端（Runtime）的源代码或API时，有几个最常用的类值得注意：如Workspace、Agent、Config等。 Workspa<a class="moretag" href="/basic_classes/">Read More...</a>]]></description>
										<content:encoded><![CDATA[<p>在使用behaviac运行时端（Runtime）的源代码或API时，有几个最常用的类值得注意：如Workspace、Agent、Config等。</p>
<h3>Workspace类</h3>
<p>Workspace类主要用于管理类型信息的导出，加载、卸载、执行、停止执行行为树，设置时间和帧数等。</p>
<ul>
<li>GetInstance() ：用于获取Workspace的单件实例。</li>
<li>ExportMetas(const char*) ：导出类型信息文件到指定的路径，详见文档《<a href="{{site.url}}{{site.baseurl}}/docs/zh/tutorials/tutorial3_1_meta_cpp_register/">C++运行时端中类型信息的注册和导出</a>》。</li>
<li>SetFilePath(const char*) ：用于加载行为树时指定行为树文件所在的目录。</li>
<li>SetFileFormat(EFileFormat) ：用于指定加载行为树文件的格式，包括Xml、Bson、Cpp/Cs、Default。其中Default表示先尝试加载Xml格式，如果找不到再尝试加载Bson格式，最后尝试加载Cpp/Cs格式，这个功能可用于行为树的热更新。</li>
<li>Update() ：用于执行所有Agent的当前行为树，行为树的执行也可以不通过该API，可以自己单独调用Agent的btexec()方法，详见文档《<a href="{{site.url}}{{site.baseurl}}/docs/zh/tutorials/tutorial13_updateloop/">运行时端的更新流程</a>》。</li>
<li>DebugUpdate() ：用于执行调试和热加载相关的方法，如果已经使用了Update()方法来执行，则连调或热加载时就不需要再调用该DebugUpdate()方法。</li>
<li>SetIsExecAgents(bool) ：用于停止/继续执行所有Agent的当前行为树，前提是行为树是执行是通过Update()方法发起的。如果是自己单独调用Agent的btexec()方法，则通过Agent的SetActive(bool)方法来停止/继续执行。</li>
<li>SetTimeSinceStartup(double) ：用于设置游戏从启动到当前的总时间，该总时间主要用于时间、等待时间等与时间有关的节点的执行。如果不每帧设置该值，这些节点将不会正常工作。</li>
<li>SetFrameSinceStartup(int) ：用于设置游戏从启动到当前的总帧数，该总帧数主要用于帧数、等待帧数等与帧数有关的节点的执行。如果不每帧设置该值，这些节点将不会正常工作。</li>
</ul>
<p>具体的代码可以查看<a href="{{site.repository}}/blob/master/inc/behaviac/base/workspace.h">behaviac/base/workspace.h</a></p>
<h3>Agent类</h3>
<p>静态方法：</p>
<ul>
<li>Create(const char*, int, short) ：用于创建Agent的实例。</li>
<li>Destroy(Agent*) ：用于销毁Agent的实例。</li>
<li>Register() ：注册该Agent类，用于记录该类的类型信息。</li>
<li>UnRegister() ：取消注册该Agent类。</li>
<li>RegisterInstanceName(const char*, const wchar_t*, const wchar_t*) ：注册实例名字，作为类型信息的一部分，导出后可用于编辑器中节点的配置。</li>
<li>UnRegisterInstanceName(const char*) ：取消注册实例名字。</li>
<li>BindInstance(Agent*, const char*, int) ：将某个Agent实例跟某个名字进行绑定。</li>
<li>UnbindInstance(const char*, int） ：取消某个Agent实例跟某个名字的绑定。</li>
</ul>
<p>成员方法：</p>
<ul>
<li>btload(const char*, bool) ：用于加载指定名字的行为树，不需要后缀名（文件格式）。</li>
<li>btunload(const char*) ：用于卸载指定名字的行为树。</li>
<li>btsetcurrent(const char*) ：用于设置当前行为树。</li>
<li>btexec() ：执行当前行为树。</li>
<li>SetActive(bool) ：用于停止/继续执行当前行为树，如果设置为false，表示停止执行当前行为树；否则，表示继续执行。</li>
<li>FireEvent(const char*) ：用于发出事件，以便于行为树中绑定的事件得到响应。</li>
<li>SetIdFlag(uint32_t) ：用于设置连调时是否需要跟踪该Agent。通过静态方法SetIdMask()设置全部Agent的Mask值，然后再通过SetIdFlag()设置当前Agent的Flag值。如果IsMasked()返回为真，则表明需要跟踪该Agent。</li>
<li>SetName(const char*) ：用于设置名字。</li>
</ul>
<p>具体的代码可以查看<a href="{{site.repository}}/blob/master/inc/behaviac/agent/agent.h">behaviac/agent/agent.h</a></p>
<h3>Config类</h3>
<p>详见文档《<a href="{{site.url}}{{site.baseurl}}/docs/zh/articles/config/">开发功能开关</a>》。</p>
]]></content:encoded>
					
					<wfw:commentRss>/basic_classes/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>使用cmake构建C++版运行时库</title>
		<link>/build/</link>
					<comments>/build/#comments</comments>
		
		<dc:creator><![CDATA[jonygli]]></dc:creator>
		<pubDate>Mon, 11 Apr 2016 09:55:36 +0000</pubDate>
				<category><![CDATA[文章]]></category>
		<category><![CDATA[上手]]></category>
		<category><![CDATA[C++]]></category>
		<category><![CDATA[编译构建]]></category>
		<guid isPermaLink="false">/?p=156</guid>

					<description><![CDATA[请首先到/language/zh/downloads/下载或克隆源码。 缺省的，我们使用cmake来生成对应平台的<a class="moretag" href="/build/">Read More...</a>]]></description>
										<content:encoded><![CDATA[<p>请首先到<a href="/language/zh/downloads/#https://github.com/Tencent/behaviac">/language/zh/downloads/</a>下载或克隆源码。</p>
<p id="cpp">缺省的，我们使用<a href="https://cmake.org/download/">cmake</a>来生成对应平台的项目文件（sln或make文件等）。</p>
<p>但cmake不是必须的，也可以选择自己喜欢的方式创建自己的项目文件。比如，使用premake等来生成项目文件，或者手工创建。</p>
<h3></h3>
<h3 id="windows"><span class="ez-toc-section" id="Windows">Windows平台</span></h3>
<ul>
<li>下载并安装<a href="https://cmake.org/download/">cmake</a>，请使用3.3以上版本</li>
<li>cmake的路径需要添加到环境变量PATH</li>
<li>运行build目录下的cmake_generate_projects.bat生成项目文件</li>
<li>如果需要build android版本
<ul>
<li>需要安装vs2015</li>
<li>使用android_vs2015子目录下的项目文件</li>
<li>或者使用cmake生成项目文件
<ul>
<li>下载并安装<a href="https://github.com/Microsoft/CMake/releases">cmake android</a>, 直接覆盖上面步骤安装的cmake就好。</li>
<li>运行build目录下的cmake_generate_projects_android.bat生成项目文件</li>
<li>如果想使用mk，可以修改生成的linux下的make文件</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="section"><span class="ez-toc-section" id="i">其他平台</span></h3>
<ul>
<li>下载并安装<a href="https://cmake.org/">cmake</a>，请使用3.3以上版本</li>
<li>如果可能，请保证4.4.6以上版本的gcc
<ul>
<li>使用版本为4.4.6的gcc可以顺利编译，但4.1.2的gcc有错误（未测试低于4.4.6的版本）</li>
</ul>
</li>
<li>运行build目录下的cmake_generate_projects.sh生成项目文件
<ul>
<li>mac上，运行build目录下的cmake_generate_projects_mac.sh生成项目文件</li>
</ul>
</li>
</ul>
<h3 id="section-1"><span class="ez-toc-section" id="i-2">注意</span></h3>
<ol>
<li>cmake_generate*.bat里使用的是vs2013和vs2015，用户可以根据自己的需要选择相应的编译器，比如vs2008、vs2010等，或者通过cmakegui进行选择。</li>
<li>CMakeLists.txt里提供的是缺省设置，可以根据自己的需要直接修改或通过cmakegui来选择配置。特别的，CMakeLists.txt里有若干个选项可以配置。<br />
<img src="/img/concepts/cmake_config.png" alt="cmake_config" /></p>
<ul>
<li>BEHAVIAC_VERSION_MODE用来控制BEHAVIAC_RELEASE是否定义。BEHAVIAC_RELEASE的用途请参考文章《<a href="/docs/zh/articles/tutorial10_performence">优化及性能</a>》。
<ul>
<li>Default：缺省模式是Debug下BEHAVIAC_RELEASE没有定义，而Release下BEHAVIAC_RELEASE有定义</li>
<li>ForceUseDev：强制不定义BEHAVIAC_RELEASE</li>
<li>ForceUseRelease：强制定义BEHAVIAC_RELEASE
<ul>
<li>在ForceUseRelease的时候，Release下，生成的项目文件会试图打开LTO开关，请参考文档《<a href="/docs/zh/articles/code_size">Cpp生成代码大小的说明</a>》</li>
</ul>
</li>
</ul>
</li>
<li>CMAKE_BUILD_TYPE用来控制生成Debug还是Release（Visual Studio的时候不需要指定CMAKE_BUILD_TYPE）</li>
<li>BUILD_SHARED_LIBS用来控制libbehaviac是stati lib/a还是dynamid dll/so</li>
<li>BUILD_USE_64BITS用来控制是否生成64位 （使用Visual Studio时，需要指定带Win64的generator，请参考cmake的文档）</li>
<li>根据上面的配置，CMake生成下面的_config.h文件，用来自动定义宏BEHAVIAC_RELEASE，如下图所示：<img class="aligncenter size-full wp-image-1650" src="/wp-content/uploads/2016/04/config.png" alt="" width="874" height="286" srcset="/wp-content/uploads/2016/04/config.png 874w, /wp-content/uploads/2016/04/config-300x98.png 300w, /wp-content/uploads/2016/04/config-768x251.png 768w" sizes="(max-width: 874px) 100vw, 874px" /></li>
<li>在另一个文件config.h中，会根据_DEBUG或DEBUG宏来尝试重新定义宏BEHAVIAC_RELEASE，如果在_config.h中宏BEHAVIAC_RELEASE并没有定义，如下图所示：<img class="aligncenter size-full wp-image-1651" src="/wp-content/uploads/2016/04/config-1.png" alt="" width="855" height="372" srcset="/wp-content/uploads/2016/04/config-1.png 855w, /wp-content/uploads/2016/04/config-1-300x131.png 300w, /wp-content/uploads/2016/04/config-1-768x334.png 768w" sizes="(max-width: 855px) 100vw, 855px" /></li>
</ul>
</li>
<li>cmake不是必须的
<ul>
<li>你可以选择自己喜欢的其他类似工具，比如premake等来生成项目文件。</li>
<li>或者，你可以手工创建项目文件。</li>
<li>又或者，可以直接把src和inc加到你已有的项目文件。</li>
<li>当你自行修改或创建项目文件的时候，可能需要参考CMakeLists.txt查看需要的设置：
<ul>
<li>include_directories包含目录，你需要设置正确的包含目录</li>
<li>add_definitions编译宏，比如_DEBUG</li>
<li>add_target_definitions编译宏，比如BEHAVIACDLL_EXPORTS，BEHAVIAC_DLL</li>
<li>CMAKE_CXX_FLAGS编译开关</li>
<li>BUILD_SHARED_LIBS是否动态库还是静态库</li>
</ul>
</li>
</ul>
</li>
<li>build\android_vs2015是提供的缺省的使用Visual Studio 2015来生成android项目的项目工程，支持64位。</li>
<li>可以使用cmakegui选择设置，或者在cmake的命令行里指定设置（ -DCMAKE_BUILD_TYPE=Debug -DBUILD_USE_64BITS=ON等）。请参考<a href="https://github.com/Tencent/behaviac/blob/master/build/cmake_generate_projects.bat">build/cmake_generate_projects.bat</a>或者cmake文档。</li>
</ol>
<h3 id="section-2"><span class="ez-toc-section" id="i-3">构建</span></h3>
<ul>
<li>无论Windows平台还是其他平台，项目文件都生成到目录cmake_binary</li>
<li>项目文件生成到目录cmake_binary，根据选用的编译工具（vs2013、make等）打开相应目录的项目文件或运行make等进行构建</li>
<li>.a、.lib、.dll、.exe等被生成到根目录的lib目录和bin目录</li>
<li>生成的项目配置(mvsc, linxu, xcode)包含了Debug和Release，请根据需要构建Debug或Release版本</li>
</ul>
<h2 id="unity"></h2>
]]></content:encoded>
					
					<wfw:commentRss>/build/feed/</wfw:commentRss>
			<slash:comments>6</slash:comments>
		
		
			</item>
		<item>
		<title>共享资源和实例数据</title>
		<link>/memory_shared/</link>
					<comments>/memory_shared/#comments</comments>
		
		<dc:creator><![CDATA[jonygli]]></dc:creator>
		<pubDate>Mon, 11 Apr 2016 09:59:42 +0000</pubDate>
				<category><![CDATA[文章]]></category>
		<category><![CDATA[概念]]></category>
		<guid isPermaLink="false">/?p=164</guid>

					<description><![CDATA[每个行为树都只有一份单独的数据作为资源被加载。 每个使用行为树的对象（Agent）依据这个共享的资源创建独立的实例数据，例如对于Sequence节点，实例数据中<a class="moretag" href="/memory_shared/">Read More...</a>]]></description>
										<content:encoded><![CDATA[<p>每个行为树都只有一份单独的数据作为资源被加载。</p>
<p>每个使用行为树的对象（Agent）依据这个共享的资源创建独立的实例数据，例如对于Sequence节点，实例数据中只是存储更新到哪个子树，至于Sequence节点的配置信息等则被共享。</p>
<p><img src="/img/faq/memory_shared.png" alt="memory_shared" /></p>
<hr />
<ul>
<li>加载行为树请使用<code>Workspace::Load</code>或<code>Agent::btload</code></li>
<li>卸载行为树请使用<code>Workspace::UnLoad</code>或<code>Agent::btunload</code></li>
<li><code>Workspace::CreateBehaviorTreeTask</code>用来根据加载的行为树资源创建实例数据，而它配套的是<code>Workspace::DestroyBehaviorTreeTask</code></li>
<li>一般情况下，不需要<strong>显式</strong>调用<code>Workspace::CreateBehaviorTreeTask</code>和<code>Workspace::DestroyBehaviorTreeTask</code>
<ul>
<li>初始化的时候调用<code>Workspace::Load</code>或<code>Agent::btload</code>加载可能会用到的行为树</li>
<li>游戏循环的时候，根据需要，调用<code>Agent::btsetcurrent</code>指定该Agent当前的行为树，后续<code>Agent::btexec</code>更新的就是当前行为树，除非再次调用<code>Agent::btsetcurrent</code>修改当前行为树</li>
<li>退出的时候，调用<code>Workspace::UnLoad</code>或<code>Agent::btunload</code>，或<code>Workspace::UnLoadAll</code>卸载行为树资源。而行为树实例是在<code>Agent::btsetcurrent</code>的时候被创建的，释放Agent的时候被Agent负责释放</li>
</ul>
</li>
<li>C#代码是同名类型里的同名函数，如<code>Workspace.Load</code>和<code>Agent.btload</code></li>
</ul>
]]></content:encoded>
					
					<wfw:commentRss>/memory_shared/feed/</wfw:commentRss>
			<slash:comments>3</slash:comments>
		
		
			</item>
		<item>
		<title>behaviac升级的步骤及注意事项</title>
		<link>/updatenotes/</link>
					<comments>/updatenotes/#comments</comments>
		
		<dc:creator><![CDATA[jonygli]]></dc:creator>
		<pubDate>Mon, 11 Apr 2016 10:01:19 +0000</pubDate>
				<category><![CDATA[文章]]></category>
		<category><![CDATA[版本升级]]></category>
		<guid isPermaLink="false">/?p=168</guid>

					<description><![CDATA[ 相比之前版本，3.6.x版本有若干重大改动 3.6版本的概述，请参考文章《关于新旧版本的说明》。 3.6.x版本的编辑器将导出类型信息代码文件，运行时不需要注<a class="moretag" href="/updatenotes/">Read More...</a>]]></description>
										<content:encoded><![CDATA[<h2><span class="ez-toc-section" id="36x"> 相比之前版本，3.6.x版本有若干重大改动</span></h2>
<ol>
<li>3.6版本的概述，请参考文章《<a href="/language/zh/3-6-overview/">关于新旧版本的说明</a>》。</li>
<li>3.6.x版本的编辑器将导出类型信息<strong>代码文件</strong>，运行时<strong>不需要</strong>注册和导出xml类型信息文件。</li>
<li>如果3.6.x版本的编辑器打开之前版本的workspace文件，将读取xml类型信息文件并且转存其中的内容，之后的版本就不再需要xml类型信息文件了</li>
<li>下列宏及函数已删除，升级后使用该宏或代码的相应代码注释掉或删掉即可（升级的时候，只需要修改编译出现错误的部分，其他的不是必须修改的，因为为了尽可能向后兼容，已经把相关宏重新定义为了空）
<ol>
<li><del>BEHAVIAC_REGISTER_METHOD/BEHAVIAC_REGISTER_PROPERTY</del></li>
<li><del>BEHAVIAC_BEGIN_PROPERTIES/BEHAVIAC_END_PROPERTIES</del></li>
<li><del>BEGIN_PROPERTIES_DESCRIPTION/END_PROPERTIES_DESCRIPTION</del></li>
<li><del>behaviac::Agent::Register/behaviac::Agent::UnRegister</del></li>
<li><del>behaviac::TypeRegister::Register/behaviac::TypeRegister::UnRegister</del></li>
<li><del>behaviac::Agent::ExportMetas</del></li>
</ol>
</li>
<li><span style="color: #ff0000;"><strong>升级步骤</strong></span>
<ol>
<li>备份程序代码及workspace项目</li>
<li><strong>删掉</strong>老版本中behaviac的所有代码（src及inc等），使用新版本中behaviac的代码（src及inc等）。（因为很多文件被删除，不要只是覆盖！）</li>
<li>使用新版本的编辑器打开workspace.xml文件，重新导出（可能需要配置“代码生成位置”）
<ol>
<li>仔细阅读该说明，点击确定后，你的workspace文件将被更新（不能恢复，除非你预先有备份！）。<img class="alignnone size-full wp-image-1151" src="/wp-content/uploads/2016/04/QQ截图20161129165728.png" alt="qq%e6%88%aa%e5%9b%be20161129165728" width="496" height="357" srcset="/wp-content/uploads/2016/04/QQ截图20161129165728.png 496w, /wp-content/uploads/2016/04/QQ截图20161129165728-300x216.png 300w" sizes="(max-width: 496px) 100vw, 496px" /></li>
<li>在弹出来的类型信息浏览器中，点击下方的“应用”按钮，生成类型代码文件，点击左下方的“打开代码生成位置”，将生成的类型代码文件添加到程序make文件或项目文件中，并编译构建成为程序的一部分：<img class="alignnone size-medium wp-image-1138" src="/wp-content/uploads/2016/04/QQ截图20161125171027-1-250x300.png" alt="qq%e6%88%aa%e5%9b%be20161125171027" width="250" height="300" srcset="/wp-content/uploads/2016/04/QQ截图20161125171027-1-250x300.png 250w, /wp-content/uploads/2016/04/QQ截图20161125171027-1.png 612w" sizes="(max-width: 250px) 100vw, 250px" /></li>
<li>你可能需要通过菜单项“文件-&gt;编辑工作区”来配置“代码生成位置”，如下图： <img class="alignnone wp-image-1089" src="/wp-content/uploads/2016/04/QQ截图20161118193315-300x139.png" alt="qq%e6%88%aa%e5%9b%be20161118193315" width="365" height="169" srcset="/wp-content/uploads/2016/04/QQ截图20161118193315-300x139.png 300w, /wp-content/uploads/2016/04/QQ截图20161118193315.png 587w" sizes="(max-width: 365px) 100vw, 365px" /></li>
<li>通过菜单项“文件-&gt;导出全部&#8230;”，重新导出所有的行为树及生成所有的类型文件，如下图：<img class="alignnone size-medium wp-image-1144" src="/wp-content/uploads/2016/04/QQ截图20161125170748-1-199x300.png" alt="qq%e6%88%aa%e5%9b%be20161125170748" width="199" height="300" srcset="/wp-content/uploads/2016/04/QQ截图20161125170748-1-199x300.png 199w, /wp-content/uploads/2016/04/QQ截图20161125170748-1.png 395w" sizes="(max-width: 199px) 100vw, 199px" /></li>
</ol>
</li>
<li>把上一步中导出的源码加入工程中开始编译构建，并修改出现的编译错误，把出错的代码都删掉即可（如上述4中所说，那些宏和函数已删除。<strong>只需要修改编译出现错误的部分，其他的不是必须修改的，因为为了尽可能向后兼容，已经把相关宏重新定义为了空</strong>）</li>
<li>如果是C#版本，步骤基本一致。</li>
</ol>
</li>
<li>等待节点和等待帧数节点的使用，请分别参考文档：<a href="/language/zh/wait/">/language/zh/wait/</a>和<a href="/language/zh/waitframes/">/language/zh/waitframes/</a></li>
<li>按照上述步骤就可以正常运行了。对于“已有实现”的类型，如果需要修改，请参考下面的说明。</li>
</ol>
<p>&nbsp;</p>
<h3><span class="ez-toc-section" id="i">对于‘已有实现’的类型</span></h3>
<p>如果需要修改的话，有两个流程可以选择。可以选择生成代码，也可以选择不生成代码，请参考下面的步骤，选择自己适合的方式。</p>
<h4><span class="ez-toc-section" id="i-2">生成代码</span></h4>
<ol>
<li>打开类型信息浏览器，如下图，“生成代码?”没有勾选上的类型就是在程序里已经实现的类型，程序里已经有了相应的类型声明以及函数定义的代码。如下图中的ChildNodeTest在代码里已经有’class ChildNodeTest’了。<img class="alignnone size-full wp-image-1153" src="/wp-content/uploads/2016/04/QQ截图20161130142048.png" alt="qq%e6%88%aa%e5%9b%be20161130142048" width="612" height="735" srcset="/wp-content/uploads/2016/04/QQ截图20161130142048.png 612w, /wp-content/uploads/2016/04/QQ截图20161130142048-250x300.png 250w" sizes="(max-width: 612px) 100vw, 612px" /></li>
<li>勾选上该Checkbox，然后点击“应用”，会生成类型文件。</li>
<li>点击“打开代码生成位置”，可以看到ChildNodeTest.cs被生成了。在上图类型信息浏览器中，每个类的“生成位置”可以用来配置该类的生成位置，如果不配置，则使用工作区统一配置的代码生成位置。<img class="alignnone size-full wp-image-1129" src="/wp-content/uploads/2016/04/QQ截图20161124183705.png" alt="qq%e6%88%aa%e5%9b%be20161124183705" width="712" height="266" srcset="/wp-content/uploads/2016/04/QQ截图20161124183705.png 712w, /wp-content/uploads/2016/04/QQ截图20161124183705-300x112.png 300w" sizes="(max-width: 712px) 100vw, 712px" /></li>
<li>打开ChildNodeTest.cs，可以看到如下，<span style="color: #0000ff;"><strong>只能在红色框内添加自己的代码。红色框外面的修改将会在重新生成代码的时候被丢弃</strong></span>！需要手工的把原来类型中的代码复制到新生成的类里，而把原来的文件<span style="color: #ff0000;">删掉</span>！否则会有重复定义的错误产生。<img class="alignnone size-full wp-image-1149" src="/wp-content/uploads/2016/04/QQ截图20161128195834-1.png" alt="qq%e6%88%aa%e5%9b%be20161128195834" width="910" height="737" srcset="/wp-content/uploads/2016/04/QQ截图20161128195834-1.png 910w, /wp-content/uploads/2016/04/QQ截图20161128195834-1-300x243.png 300w, /wp-content/uploads/2016/04/QQ截图20161128195834-1-768x622.png 768w" sizes="(max-width: 910px) 100vw, 910px" /></li>
<li>从上可知，如果要修改类型名、成员名，请在“类型信息浏览器”中修改，然后“应用”就可以生成更新的代码。而其他相关代码只能添加在‘///&lt;&lt;&lt; BEGIN WRITING YOUR CODE’和‘///&lt;&lt;&lt; END WRITING YOUR CODE’中间，添加在这个块外面的代码在重新生成代码的时候将会丢失！C++代码也是同样的处理。<span style="color: #ff0000;">不要手工修改</span>‘///&lt;&lt;&lt; BEGIN WRITING YOUR CODE’后面的内容（例如FILE_INIT，FILE_UNINIT，CLASS_PART等），该内容在重新生成代码的时候将被使用到。</li>
<li>对于enum和struct，如果需要修改，也需要勾选上其&#8221;生成代码?&#8221;的Checkbox。</li>
</ol>
<h4><span class="ez-toc-section" id="i-3">不生成代码</span></h4>
<p>上述生成代码的流程，需要手工的把原来的代码copy/paste到生成的代码文件中有“///&lt;&lt;&lt; BEGIN WRITING YOUR CODE’和‘///&lt;&lt;&lt; END WRITING YOUR CODE”这样的注释块中间，比较麻烦！而且有人可能并不喜欢这样的形式，那么可以采取下面的流程：</p>
<ol>
<li>不要勾选“生成代码?”，任何修改依然在原来自己维护的代码中进行。</li>
<li>任何需要在行为树中暴露的属性或方法需要在类型信息浏览器中同样的添加，否则编辑器中将看不到该属性或方法，即不能被使用。但原来已有的不需要重复加入，添加后需要点击“应用”重新生成胶水代码。</li>
<li>另一方面，如果只是在编辑器中添加了属性或方法（添加后需要点击“应用”重新生成胶水代码），而在你的代码中没有相应的修改，编译程序的时候，会有编译错误。</li>
<li>如果运行没有重新编译的程序，有可能会有报错发生：
<ol>
<li>当只是添加了属性的时候，如果没有使用“应用”后重新生成的代码编译构建程序，而使用老的程序的时候，可以正常运行，只是新添加的属性作为自定义属性使用而已（编译构建后，新添加的属性就将作为Agent的真正成员，效率最高）。</li>
<li>当修改了方法（添加或改名），如果没有使用“应用”后重新生成的代码编译构建程序，而使用老的程序的时候，会有错误发生，在_behaviac_$_$.log中会有详细的错误输出。</li>
</ol>
</li>
</ol>
<h4><span class="ez-toc-section" id="i-4">总结比较</span></h4>
<p>从上面可以知道，对于从老版本升级到3.6.*的情况下，对于已经有了大量代码的类来说，可以选择依然使用原来的代码，或者可以选择生成代码。</p>
<p>使用原来的代码的好处是不需要copy/paste大量代码到新生成的类型文件中了，并且所有的代码都可以保持原来的风格，缺点是之后任何关于属性、方法的修改（改名、添加、删除等）都需要在类型信息浏览器中重复的做一遍。</p>
<p>选择生成代码的缺点是需要手工copy/paste大量的代码到新生成的类型文件里，并且需要忍受begin/end注释块的束缚。但好处是后续的修改都只需要在类型信息浏览器中改一次，重新生成就好了。</p>
<p>实际上即使对于选择了生成代码的情况，后续也可以再选择不生成代码，反之亦然。选择生成代码，则编辑器负责在你指定的位置生成代码；而选择不生成代码，编辑器将不为你生成代码，所有的代码由你自己来维护。二选一，如果选择生成代码，而自己原来维护的代码没用删掉，则会有编译错误！</p>
<p>另外，需要说明的是，这里的生成代码是指生成class的声明代码（.h和.cpp，或者.cs）。而不管这里是否选择生成代码，在点击“应用”的时候，都会生成所有类型的胶水代码，可以在配置的代码生成位置查看生成的behaviac_agent_meta.cpp文件或AgentProperties.cs，里面的代码就是所谓的“胶水”代码。</p>
<p>此外，我们知道，行为树的导出格式可以是xml或bson，也可以导出cpp或c#代码。即使采用xml或bson格式的时候，这里的“胶水”代码或者类型代码都会被生成，而且需要被添加到工程项目中参与编译构建！</p>
<p><span id="more-168"></span></p>
<h2><span class="ez-toc-section" id="34x35x">相比3.4.x版本，3.5.x版本有若干重大改动</span></h2>
<ol>
<li>用最新的代码把你们的游戏能够编译运行（如果可能首先删除旧的的代码及导出数据，用新代码替换。）</li>
<li>导出最新的meta的xml文件</li>
<li>用最新版本的编辑器打开老的workspace，重新导出</li>
<li>用3中导出的新的文件，重新编译构建，运行游戏</li>
</ol>
<p>大版本升级，导出文件的版本号都会有改变，不严格按照上述步骤的话，在运行游戏或编辑器的时候都会有报错。而小版本的升级的时候，导出文件的版本号没有改变，可以不严格按照上述步骤。</p>
<p>对于unity，3.5.3及以后的版本，在上述步骤3中导出文件的时候，会生成c#文件（AgentProperties.cs和customizedtypes.cs），需要添加都项目中，否则运行时会发生错误。</p>
<p>为了支持C# GC Free，生成的代码有大的变化，需要按照上述升级步骤升级版本，否则运行游戏或者编辑器都会有报错。</p>
<h2><span class="ez-toc-section" id="2x3x">相比2.x版本，3.x版本有若干重大改动</span></h2>
<ol>
<li>meta browser， 变量的使用更加统一和方便</li>
<li>preaction/postaction，任何一个节点都可以添加前置和后置，统一了用法和体验</li>
<li>支持了FSM</li>
</ol>
<h2><span class="ez-toc-section" id="2xAPItestunittesttestusertest">相比2.x版本，API的改动（请参考test/unittest或test/usertest中的代码）：</span></h2>
<ul>
<li>删掉了behaviac::Start, behaviac::Stop</li>
<li>LogManager::SetEnable -&gt; Config::SetLogging</li>
<li>删掉了World</li>
<li>删掉了SetWorkspaceSettings</li>
<li>删掉了REGISTER_EVENT</li>
<li>bttick rename to btexec</li>
<li>DECLARE_BEHAVIAC_OBJECT_NOVIRTUAL rename to DECLARE_BEHAVIAC_OBJECT_STRUCT</li>
<li>删掉了REGISTER_METHOD_CHECKRESULT</li>
<li>RegisterName -&gt; RegisterIntanceName, UnRegisterName -&gt; UnRegisterIntanceName</li>
<li>behaviac::Property::Registger, behaviac::Condition::Register -&gt; behaviac::TypeRegister::Register, UnRegister类似</li>
<li>在所有加载BT之前，调用behaviac::Workspace::GetInstance()-&gt;SetFilePath和behaviac:: Workspace::GetInstance()-&gt;SetFileFormat来设置路径和格式</li>
<li>behaviac::Workspace::ExportMetas修改为behaviac::Workspace::GetInstance()-&gt;ExportMetas，其他相应的对Workspace的函数的调用也要类似的修改</li>
<li>删掉了Workspace::LogFrames和Workspace::HandleRequests, 添加了Workspace::DebugUpdate</li>
<li>behaviac::World::GetInstance()-&gt;btexec()修改为behaviac::Workspace::GetInstance()-&gt;Update()</li>
</ul>
]]></content:encoded>
					
					<wfw:commentRss>/updatenotes/feed/</wfw:commentRss>
			<slash:comments>2</slash:comments>
		
		
			</item>
	</channel>
</rss>
