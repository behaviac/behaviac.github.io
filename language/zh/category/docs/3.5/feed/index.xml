<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>3.5 &#8211; behaviac</title>
	<atom:link href="/language/zh/category/docs/3.5//feed/" rel="self" type="application/rss+xml" />
	<link>/</link>
	<description>Tencent behaviac, Game AI, Behavior Tree, Finite State Machine, Hierarchical Task Network, BT FSM HTN, 腾讯开源, 游戏AI, 行为树,有限状态机,分层任务网络</description>
	<lastBuildDate>Mon, 16 Jan 2017 08:10:05 +0000</lastBuildDate>
	<language>zh-CN</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>https://wordpress.org/?v=5.4.1</generator>
	<item>
		<title>关于新旧版本的说明</title>
		<link>/version_desc/</link>
					<comments>/version_desc/#respond</comments>
		
		<dc:creator><![CDATA[cainhuang]]></dc:creator>
		<pubDate>Thu, 08 Dec 2016 09:55:13 +0000</pubDate>
				<category><![CDATA[3.5]]></category>
		<guid isPermaLink="false">/?p=1219</guid>

					<description><![CDATA[归类到“3.5”中的这些文章都是基于3.5及之前旧版本的文档，其他目录（“文章”、“教程”、“手册”等）下的文档都用于3.6及以上新版本，如下图所示： 其中，3<a class="moretag" href="/version_desc/">Read More...</a>]]></description>
										<content:encoded><![CDATA[<p>归类到“3.5”中的这些文章都是基于3.5及之前旧版本的文档，其他目录（“文章”、“教程”、“手册”等）下的文档都用于3.6及以上新版本，如下图所示：</p>
<p><img src="/wp-content/uploads/2016/12/docs_menu.png" alt="" width="205" height="283" class="aligncenter size-full wp-image-1460" /></p>
<p>其中，3.6及以上新版本的主要特性如下所示：</p>
<p align="center"><video src="http://dlied5.qq.com/behaviac/behaviac_overview.mp4" controls="controls" width="480" height="288"><br />
您的浏览器不支持 video 标签。<br />
</video></p>
<p>behaviac在3.6之后的新版本，不再从运行时（程序端）导出类型信息，而是将类型信息的编辑工作全部放在了编辑器端，如下图所示：</p>
<p><img class="size-full wp-image-1261 aligncenter" src="/wp-content/uploads/2016/12/workflow-1.png" alt="workflow" width="590" height="279" srcset="/wp-content/uploads/2016/12/workflow-1.png 590w, /wp-content/uploads/2016/12/workflow-1-300x142.png 300w" sizes="(max-width: 590px) 100vw, 590px" /></p>
<p>新的设计是工作流从编辑器到运行时的单向箭头，也即类型信息完全在编辑器端设计，类型信息以源码的形式生成，程序端再把编辑器生成的类型信息相关的源码编译进程序。最后，程序端加载并执行编辑器导出的行为树。</p>
<p>整个设计有如下优点：</p>
<ul>
<li>流程简单，没有歧义</li>
<li>程序员不需要写任何额外的代码，只需要把生成的代码加入工程</li>
<li>支持方便的添加新的类型或属性、方法，修改已有的类型或属性、方法，不再需要多次修改</li>
<li>属性不再必须是public的，被有效的封装</li>
<li>数据的兼容性检测，尽力支持策划和程序员并行工作，尽力避免策划等待程序员更新</li>
<li>支持热更新，将允许在代码不改变的情况下使用自定义变量以及修改行为树</li>
</ul>
<h2><span class="ez-toc-section" id="i"><strong>工作区</strong></span></h2>
<p>工作区用于管理整个项目的配置，包括一些位置和语言等参数，如下图所示：</p>
<p><img class="aligncenter size-full wp-image-1175" src="/wp-content/uploads/2016/12/new_workspace.png" alt="new_workspace" width="587" height="272" srcset="/wp-content/uploads/2016/12/new_workspace.png 587w, /wp-content/uploads/2016/12/new_workspace-300x139.png 300w" sizes="(max-width: 587px) 100vw, 587px" /></p>
<ul>
<li style="text-align: left;"><strong>工作区位置：</strong>保存工作区文件的目录，在该目录下会保存出*.workspace.xml的文件，该文件即是编辑器打开的工作区文件（或者称之为项目文件）。</li>
<li><strong>行为树源位置：</strong>对既有服务器，又有客户端的项目开发，可能需要共用行为树，这时候只要为服务器和客户端分别创建工作区，然后为它们设置相同的“行为树源位置”即可。这样，只需要编辑同一份行为树，就可以让服务器和客户端的AI逻辑保持一致。</li>
<li><strong>行为树导出位置：</strong>在该目录下，导出编辑好的行为树，并且需要在程序端设置的加载位置，以便程序运行起来后，加载所需的行为树。</li>
<li><strong>代码生成位置：</strong>用于存放后面将要描述的类型信息浏览器中编辑好的类型代码文件，还包含了一些“胶水”代码文件，都需要整合到运行时（游戏端）一起编译构建。</li>
<li><strong>程序端开发语言：</strong>可选cpp（即C++）和cs（即C#）两种，表示程序端的代码语言。结合上面所说的情况，可以支持服务器和客户端采用不同的语言编写代码，但共用同一份行为树数据。</li>
</ul>
<h2><span class="ez-toc-section" id="i-2">类型信息</span></h2>
<p>类型信息浏览器是进行类型信息查看和编辑的重要工具，可以管理（添加、删除、修改等）整个工作区所需的类型及其属性、方法、实例等信息，如下图所示：</p>
<h4><img class="aligncenter size-full wp-image-1264" src="/wp-content/uploads/2016/12/meta_browser-1.png" alt="meta_browser" width="612" height="735" srcset="/wp-content/uploads/2016/12/meta_browser-1.png 612w, /wp-content/uploads/2016/12/meta_browser-1-250x300.png 250w" sizes="(max-width: 612px) 100vw, 612px" /></h4>
<p style="text-align: left;">点击类型信息浏览器下方的“应用”按钮，编辑出来的类型信息会保存在工作区文件所在的同目录下。例如，假设工作区文件是FirstWorkspace.workspace.xml，则在它所在的目录下，会自动保存出FirstWorkspace.meta.xml文件。</p>
<p style="text-align: left;">此外，点击“应用”按钮后，还会在工作区中设置的“代码生成位置”生成类型及其相关的“胶水”代码文件。点击左下方的“打开代码生成位置”按钮，弹出“behaviac_generated/types”目录，如下图所示：</p>
<p><img class="aligncenter size-full wp-image-1184" src="/wp-content/uploads/2016/12/export_path.png" alt="export_path" width="310" height="186" srcset="/wp-content/uploads/2016/12/export_path.png 310w, /wp-content/uploads/2016/12/export_path-300x180.png 300w" sizes="(max-width: 310px) 100vw, 310px" /></p>
<p>注意：在自己的项目中，需要将“behaviac_generated/types/internal”目录中的所有cpp文件添加进自己的项目中，并且将“behaviac_types.h”头文件包含到自己的代码中以便能使用这些自动生成的“胶水”代码，如下图所示：</p>
<p><img class="aligncenter size-full wp-image-1222" src="/wp-content/uploads/2016/12/include_project.png" alt="include_project" width="286" height="208" /></p>
<p>其中，“behaviac_generated/types/internal”目录中的behaviac_agent_member_visitor.h文件生成了用于访问类的私有属性和方法的“胶水”代码，behaviac_agent_meta.h/cpp文件生成了用于注册类及其属性、方法、实例等信息的“胶水”代码，这些“胶水”代码的作用是为了程序端运行时，可以通过名字自动取用到类及其成员属性、方法及其实例等。</p>
<p>FirstAgent.h/cpp是生成的Agent子类文件，在里面可以根据需要继续添加自己的代码，如下代码所示：</p>
<p>FirstAgent.h：</p>
<pre style="padding-left: 30px;">#ifndef _BEHAVIAC_FIRSTAGENT_H_
#define _BEHAVIAC_FIRSTAGENT_H_

#include "behaviac_agent_headers.h"

///&lt;&lt;&lt; BEGIN WRITING YOUR CODE FILE_INIT

///&lt;&lt;&lt; END WRITING YOUR CODE

class FirstAgent : public behaviac::Agent
    ///&lt;&lt;&lt; BEGIN WRITING YOUR CODE FirstAgent
    ///&lt;&lt;&lt; END WRITING YOUR CODE
{
public:
    FirstAgent();

    virtual ~FirstAgent();

    BEHAVIAC_DECLARE_AGENTTYPE(FirstAgent, behaviac::Agent)

private:
    int p1;
public:
    inline void _set_p1(int value)
    {
        p1 = value;
    }
    inline int&amp; _get_p1()
    {
        return p1;
    }

public:
    void m1();

    ///&lt;&lt;&lt; BEGIN WRITING YOUR CODE CLASS_PART

    ///&lt;&lt;&lt; END WRITING YOUR CODE
};

///&lt;&lt;&lt; BEGIN WRITING YOUR CODE FILE_UNINIT

///&lt;&lt;&lt; END WRITING YOUR CODE

#endif</pre>
<p>FirstAgent.cpp：</p>
<pre>#include "FirstAgent.h"

///&lt;&lt;&lt; BEGIN WRITING YOUR CODE FILE_INIT

///&lt;&lt;&lt; END WRITING YOUR CODE

FirstAgent::FirstAgent()
{
    p1 = 0;

    ///&lt;&lt;&lt; BEGIN WRITING YOUR CODE CONSTRUCTOR

    ///&lt;&lt;&lt; END WRITING YOUR CODE
}

FirstAgent::~FirstAgent()
{
    ///&lt;&lt;&lt; BEGIN WRITING YOUR CODE DESTRUCTOR

    ///&lt;&lt;&lt; END WRITING YOUR CODE
}

void FirstAgent::m1()
{
    ///&lt;&lt;&lt; BEGIN WRITING YOUR CODE m1

    ///&lt;&lt;&lt; END WRITING YOUR CODE
}

///&lt;&lt;&lt; BEGIN WRITING YOUR CODE FILE_UNINIT

///&lt;&lt;&lt; END WRITING YOUR CODE</pre>
<p>注意：自己的代码需要添加在“///&lt;&lt;&lt; BEGIN WRITING YOUR CODE FILE_INIT”和“///&lt;&lt;&lt; END WRITING YOUR CODE”之间，以便下次生成代码时，可以自动进行合并。</p>
<p>此外，如果该类并没有勾选“生成代码”选项，那么在点击“应用”按钮后，将不会生成该类的代码，需要你自己完全手工编写。为了提高手工编写代码的效率，可以点击类型信息浏览器右上方的“预览原型代码”按钮，将会弹出该类的原型代码，可以选择需要的内容复制到你的代码中，如下图所示：</p>
<p><img class="aligncenter size-full wp-image-1186" src="/wp-content/uploads/2016/12/preview_prototype.png" alt="preview_prototype" width="605" height="230" srcset="/wp-content/uploads/2016/12/preview_prototype.png 605w, /wp-content/uploads/2016/12/preview_prototype-300x114.png 300w, /wp-content/uploads/2016/12/preview_prototype-604x230.png 604w" sizes="(max-width: 605px) 100vw, 605px" /></p>
<p style="text-align: left;">如果生成的文件中需要引用到你的项目中的其他头文件，可以点击上图中的“设置头文件”按钮，添加自己需要的.h文件，如下图所示：</p>
<p><img class="aligncenter size-full wp-image-1187" src="/wp-content/uploads/2016/12/set_headers.png" alt="set_headers" width="524" height="271" srcset="/wp-content/uploads/2016/12/set_headers.png 524w, /wp-content/uploads/2016/12/set_headers-300x155.png 300w" sizes="(max-width: 524px) 100vw, 524px" /></p>
<h2 style="text-align: left;"><span class="ez-toc-section" id="i-3"><strong>编辑行为树</strong></span></h2>
<p>根据在类型信息浏览器中创建的Agent子类，我们就可以开始创建和编辑行为树了。例如，行为树的根节点需要配置Agent类型，叶子节点需要配置相应的属性和方法，如下图所示：</p>
<p><img class="aligncenter size-full wp-image-1203" src="/wp-content/uploads/2016/12/right_bt.png" alt="right_bt" width="817" height="280" srcset="/wp-content/uploads/2016/12/right_bt.png 817w, /wp-content/uploads/2016/12/right_bt-300x103.png 300w, /wp-content/uploads/2016/12/right_bt-768x263.png 768w" sizes="(max-width: 817px) 100vw, 817px" /></p>
<p>在编辑器中编辑的行为树称之为”源行为树“，但程序端只能加载并执行导出后的行为树。因此，编辑完行为树之后，需要统一导出。</p>
<h2><span class="ez-toc-section" id="i-4"><strong>导出行为树</strong></span></h2>
<p>打开“导出”窗口，如下图所示：</p>
<p><img class="aligncenter size-full wp-image-1238" src="/wp-content/uploads/2016/12/export-1.png" alt="export" width="395" height="595" srcset="/wp-content/uploads/2016/12/export-1.png 395w, /wp-content/uploads/2016/12/export-1-199x300.png 199w" sizes="(max-width: 395px) 100vw, 395px" /></p>
<p style="text-align: left;">直接点击上图下方的 “导出”按钮，可以看到在工作区配置的“行为树导出位置”目录下，有了所有导出的行为树文件，如下图所示：</p>
<p><img class="aligncenter size-full wp-image-1223" src="/wp-content/uploads/2016/12/export_files-1.png" alt="export_files" width="226" height="191" /></p>
<h2 style="text-align: left;"><span class="ez-toc-section" id="i-5">使用行为树</span></h2>
<p style="text-align: left;">在程序端，需要指定上面提及的导出目录和文件格式，以便程序运行时能正常加载这些导出后的行为树，如下代码所示：</p>
<pre>behaviac::Workspace::GetInstance()-&gt;SetFilePath("../tutorials/tutorial_0/cpp/exported");

behaviac::Workspace::GetInstance()-&gt;SetFileFormat(behaviac::Workspace::EFF_xml);
</pre>
<p>然后，调用相应的加载接口，就可以加载所需的行为树了，如下代码所示：</p>
<pre>FirstAgent* g_FirstAgent = behaviac::Agent::Create&lt;FirstAgent&gt;();

g_FirstAgent-&gt;btload("FirstBT");

g_FirstAgent-&gt;btsetcurrent("FirstBT");</pre>
<p>加载完行为树，Agent实例就可以执行设置的当前行为树了，如下代码所示：</p>
<pre>g_FirstAgent-&gt;btexec();</pre>
<p>此外，在“行为树导出位置”目录下的meta文件夹包含了*.meta.xml文件，该文件内含有Agent子类的自定义属性，可以用来做Agent子类新增（自定义）成员属性的热更新。</p>
]]></content:encoded>
					
					<wfw:commentRss>/version_desc/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>编辑器的安装</title>
		<link>/tutorial1_install/</link>
					<comments>/tutorial1_install/#respond</comments>
		
		<dc:creator><![CDATA[admin]]></dc:creator>
		<pubDate>Fri, 13 May 2016 02:17:21 +0000</pubDate>
				<category><![CDATA[3.5]]></category>
		<category><![CDATA[上手]]></category>
		<category><![CDATA[安装]]></category>
		<category><![CDATA[编辑器]]></category>
		<guid isPermaLink="false">/?p=267</guid>

					<description><![CDATA[首先从下载页面下载编辑器 可以查看目录结构 安装 安装behaviac套件的系统配置需求如下所示： 最低配置： 硬件环境： CPU：Intel core2 Du<a class="moretag" href="/tutorial1_install/">Read More...</a>]]></description>
										<content:encoded><![CDATA[<p><a href="/language/zh/behaviac%E7%89%88%E6%9C%AC%E4%B8%8B%E8%BD%BD/">首先从下载页面下载编辑器</a></p>
<p><a href="/language/zh/directory/">可以查看目录结构</a></p>
<h2 id="section">安装</h2>
<p>安装behaviac套件的系统配置需求如下所示：</p>
<h3 id="section-1">最低配置：</h3>
<p>硬件环境：</p>
<p>CPU：Intel core2 Duo 2.0G或同等配置</p>
<p>内存：2GB以上</p>
<p>显卡：nvidia 6600GT或同等配置</p>
<p>软件环境：</p>
<p>操作系统：Windows XP/Vista/7/8</p>
<p>屏幕分辨率：1024*768</p>
<h3 id="section-2">推荐配置：</h3>
<p>硬件环境：</p>
<p>CPU：Intel I5 2.93G或更高配置</p>
<p>内存：4GB以上</p>
<p>显卡：nvidia GTS450或更高配置</p>
<p>软件环境：</p>
<p>操作系统：Windows 7/8</p>
<p>屏幕分辨率：1680*1050</p>
<p>运行BehaviacSetup_***.exe安装包文件，选择安装路径（推荐直接使用默认路径），安装behaviac相关套件。</p>
<p>可能需要下载安装<a href="https://support.microsoft.com/en-us/kb/2977003">Microsoft Visual C++ 运行库</a>。<br />
及<a href="https://www.microsoft.com/en-US/download/details.aspx?id=21">.net</a>。</p>
<p>安装完成后，会在桌面生成编辑器的快捷方式，如下图所示：</p>
<p><img src="/img/tutorials/tutorial1/designerIcon.png" alt="" /></p>
<p>图1 安装后桌面的编辑器图标</p>
<p>另外，在系统的“开始”菜单中生成了一些游戏demo和文档的菜单项。其中，BattleCityDemo是采用Unity引擎实现的小游戏（C#版），LaunchCocosGame是采用Cocos引擎实现的小游戏（C++版），LaunchSDLDemo是采用SDL库实现的小游戏（C++版），如下图所示：</p>
<p><img src="/img/tutorials/tutorial1/startmenu.png" alt="" /></p>
<p>图2 开始菜单中demo和文档菜单项</p>
]]></content:encoded>
					
					<wfw:commentRss>/tutorial1_install/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>编辑器的使用</title>
		<link>/tutorial2_usage/</link>
					<comments>/tutorial2_usage/#comments</comments>
		
		<dc:creator><![CDATA[admin]]></dc:creator>
		<pubDate>Fri, 13 May 2016 02:18:49 +0000</pubDate>
				<category><![CDATA[3.5]]></category>
		<category><![CDATA[上手]]></category>
		<category><![CDATA[编辑器]]></category>
		<guid isPermaLink="false">/?p=269</guid>

					<description><![CDATA[1 概述 behaviac中间件是我们对行为树、有限状态机等AI范式的一种整合实现方案，主要包括编辑器（Designer）和运行时库（Runtime）两大部分。<a class="moretag" href="/tutorial2_usage/">Read More...</a>]]></description>
										<content:encoded><![CDATA[<h2 id="section"><span class="ez-toc-section" id="1">1 概述</span></h2>
<p>behaviac中间件是我们对行为树、有限状态机等AI范式的一种整合实现方案，主要包括编辑器（Designer）和运行时库（Runtime）两大部分。其中，编辑器用于编辑、导出类型信息，也用于编辑、导出和调试行为树；运行时库也可导出类型信息，主要用于解释和执行编辑器导出的行为树，运行时库需要整合到自己的游戏项目中去。</p>
<p>编辑器和运行时之间通过类型信息（Meta）进行交互，注意类型信息流动的双向箭头，表示编辑器和运行时库双方都可以导出类型信息，如下图所示：</p>
<p><img src="/img/overview/meta.png" alt="" /></p>
<p>图1 基于类型信息的编辑器和运行时端的交互</p>
<p>编辑器只能运行在Windows平台上，运行时库支持C++和C#语言两个版本，对Unity引擎原生支持C#，运行时库目前支持所有主流平台，包括Windows/Linux/Android/iOS等。</p>
<p>该组件的使用场景，支持但不限于游戏中的逻辑、角色的人工智能、动画的控制等方面。</p>
<h2 id="section-1"><span class="ez-toc-section" id="2">2 编辑器的使用</span></h2>
<h3 id="section-2"><span class="ez-toc-section" id="21">2.1 基本介绍</span></h3>
<p>编辑器首次打开后为会根据操作系统的语言环境配置自动设置为中文版或英文版的界面，若需更改语言显示，可以依次选择菜单项“文件（File）”-&gt;“设置（Settings）”，在弹出的设置对话框中，选择需要的“语言（Language）”并点击“确认（OK）”后，退出并重新打开编辑器，则转为需要语言的界面。<br />
编辑器主要分为几个部分：菜单和工具栏、行为树文件区、节点区、主视口和属性表等，如下图所示：</p>
<p><img src="/img/tutorials/tutorial2/designerMainWindow.png" alt="" /></p>
<p>图2.1 编辑器主界面</p>
<ul>
<li>菜单和工具栏：主要有新建/打开工作区、新建/保存/导出/关闭行为树文件、设置、退出、帮助等菜单项或按键。</li>
<li>行为树文件区：列出了当前打开的工作区里面的所有行为树文件，双击某个行为树文件节点可以打开该文件。</li>
<li>节点区：给出了behaviac组件支持的所有行为树节点类型，在编辑行为树的时候，可以通过鼠标拖拽添加到主视口的行为树上去。</li>
<li>主视口：显示了当前打开的行为树图形，可以打开多个行为树，分页显示。</li>
<li>属性表：在主视口中点击选择某个节点后，属性表会更新显示当前选中节点的所有属性，可以编辑各个属性。</li>
</ul>
<p>所有窗口的停靠位置均可根据个人喜好，通过鼠标在窗口边框的拖拽重新布局。编辑器中所有的按钮均可将鼠标停在上面查看其tips，以便查知其功能。编辑器中鼠标、键盘的按键用法介绍，请查看菜单中的“帮助（Help）”-&gt;“起始页（StartPage）”。</p>
<p>编辑器分为三种操作模式：<br />
&#8211; 编辑模式：这是常规模式，编辑器启动后默认进入该模式，主要用于为游戏项目编辑所需的类型信息和行为树。<br />
&#8211; 连接模式：这是编辑器连接上游戏之后进入的模式，此时不能编辑行为树本身，只能用于观察行为树的高亮执行路径、设置断点等调试相关的操作。<br />
&#8211; 分析模式：这是离线模式，在断开游戏时保存了连接过程中的所有消息，在该模式可以模拟连接模式游戏端发送过来的消息，进行离线分析行为树的执行情况。</p>
<h3 id="section-3"><span class="ez-toc-section" id="22">2.2 操作说明</span></h3>
<h4 id="section-4"><span class="ez-toc-section" id="221">2.2.1 新建工作区</span></h4>
<p>首次使用编辑器，需要为自己的项目创建一个工作区：</p>
<ul>
<li>点击菜单“文件”-&gt;“新建工作区”，弹出新建工作区对话框，如下图所示。</li>
</ul>
<p><img src="/img/tutorials/tutorial2/newWorkspace.png" alt="" /></p>
<p>图2.2.1 新建工作区</p>
<ul>
<li>依次设置工作区的名字、位置（即工作区的保存路径）、源位置（即原始行为树的保存路径）、导出位置（即运行时库所需行为树的导出路径）和元数据位置（即运行时库导出的类型信息文件路径）。</li>
<li>源位置是存放编辑器创建的行为树的位置。导出位置是存放导出的行为树的位置。源位置和导出位置缺省情况下位于工作区所在的目录内：behaviors和exported。</li>
<li>元数据位置、源位置和导出位置需要和工作区文件必须位于同一个盘符下（如果位于不同的盘符下，调试的时候会有问题）。缺省情况下，它们位于同一个顶级目录下。</li>
</ul>
<h4 id="section-5"><span class="ez-toc-section" id="222">2.2.2 打开工作区</span></h4>
<p>点击菜单“文件”-&gt;“打开工作区”，选择保存在磁盘上的*.workspace.xml文件。<br />
在安装路径下有提供的例子供参考，例如默认安装路径下的“C:\Program Files (x86)\behaviac\integration\BattleCityDemo\Assets\BTWorkspace\BattleCity.workspace.xml”，或者从菜单中的“文件”-&gt;“最近打开的工作区”列表中选择最近打开过的工作区。<br />
behaviac组件提供了C++和C#两种编程语言的单元测试以及游戏Demo，可以通过编辑器中的菜单项“帮助”-&gt;“控制说明” 进入，然后点击快速打开所需的单元测试或游戏Demo所用到的工作区，如下图所示：</p>
<p><img src="/img/tutorials/tutorial2/demoUnittest.png" alt="" /></p>
<p>图2.2.2 快速打开单元测试和游戏Demo的工作区</p>
<h4 id="section-6"><span class="ez-toc-section" id="223">2.2.3 编辑工作区</span></h4>
<p>点击菜单“文件”-&gt;“编辑工作区”，可以修改该工作区的设置（名字、元数据位置、源位置、导出位置等），如下图所示：</p>
<p><img src="/img/tutorials/tutorial2/editWorkspace.png" alt="" /></p>
<p>图2.2.3 编辑工作区</p>
<h4 id="section-7"><span class="ez-toc-section" id="224">2.2.4 新建并编辑行为树文件</span></h4>
<ul>
<li>在打开的工作区中，从工具栏里面点击“新建行为树”按钮或者通过菜单中“文件”-&gt;“新建行为树”项，创建一个行为树文件。</li>
<li>在主视口中，为新建的行为树根节点选择设置其“Agent类型”。</li>
<li>在“节点区”中用鼠标左键选择并拖拽一些节点到主视口中来构建需要的行为树，并设置每个节点的属性。每种节点的具体用法请参考菜单项“帮助”-&gt;“节点介绍”。</li>
<li>编辑过程中，支持Undo/Redo、保存等文件操作，鼠标、键盘的按键用法请对照菜单项“帮助”-&gt;“控制说明”。</li>
</ul>
<h4 id="section-8"><span class="ez-toc-section" id="225">2.2.5 打开行为树文件</span></h4>
<p>如图2.1所示，在“行为树文件区”中，双击某个行为树文件节点就可以在主视口中打开该文件。</p>
<h4 id="section-9"><span class="ez-toc-section" id="226">2.2.6 导出行为树文件</span></h4>
<ul>
<li>编辑完行为树之后，可以通过菜单项“文件”-&gt;“导出行为树”（或者快捷键Ctrl+T）导出当前打开的行为树文件。</li>
<li>通过菜单项“文件”-&gt;“导出全部”项（或者快捷键Ctrl+Shift+T）导出工作区中的所有行为树文件。</li>
<li>目前支持4种文件格式的导出，即XML、BSON、C++和C#，如下图所示：</li>
</ul>
<p><img src="/img/tutorials/tutorial2/exportBehaviors.png" alt="" /></p>
<p>图2.2.6.1 导出行为树</p>
<ul>
<li>对于C++/C#格式的导出，还可以设置导出的文件名和位置。点击图2.2.6.1中“导出设置”-&gt;“设置”列的“…”按钮，可以弹出“C++/C#导出设置”对话框。对于C++文件，还需添加游戏项目中Agent子类的.h头文件，如图2.2.6.2所示。<br />
导出后，将在指定的导出路径下生成behaviac_generated目录，里面又包含了behaviors和types两个子目录，需要将这两个子目录里面的所有文件全部包含到自己的项目中去。<br />
注意：对于导出C++文件，如果不添加Agent子类的.h头文件，那么需要注意将behaviors和types两个子目录中生成的头文件放在项目代码include “yourAgent.h”之后，以确保Agent子类先被包含进来，否则会有编译错误。</li>
</ul>
<p><img src="/img/tutorials/tutorial2/exportSettings.png" alt="" /></p>
<p>图2.2.6.2 C++/C#的导出设置</p>
<ul>
<li>图2.2.6.2中的选项“是否导出统一文件”用来表示导出的C++或者C#文件是否为一个统一的大文件还是若干个小文件，其中每个小文件对应一个行为树。</li>
<li>运行时库支持行为树导出文件的热加载，如果在编辑器修改完行为树之后，重新导出，游戏端会自动重新加载所用到的行为树，无需重启游戏。</li>
</ul>
<h4 id="section-10"><span class="ez-toc-section" id="227_Permalink">2.2.7 连接游戏<a class="header-link" title="Permalink" href="/docs/zh/tutorials/tutorial2_usage/#section-10"><span class="sr-only">Permalink</span><i class="fa fa-link"></i></a></span></h4>
<ul>
<li>从开始菜单中，启动小游戏BattleCityDemo，如下图所示：</li>
</ul>
<p><img src="/img/tutorials/tutorial2/battleCityDemo.png" alt="" /></p>
<p>图2.2.7.1 Battle City Demo</p>
<ul>
<li>点击游戏主界面右上角的“Show Levels”按钮，可以切换不同的关卡，如下图所示：</li>
</ul>
<p><img src="/img/tutorials/tutorial2/selectGameLevel.png" alt="" /></p>
<p>图2.2.7.2 选择关卡</p>
<ul>
<li>点击游戏主界面左下角的“Launch Designer”按钮，启动编辑器，编辑器会自动打开BattleCityDemo的工作区，并打开游戏当前关卡所用到的行为树（如果没有切换其他关卡，默认打开的是Tank_Fire_Random行为树文件）。</li>
<li>点击编辑器工具栏中的“连接游戏”按钮或通过菜单项“文件”-&gt;“连接游戏”（或通过快捷键Ctrl+L），开始连接游戏。默认的，一般无需更改服务器IP和端口号，如图2.2.7.3所示。<br />
注意：有时候可能会发现连不上游戏，很可能是原来的端口号已被占用，可以尝试在运行时端的端口号60636改为其他值，然后相应的修改图2.2.7.3中的端口号，尝试重新连接游戏。</li>
</ul>
<p><img src="/img/tutorials/tutorial2/connectGame.png" alt="" /></p>
<p>图2.2.7.3 连接游戏</p>
<ul>
<li>连接成功后，编辑器从编辑模式切换到连接模式，如下图所示：</li>
</ul>
<p><img src="/img/tutorials/tutorial2/connectMode.png" alt="" /></p>
<p>图2.2.7.4 连接模式</p>
<ul>
<li>时间轴（Timeline）：默认位于编辑器最上方，用于表示当前帧相关的信息。</li>
<li>实例列表：列出了游戏中所有的对象实例，双击实例节点后可以开始跟踪调试选中的实例，右键单击实例节点弹出如下菜单，如图2.2.7.5所示。其中“调试”跟双击节点的作用一致，开始跟踪选中的实例，主视口会高亮显示行为树的执行路径；“查看属性”用于跟踪当前选中实例的所有属性的变化，编辑器会弹出实例的属性列表。</li>
</ul>
<p><img src="/img/tutorials/tutorial2/debugInstance.png" alt="" /></p>
<p>图2.2.7.5 实例右键菜单</p>
<ul>
<li>主视口：高亮的节点边框和连接线段，表示程序当前执行的路径情况。双击树中节点的左右两侧，可以设置节点的断点（左侧表示进入断点，右侧表示退出断点），用于游戏执行时在断点位置停下来，游戏断下来后按F5键后继续运行。</li>
<li>输出窗口：列出了收到的全部消息，用于调试时查看记录。</li>
<li>Agent的属性：可以显示当前Agent属性的变化。</li>
<li>断点：通过菜单项“视图”-&gt;“断点”打开断点窗口后，可以查看、管理当前工作区中的所有断点。</li>
</ul>
<h4 id="section-11"><span class="ez-toc-section" id="228">2.2.8 分析导出数据</span></h4>
<ul>
<li>点击菜单或工具栏中的“断开游戏”按键，断开与游戏端的连接，回到编辑模式。</li>
<li>默认弹出如下对话框，保存之前连接模式下调试的相关数据。</li>
</ul>
<p><img src="/img/tutorials/tutorial2/saveDump.png" alt="" /></p>
<p>图2.2.8.1 保存dump数据</p>
<ul>
<li>点击菜单或工具栏中的“分析导出文件”按键，选择打开上一步导出的数据文件，编辑器进入到分析模式。</li>
<li>分析模式的界面布局跟连接模式类似，但是可以通过时间轴里面的播放按钮开始重现连接过程中的情况，如下图所示：</li>
</ul>
<p><img src="/img/tutorials/tutorial2/analyzeDump.png" alt="" /></p>
<p>图2.2.8.2 分析dump数据</p>
<ul>
<li>要退出分析模式，可以点击菜单或工具栏中的“终止分析”按键，回到编辑模式。</li>
</ul>
<p>需要指出的是，分析模式下还可以直接下载_behaviac_$_.log文件进行离线分析。_behaviac_$_.log文件一般生成在exe所在的目录。对于unity，_behaviac_$_.log文件生成在Assets所在的目录中。</p>
<h4 id="section-12"><span class="ez-toc-section" id="229">2.2.9 其他</span></h4>
<p>除了BattleCityDemo小游戏（基于Unity引擎实现，运行时库为C#版）之外，还有LaunchCocosGame（基于Cocos引擎实现，运行时库为C++版）和LaunchSDLDemo小游戏（基于SDL库实现，运行时库为C++版）。<br />
如图2.2所示，从操作系统的开始菜单中启动LaunchCocosGame或LaunchSDLDemo小游戏后，游戏跟编辑器的连接需要单独启动编辑器，然后再点击编辑器工具栏中的“连接游戏”按钮或通过菜单项“文件”-&gt;“连接游戏”（快捷键Ctrl+L），开始连接游戏。连接后，执行情况跟BattleCityDemo小游戏类似。</p>
<div class="section-nav"></div>
]]></content:encoded>
					
					<wfw:commentRss>/tutorial2_usage/feed/</wfw:commentRss>
			<slash:comments>3</slash:comments>
		
		
			</item>
		<item>
		<title>C++运行时端的使用上手</title>
		<link>/tutorial14_cpp_workflow/</link>
					<comments>/tutorial14_cpp_workflow/#comments</comments>
		
		<dc:creator><![CDATA[admin]]></dc:creator>
		<pubDate>Fri, 13 May 2016 02:21:24 +0000</pubDate>
				<category><![CDATA[3.5]]></category>
		<category><![CDATA[上手]]></category>
		<category><![CDATA[C++]]></category>
		<category><![CDATA[运行时]]></category>
		<guid isPermaLink="false">/?p=273</guid>

					<description><![CDATA[运行时（游戏）端使用行为树之前，需要确保行为树文件已经成功导出。 如何注册和导出类型信息请参考C++类型信息的注册和导出，如何导出行为树请参考导出和使用XML/<a class="moretag" href="/tutorial14_cpp_workflow/">Read More...</a>]]></description>
										<content:encoded><![CDATA[<p id="c">运行时（游戏）端使用行为树之前，需要确保行为树文件已经成功导出。</p>
<p>如何注册和导出类型信息请参考<a href="/docs/zh/tutorials/tutorial3_1_meta_cpp_register/">C++类型信息的注册和导出</a>，如何导出行为树请参考<a href="/docs/zh/tutorials/tutorial4_1_export_xml_bson/">导出和使用XML/BSON行为树</a>。</p>
<p>通过编辑器导出行为树文件后，运行时端的执行主要分为三个部分：</p>
<ul>
<li>初始化</li>
<li>循环更新</li>
<li>清理</li>
</ul>
<h3 id="section"><span class="ez-toc-section" id="1">1 初始化</span></h3>
<p>在游戏的初始化函数中，添加初始化behaviac组件所需的功能，例如注册Agent子类信息、设置行为树文件的加载路径和文件格式、创建Agent子类的实例、加载行为树并设置当前所需执行的行为树等。</p>
<p>如下代码所示：</p>
<div class="highlighter-rouge">
<pre class="highlight"><code><span class="n">bool</span> <span class="nf">InitBehavic</span><span class="p">(</span><span class="n">behaviac</span><span class="o">::</span><span class="n">Workspace</span><span class="o">::</span><span class="n">EFileFormat</span> <span class="n">ff</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">behaviac</span><span class="o">::</span><span class="n">Config</span><span class="o">::</span><span class="n">SetSocketBlocking</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>
    <span class="n">behaviac</span><span class="o">::</span><span class="n">Config</span><span class="o">::</span><span class="n">SetSocketPort</span><span class="p">(</span><span class="mi">8081</span><span class="p">);</span>

    <span class="n">behaviac</span><span class="o">::</span><span class="n">Agent</span><span class="o">::</span><span class="n">Register</span><span class="o">&lt;</span><span class="n">CBTPlayer</span><span class="o">&gt;</span><span class="p">();</span>

    <span class="n">behaviac</span><span class="o">::</span><span class="n">Workspace</span><span class="o">::</span><span class="n">GetInstance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">SetFilePath</span><span class="p">(</span><span class="s">"../test/demo_running/behaviac/exported"</span><span class="p">);</span>
    <span class="n">behaviac</span><span class="o">::</span><span class="n">Workspace</span><span class="o">::</span><span class="n">GetInstance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">SetFileFormat</span><span class="p">(</span><span class="n">ff</span><span class="p">);</span>

    <span class="n">behaviac</span><span class="o">::</span><span class="n">Workspace</span><span class="o">::</span><span class="n">GetInstance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">ExportMetas</span><span class="p">(</span><span class="s">"../test/demo_running/behaviac/demo_running.xml"</span><span class="p">);</span>

    <span class="c1">//behaviac::Agent::SetIdMask(kIdMask_Wolrd | kIdMask_Opponent);
</span>    <span class="n">behaviac</span><span class="o">::</span><span class="n">Workspace</span><span class="o">::</span><span class="n">GetInstance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">SetDeltaFrames</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">bool</span> <span class="nf">InitPlayer</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">pszTreeName</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">g_player</span> <span class="o">=</span> <span class="n">behaviac</span><span class="o">::</span><span class="n">Agent</span><span class="o">::</span><span class="n">Create</span><span class="o">&lt;</span><span class="n">CBTPlayer</span><span class="o">&gt;</span><span class="p">();</span>

    <span class="n">bool</span> <span class="n">bRet</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="n">bRet</span> <span class="o">=</span> <span class="n">g_player</span><span class="o">-&gt;</span><span class="n">btload</span><span class="p">(</span><span class="n">pszTreeName</span><span class="p">);</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">bRet</span><span class="p">);</span>

    <span class="n">g_player</span><span class="o">-&gt;</span><span class="n">btsetcurrent</span><span class="p">(</span><span class="n">pszTreeName</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">bRet</span><span class="p">;</span>
<span class="p">}</span>

</code></pre>
</div>
<div class="note info">
<h5><span class="ez-toc-section" id="i">关于文件路径的说明</span></h5>
</div>
<ul>
<li>Workspace::SetFilePath指定的是编辑器中Workspace的导出路径，可以是绝对路径。当指定的是相对路径的时候，相对的是当前<strong>工作路径</strong>（一般都是运行程序所在目录）。</li>
<li>Agent::btload使用的文件名是相对于Workspace::SetFilePath指定的路径，没有扩展名，可以有目录结构的层次化文件名，如“node_test/selector_loop_ut_7”。在编辑器中打开某个行为树后，右键文件页选取“复制文件名”获取。</li>
</ul>
<p><img src="/img/tutorials/tutorial14/copy_filepath.png" alt="copy_filepath" /></p>
<ul>
<li>例如：
<ul>
<li>如果运行程序所在目录（或者VS里指定的工作路径$(TargetDir)）是”D:\Test\bin”</li>
<li>Workspace::SetFilePath指定的相对路径是“../behaviac/workspace/exported”</li>
<li>btload指定是“node_test/selector_loop_ut_7”</li>
<li>则workspace的导出路径实际是“D:/Test/behaviac/workspace/exported”，<br />
而相应的导出行为树文件是“D:/Test/behaviac/workspace/exported/node_test/selector_loop_ut_7.xml”或<br />
“D:/Test/behaviac/workspace/exported/node_test/selector_loop_ut_7.bson.bytes”。</li>
<li>具体是xml或bson则由Workspace::SetFileFormat确定。</li>
<li>当指定格式是cpp或c#的时候，导出的行为树是cpp或c#源码，已经编译构建进可执行程序，Agent::btload指定的文件名（跟xml的用法一样，无需修改btload的参数）只是用来标识该行为树的，从而代码可以据此创建相应的行为树，不像xml或bson格式的时候需要加载数据文件。</li>
</ul>
</li>
<li>如果Agent::btload加载失败，请注意检查当前路径，Workspace::SetFilePath设定的导出路径，以及Agent::btload指定的文件标识。还可以在当前路径里检查log文件<code class="highlighter-rouge">_behaviac_$_$_.log</code></li>
</ul>
<h3 id="section-1"><span class="ez-toc-section" id="2">2 循环更新</span></h3>
<p>在游戏的主循环中，添加执行Agent实例的行为树相关代码，也即通过调用Agent类的接口btexec()或Workspace类的接口Update()来执行行为树。</p>
<p>这两种执行方式的区别，请参考<a href="/docs/zh/tutorials/tutorial13_updateloop/">更新流程</a>。</p>
<p>如下代码样例所示：</p>
<div class="highlighter-rouge">
<pre class="highlight"><code>
<span class="kt">void</span> <span class="nf">UpdateLoop</span><span class="p">()</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span>  <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">frames</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">behaviac</span><span class="o">::</span><span class="n">EBTStatus</span> <span class="n">status</span> <span class="o">=</span> <span class="n">behaviac</span><span class="o">::</span><span class="n">BT_RUNNING</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="n">behaviac</span><span class="o">::</span><span class="n">BT_RUNNING</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"frame "</span> <span class="o">&lt;&lt;</span> <span class="o">++</span><span class="n">frames</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">g_player</span><span class="o">-&gt;</span><span class="n">btexec</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>

</code></pre>
</div>
<h3 id="section-2"><span class="ez-toc-section" id="3">3 清理</span></h3>
<p>最后的清理过程，包括销毁Agent子类的实例，以及反注册Agent子类信息等。</p>
<p>如下代码样例所示：</p>
<div class="highlighter-rouge">
<pre class="highlight"><code>
<span class="kt">void</span> <span class="nf">CleanupPlayer</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">behaviac</span><span class="o">::</span><span class="n">Agent</span><span class="o">::</span><span class="n">Destroy</span><span class="p">(</span><span class="n">g_player</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">CleanupBehaviac</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">behaviac</span><span class="o">::</span><span class="n">Agent</span><span class="o">::</span><span class="n">UnRegister</span><span class="o">&lt;</span><span class="n">CBTPlayer</span><span class="o">&gt;</span><span class="p">();</span>

	<span class="n">behaviac</span><span class="o">::</span><span class="n">Workspace</span><span class="o">::</span><span class="n">GetInstance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">Cleanup</span><span class="p">();</span>
<span class="p">}</span>

</code></pre>
</div>
<p>以上步骤的完整代码，请参考<a href="https://github.com/Tencent/behaviac/blob/master/test/demo_running/demo_running.cpp">demo_running.cpp</a>文件。</p>
]]></content:encoded>
					
					<wfw:commentRss>/tutorial14_cpp_workflow/feed/</wfw:commentRss>
			<slash:comments>2</slash:comments>
		
		
			</item>
		<item>
		<title>导出和使用C++行为树</title>
		<link>/tutorial4_2_export_cpp/</link>
					<comments>/tutorial4_2_export_cpp/#respond</comments>
		
		<dc:creator><![CDATA[admin]]></dc:creator>
		<pubDate>Fri, 13 May 2016 02:29:06 +0000</pubDate>
				<category><![CDATA[3.5]]></category>
		<category><![CDATA[上手]]></category>
		<category><![CDATA[C++]]></category>
		<category><![CDATA[编辑器]]></category>
		<guid isPermaLink="false">/?p=284</guid>

					<description><![CDATA[在“导出行为树”对话框中，选择“C++ Behavior Exporter”，如下图所示： 点击上图中右侧的“…”设置按钮，在弹出的“C++导出设置”对话框中设<a class="moretag" href="/tutorial4_2_export_cpp/">Read More...</a>]]></description>
										<content:encoded><![CDATA[<ul>
<li>在“导出行为树”对话框中，选择“C++ Behavior Exporter”，如下图所示：</li>
</ul>
<p><img class="aligncenter" src="/img/tutorials/tutorial4/exportCpp.png" alt="" /></p>
<ul>
<li>点击上图中右侧的“…”设置按钮，在弹出的“C++导出设置”对话框中设置生成文件所在的位置，并可以添加项目中游戏类（从Agent类派生而来）所在的.h头文件，添加的头文件将会被包含在生成的.cpp文件中，如下图所示：</li>
</ul>
<p><img class="aligncenter" src="/img/tutorials/tutorial4/cppExportSettings.png" alt="" /></p>
<ul>
<li>回到“导出行为树”对话框，点击“导出”按钮，开始导出<code class="highlighter-rouge">C++</code>文件。在指定的导出位置（默认为当前工作区的导出路径）会自动生成一个名为<code class="highlighter-rouge">behaviac_generated</code>的文件夹，里面生成了<code class="highlighter-rouge">behaviors</code>和<code class="highlighter-rouge">types</code>两个子文件夹，如图3所示：</li>
<li><code class="highlighter-rouge">behaviors</code>文件夹中含有<code class="highlighter-rouge">generated_behaviors.h</code>及其他单个的行为树<code class="highlighter-rouge">.inl</code>文件（如果没有勾选“导出统一文件？”，则对每一棵行为树都会生成独立的<code class="highlighter-rouge">.inl</code>文件，这些.inl文件会自动include在<code class="highlighter-rouge">generated_behaviors.h</code>文件中，无需在自己的项目中再include这些<code class="highlighter-rouge">.inl</code>文件，只需要include这个<code class="highlighter-rouge">generated_behaviors.h</code>文件即可）。</li>
<li><code class="highlighter-rouge">types</code>文件夹中含有<code class="highlighter-rouge">agentproperties.h</code>（为Agent类自定义的属性和方法，会扩展在该文件中）、<code class="highlighter-rouge">customizedtypes.h/customizedtypes.cpp</code>（自定义的枚举和结构体类型，会生成在这两个文件中）以及其他自定义<code class="highlighter-rouge">Agent</code>子类的文件（这些文件是为添加的<code class="highlighter-rouge">Agent</code>子类自动生成的<code class="highlighter-rouge">.h/.cpp</code>文件，需要程序员补充代码进一步实现这些<code class="highlighter-rouge">Agent</code>子类的逻辑）。</li>
</ul>
<p><img class="aligncenter" src="/img/tutorials/tutorial4/exportedCppFiles.png" alt="" /></p>
<ul>
<li>注意：这些自动生成的文件（除了上面提及的单个的行为树<code class="highlighter-rouge">.inl</code>文件之外）都需要包含到自己的游戏项目中，一起参与整个项目代码的编译和构建。</li>
<li>在项目中包含了这些自动生成的代码文件后，就可以与前面提及的<a href="/docs/zh/tutorials/tutorial4_1_export_xml_bson/">导出和使用XML/BSON行为树</a>一样的接口和方式加载使用这些C++文件，只是需要将文件格式改为<code class="highlighter-rouge">EFF_cpp</code>：</li>
</ul>
<div class="highlighter-rouge">
<pre class="highlight"><code>
<span class="n">behaviac</span><span class="o">::</span><span class="n">Workspace</span><span class="o">::</span><span class="n">GetInstance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">SetFileFormat</span><span class="p">(</span><span class="n">behaviac</span><span class="o">::</span><span class="n">Workspace</span><span class="o">::</span><span class="n">EFF_cpp</span><span class="p">);</span>

</code></pre>
</div>
<div class="section-nav"></div>
]]></content:encoded>
					
					<wfw:commentRss>/tutorial4_2_export_cpp/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>C++运行时端中元信息的注册和导出</title>
		<link>/tutorial3_1_meta_cpp_register/</link>
					<comments>/tutorial3_1_meta_cpp_register/#comments</comments>
		
		<dc:creator><![CDATA[admin]]></dc:creator>
		<pubDate>Fri, 13 May 2016 02:23:51 +0000</pubDate>
				<category><![CDATA[3.5]]></category>
		<category><![CDATA[上手]]></category>
		<category><![CDATA[C++]]></category>
		<category><![CDATA[运行时]]></category>
		<guid isPermaLink="false">/?p=276</guid>

					<description><![CDATA[behaviac组件的基本运作机制就是在运行时端（C++）和编辑器通过元信息进行交互，如图1所示。其中，元信息里面包含了类自身的描述、属性、方法及类的实例等。 <a class="moretag" href="/tutorial3_1_meta_cpp_register/">Read More...</a>]]></description>
										<content:encoded><![CDATA[<p id="c">behaviac组件的基本运作机制就是在运行时端（C++）和编辑器通过元信息进行交互，如图1所示。其中，元信息里面包含了类自身的描述、属性、方法及类的实例等。</p>
<p><img class="aligncenter" src="/img/overview/meta.png" alt="" /></p>
<p style="text-align: center;">图1 基于元信息的编辑器和运行时端的交互</p>
<p>在运行时端，也即游戏代码端，通过注册（C++通过宏的方式）并导出供行为树引擎和编辑器使用的XML元信息。运行时端主要是由程序员编写Agent的子类及其属性和方法，然后调用相关接口将这些元信息导出，就可以在编辑器中对这些元信息进行使用。</p>
<p>在编辑器中也可以创建和编辑元信息。在项目开始初期，也就是程序员还没把代码写出来之前，策划就可以自己手动的创建一些Agent子类、属性和方法等元信息。这样可以加速游戏原型的创建，也就是策划不用等程序员，就可以进行游戏原型的编辑。</p>
<p>整个工作流程主要分为以下几个步骤：</p>
<h3 id="section">1 注册元信息</h3>
<ul>
<li>在.h文件中，根据项目需要按以下步骤编写自己的游戏类：
<ul>
<li>首先需要包含头文件#include “behaviac/behaviac.h”。</li>
<li>该类需要从behaviac::Agent基类继承。</li>
<li>首先用宏DECLARE_BEHAVIAC_AGENT声明该类及其父类，用于行为树引擎内部的反射系统所需的类型信息。</li>
<li>为该类添加必要的属性和方法等。</li>
</ul>
</li>
</ul>
<p>如下代码样例所示：</p>
<div class="highlighter-rouge">
<pre class="highlight"><code>
<span class="cp">#include "behaviac/behaviac.h"
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">behaviac</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">CBTPlayer</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Agent</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">DECLARE_BEHAVIAC_AGENT</span><span class="p">(</span><span class="n">CBTPlayer</span><span class="p">,</span> <span class="n">Agent</span><span class="p">);</span>

    <span class="n">CBTPlayer</span><span class="p">();</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">CBTPlayer</span><span class="p">();</span>

    <span class="kt">time_t</span> <span class="n">GetCurTime</span><span class="p">();</span>
    <span class="n">bool</span> <span class="n">Condition</span><span class="p">();</span>
    <span class="n">behaviac</span><span class="o">::</span><span class="n">EBTStatus</span> <span class="n">Action1</span><span class="p">();</span>
    <span class="n">EBTStatus</span> <span class="n">Action3</span><span class="p">();</span>

<span class="k">private</span><span class="o">:</span>
    <span class="kt">int</span>                 <span class="n">m_iX</span><span class="p">;</span>
    <span class="kt">int</span>                 <span class="n">m_iY</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">int</span>        <span class="n">m_iBaseSpeed</span><span class="p">;</span>
    <span class="kt">int</span>					<span class="n">m_Frames</span><span class="p">;</span>
<span class="p">};</span>

</code></pre>
</div>
<ul>
<li>在.cpp文件中，通过一系列宏来注册该类自身的描述及其属性与方法：
<ul>
<li>宏BEGIN_PROPERTIES_DESCRIPTION和END_PROPERTIES_DESCRIPTION表示类型信息注册的开始和结束。</li>
<li>宏CLASS_DISPLAYNAME和CLASS_DESC用于注册类自身的显示名和描述。</li>
<li>宏REGISTER_PROPERTY用于注册类的属性，可以通过.DISPLAYNAME的追加方式为属性添加显示名，通过.DESC的追加方式为属性添加描述。</li>
<li>宏REGISTER_METHOD用于注册类的方法，可以通过.DISPLAYNAME的追加方式为方法添加显示名，通过.DESC的追加方式为方法添加描述，通过.PARAM_DISPLAY_INFO的追加方式为参数添加显示名和描述等。如果参数类型是数值类型（例如int、unsigned int、float等），.PARAM_DISPLAY _INFO还可以用来指定参数的有效范围。</li>
</ul>
</li>
</ul>
<p>如下代码样例所示：</p>
<div class="highlighter-rouge">
<pre class="highlight"><code>
<span class="n">BEGIN_PROPERTIES_DESCRIPTION</span><span class="p">(</span><span class="n">CBTPlayer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">REGISTER_PROPERTY</span><span class="p">(</span><span class="n">m_iBaseSpeed</span><span class="p">);</span>

	<span class="n">REGISTER_METHOD</span><span class="p">(</span><span class="n">Condition</span><span class="p">);</span>
	<span class="n">REGISTER_METHOD</span><span class="p">(</span><span class="n">Action1</span><span class="p">);</span>
	<span class="n">REGISTER_METHOD</span><span class="p">(</span><span class="n">Action3</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">END_PROPERTIES_DESCRIPTION</span><span class="p">()</span>

</code></pre>
</div>
<h3 id="section-1">2 导出元信息</h3>
<p>注册完类信息之后，按以下步骤导出元数据文件：</p>
<ul>
<li>在初始化函数里，添加Agent::Register&lt;***&gt;()用于注册类信息到引擎库中。</li>
<li>通过Agent::RegisterInstanceName&lt;***&gt;(…)来注册类的实例名。</li>
<li>调用Workspace::GetInstance()-&gt;SetFilePath(…)设置元信息文件导出的位置。</li>
<li>调用Workspace::GetInstance()-&gt;ExportMetas(…)导出元信息文件。</li>
<li>在释放函数里，添加Agent::Unregister&lt;***&gt;()用于释放类型的注册信息。</li>
</ul>
<p>如下代码样例所示：</p>
<div class="highlighter-rouge">
<pre class="highlight"><code>
<span class="n">bool</span> <span class="nf">InitBehavic</span><span class="p">(</span><span class="n">behaviac</span><span class="o">::</span><span class="n">Workspace</span><span class="o">::</span><span class="n">EFileFormat</span> <span class="n">ff</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">behaviac</span><span class="o">::</span><span class="n">Config</span><span class="o">::</span><span class="n">SetSocketBlocking</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>
    <span class="n">behaviac</span><span class="o">::</span><span class="n">Config</span><span class="o">::</span><span class="n">SetSocketPort</span><span class="p">(</span><span class="mi">8081</span><span class="p">);</span>

    <span class="n">behaviac</span><span class="o">::</span><span class="n">Agent</span><span class="o">::</span><span class="n">Register</span><span class="o">&lt;</span><span class="n">CBTPlayer</span><span class="o">&gt;</span><span class="p">();</span>

    <span class="n">behaviac</span><span class="o">::</span><span class="n">Workspace</span><span class="o">::</span><span class="n">GetInstance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">SetFilePath</span><span class="p">(</span><span class="s">"../test/demo_running/behaviac/exported"</span><span class="p">);</span>
    <span class="n">behaviac</span><span class="o">::</span><span class="n">Workspace</span><span class="o">::</span><span class="n">GetInstance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">SetFileFormat</span><span class="p">(</span><span class="n">ff</span><span class="p">);</span>

    <span class="n">behaviac</span><span class="o">::</span><span class="n">Workspace</span><span class="o">::</span><span class="n">GetInstance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">ExportMetas</span><span class="p">(</span><span class="s">"../test/demo_running/behaviac/demo_running.xml"</span><span class="p">);</span>

    <span class="c1">//behaviac::Agent::SetIdMask(kIdMask_Wolrd | kIdMask_Opponent);
</span>    <span class="n">behaviac</span><span class="o">::</span><span class="n">Workspace</span><span class="o">::</span><span class="n">GetInstance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">SetDeltaFrames</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">CleanupBehaviac</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">behaviac</span><span class="o">::</span><span class="n">Agent</span><span class="o">::</span><span class="n">UnRegister</span><span class="o">&lt;</span><span class="n">CBTPlayer</span><span class="o">&gt;</span><span class="p">();</span>
<span class="n">    behaviac</span><span class="o">::</span><span class="n">Workspace</span><span class="o">::</span><span class="n">GetInstance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">Cleanup</span><span class="p">();</span>
<span class="p">}</span>

</code></pre>
</div>
<p>更多细节可以参考behaviac组件C++源码中附带的test/demo_running工程的<a href="https://github.com/Tencent/behaviac/blob/master/test/demo_running/demo_running.cpp">demo_running.cpp</a>文件。</p>
]]></content:encoded>
					
					<wfw:commentRss>/tutorial3_1_meta_cpp_register/feed/</wfw:commentRss>
			<slash:comments>2</slash:comments>
		
		
			</item>
		<item>
		<title>C#运行时端中元信息的注册和导出</title>
		<link>/tutorial3_2_meta_cs_register/</link>
					<comments>/tutorial3_2_meta_cs_register/#respond</comments>
		
		<dc:creator><![CDATA[admin]]></dc:creator>
		<pubDate>Fri, 13 May 2016 02:25:57 +0000</pubDate>
				<category><![CDATA[3.5]]></category>
		<category><![CDATA[unity]]></category>
		<category><![CDATA[上手]]></category>
		<category><![CDATA[运行时]]></category>
		<guid isPermaLink="false">/?p=278</guid>

					<description><![CDATA[behaviac组件的基本运作机制就是在运行时端（C#）和编辑器通过元信息进行交互，如图1所示。其中，元信息里面包含了类自身的描述、属性、方法及类的实例等。 图<a class="moretag" href="/tutorial3_2_meta_cs_register/">Read More...</a>]]></description>
										<content:encoded><![CDATA[<p id="c-">behaviac组件的基本运作机制就是在运行时端（C#）和编辑器通过元信息进行交互，如图1所示。其中，元信息里面包含了类自身的描述、属性、方法及类的实例等。</p>
<p><img class="aligncenter" src="/img/overview/meta.png" alt="" /></p>
<p style="text-align: center;">图1 基于元信息的编辑器和运行时端的交互</p>
<p>在运行时端，也即游戏代码端，通过注册（C#通过标记Attribute的方式）并导出供行为树引擎和编辑器使用的XML元信息。运行时端主要是由程序员编写Agent的子类及其属性和方法，然后调用相关接口将这些元信息导出，就可以在编辑器中对这些元信息进行使用。</p>
<p>在编辑器中也可以创建和编辑元信息。在项目开始初期，也就是程序员还没把代码写出来之前，策划就可以自己手动的创建一些Agent子类、属性和方法等元信息。这样可以加速游戏原型的创建，也就是策划不用等程序员，就可以进行游戏原型的编辑。</p>
<p>整个工作流程主要分为以下几个步骤：</p>
<h3 id="section">1 注册元信息</h3>
<p>C#中编写的游戏类从behaviac.Agent派生，并通过相关的Attribute来标记元信息：</p>
<ul>
<li>类：TypeMetaInfo</li>
<li>成员属性：MemberMetaInfo</li>
<li>成员方法：MethodMetaInfo</li>
</ul>
<p>这3个类都可以接受诸如显示名字，描述等更多参数。详细请参考代码。</p>
<p>如下代码样例所示：</p>
<figure class="highlight">
<pre><code class="language-cs" data-lang="cs"><span class="na">[behaviac.TypeMetaInfo()]</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">AgentNodeTest</span> <span class="p">:</span> <span class="n">behaviac</span><span class="p">.</span><span class="n">Agent</span>
<span class="p">{</span>
    <span class="p">[</span><span class="n">behaviac</span><span class="p">.</span><span class="nf">MemberMetaInfo</span><span class="p">()]</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">testVar_0</span> <span class="p">=</span> <span class="p">-</span><span class="m">1</span><span class="p">;</span>

    <span class="p">[</span><span class="n">behaviac</span><span class="p">.</span><span class="nf">MemberMetaInfo</span><span class="p">(</span><span class="s">"testVar_1"</span><span class="p">,</span> <span class="s">"testVar_1 property"</span><span class="p">,</span> <span class="m">100</span><span class="p">)]</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">testVar_1</span> <span class="p">=</span> <span class="p">-</span><span class="m">1</span><span class="p">;</span>

    <span class="p">[</span><span class="n">behaviac</span><span class="p">.</span><span class="nf">MemberMetaInfo</span><span class="p">()]</span>
    <span class="k">public</span> <span class="kt">float</span> <span class="n">testVar_2</span> <span class="p">=</span> <span class="p">-</span><span class="m">1.0f</span><span class="p">;</span>

    <span class="p">[</span><span class="n">behaviac</span><span class="p">.</span><span class="nf">MemberMetaInfo</span><span class="p">()]</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">waiting_timeout_interval</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>

    <span class="p">[</span><span class="n">behaviac</span><span class="p">.</span><span class="nf">MemberMetaInfo</span><span class="p">()]</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">testVar_str_0</span> <span class="p">=</span> <span class="kt">string</span><span class="p">.</span><span class="n">Empty</span><span class="p">;</span>

    <span class="k">public</span> <span class="kt">bool</span> <span class="n">m_bCanSee</span> <span class="p">=</span> <span class="k">false</span><span class="p">;</span>

    <span class="p">[</span><span class="n">behaviac</span><span class="p">.</span><span class="nf">MethodMetaInfo</span><span class="p">()]</span>
    <span class="k">public</span> <span class="k">void</span> <span class="nf">setEventVarInt</span><span class="p">(</span><span class="kt">int</span> <span class="n">var</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">event_test_var_int</span> <span class="p">=</span> <span class="n">var</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="p">[</span><span class="n">behaviac</span><span class="p">.</span><span class="nf">MethodMetaInfo</span><span class="p">()]</span>
    <span class="k">public</span> <span class="k">void</span> <span class="nf">setEventVarBool</span><span class="p">(</span><span class="kt">bool</span> <span class="n">var</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">event_test_var_bool</span> <span class="p">=</span> <span class="n">var</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre>
</figure>
<h3 id="section-1">2 导出元信息</h3>
<p>由于C#代码中已经包含了各种Attribute来描述元信息，因而导出相比C++要简单：</p>
<ul>
<li>Agent子类的实例通过Agent.RegisterInstanceName&lt;***&gt;(…)来进行注册。</li>
<li>调用Workspace.Instance.FilePath设置元信息文件导出的位置。</li>
<li>调用Workspace.Instance.ExportMetas(…)导出元信息文件。</li>
</ul>
<p>如下代码样例所示：</p>
<figure class="highlight">
<pre><code class="language-cs" data-lang="cs"><span class="k">public</span> <span class="kt">bool</span> <span class="nf">Init</span> <span class="p">()</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ms_fileSystem</span> <span class="p">==</span> <span class="k">null</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">ms_fileSystem</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">BehaviacFileManager</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="c1">//&lt; write log file
</span>    <span class="n">behaviac</span><span class="p">.</span><span class="n">Config</span><span class="p">.</span><span class="n">IsLogging</span> <span class="p">=</span> <span class="k">true</span><span class="p">;</span>
    <span class="c1">//behaviac.Config.IsSocketing = false;
</span>
    <span class="n">behaviac</span><span class="p">.</span><span class="n">Workspace</span><span class="p">.</span><span class="n">Instance</span><span class="p">.</span><span class="n">FilePath</span> <span class="p">=</span> <span class="k">this</span><span class="p">.</span><span class="n">WorkspaceExportPath</span><span class="p">;</span>
    <span class="n">behaviac</span><span class="p">.</span><span class="n">Workspace</span><span class="p">.</span><span class="n">Instance</span><span class="p">.</span><span class="n">FileFormat</span> <span class="p">=</span> <span class="n">behaviac</span><span class="p">.</span><span class="n">Workspace</span><span class="p">.</span><span class="n">EFileFormat</span><span class="p">.</span><span class="n">EFF_xml</span><span class="p">;</span>

    <span class="c1">//register names
</span>    <span class="n">behaviac</span><span class="p">.</span><span class="n">Agent</span><span class="p">.</span><span class="n">RegisterInstanceName</span><span class="p">&lt;</span><span class="n">GameLevelCommon</span><span class="p">&gt;(</span><span class="s">"GameLevel"</span><span class="p">);</span>
    <span class="n">behaviac</span><span class="p">.</span><span class="n">Workspace</span><span class="p">.</span><span class="n">Instance</span><span class="p">.</span><span class="nf">ExportMetas</span><span class="p">(</span><span class="s">"behaviac/workspace/xmlmeta/BattleCityMeta.xml"</span><span class="p">);</span>

    <span class="n">behaviac</span><span class="p">.</span><span class="n">Debug</span><span class="p">.</span><span class="nf">Log</span><span class="p">(</span><span class="s">"Behaviac meta data export over."</span><span class="p">);</span>
    <span class="n">behaviac</span><span class="p">.</span><span class="n">Agent</span><span class="p">.</span><span class="nf">SetIdMask</span><span class="p">(</span><span class="m">0xffffffff</span><span class="p">);</span>

    <span class="k">return</span> <span class="k">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">void</span> <span class="nf">Uninit</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">behaviac</span><span class="p">.</span><span class="n">Workspace</span><span class="p">.</span><span class="n">Instance</span><span class="p">.</span><span class="nf">Cleanup</span><span class="p">();</span>
<span class="p">}</span></code></pre>
</figure>
<p>更多细节可以参考behaviac组件C#源码中附带的integration/BattleCityDemo工程的<a href="https://github.com/Tencent/behaviac/blob/master/integration/BattleCityDemo/Assets/Scripts/BehaviacSystem.cs">BehaviacSystem.cs</a>文件。</p>
]]></content:encoded>
					
					<wfw:commentRss>/tutorial3_2_meta_cs_register/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>导出和使用C#行为树</title>
		<link>/tutorial4_3_export_cs/</link>
					<comments>/tutorial4_3_export_cs/#respond</comments>
		
		<dc:creator><![CDATA[admin]]></dc:creator>
		<pubDate>Fri, 13 May 2016 02:29:49 +0000</pubDate>
				<category><![CDATA[3.5]]></category>
		<category><![CDATA[unity]]></category>
		<category><![CDATA[上手]]></category>
		<category><![CDATA[编辑器]]></category>
		<guid isPermaLink="false">/?p=286</guid>

					<description><![CDATA[在“导出行为树”对话框中，选择“C# Behavior Exporter”，如下图所示： 点击上图中右侧的“…”设置按钮，在弹出的“C#导出设置”对话框中设置导<a class="moretag" href="/tutorial4_3_export_cs/">Read More...</a>]]></description>
										<content:encoded><![CDATA[<ul>
<li>在“导出行为树”对话框中，选择“C# Behavior Exporter”，如下图所示：</li>
</ul>
<p><img class="aligncenter" src="/img/tutorials/tutorial4/exportCs.png" alt="" /></p>
<ul>
<li>点击上图中右侧的“…”设置按钮，在弹出的“C#导出设置”对话框中设置导出文件所在的位置，如图2所示：</li>
</ul>
<p><img class="aligncenter" src="/img/tutorials/tutorial4/csExportSettings.png" alt="" /></p>
<ul>
<li>回到“导出行为树”对话框，点击“导出”按钮，开始导出<code class="highlighter-rouge">C#</code>文件。在指定的导出位置（默认为当前工作区的导出路径）会自动生成一个名为<code class="highlighter-rouge">behaviac_generated</code>的文件夹，里面生成了<code class="highlighter-rouge">behaviors</code>和<code class="highlighter-rouge">types</code>两个子文件夹，如图3所示：<img class="aligncenter" src="/img/tutorials/tutorial4/exportedCsFiles.png" alt="" /></li>
<li><code class="highlighter-rouge">behaviors</code>文件夹含有<code class="highlighter-rouge">generated_behaviors.cs</code>及其他单个的行为树<code class="highlighter-rouge">.cs</code>文件（如果没有勾选“导出统一文件？”，则对每一棵行为树都会生成独立的<code class="highlighter-rouge">.cs</code>文件）。</li>
<li><code class="highlighter-rouge">types</code>文件夹中含有<code class="highlighter-rouge">agentproperties.cs</code>（为<code class="highlighter-rouge">Agent</code>类自定义的属性和方法，会扩展在该文件中）、<code class="highlighter-rouge">customizedtypes.cs</code>（自定义的枚举和结构体类型，会生成在这个文件中）以及其他的<code class="highlighter-rouge">Agent</code>子类的文件（这些文件是为添加的<code class="highlighter-rouge">Agent</code>子类自动生成的<code class="highlighter-rouge">.cs</code>文件，需要程序员补充代码进一步实现这些<code class="highlighter-rouge">Agent</code>子类的逻辑），这些自动生成的文件都需要包含到自己的游戏项目中。</li>
</ul>
<ul>
<li>注意：这些自动生成的文件都需要包含到自己的游戏项目中，一起参与整个项目代码的编译和构建。</li>
<li>在项目中包含了这些自动生成的<code class="highlighter-rouge">.cs</code>文件后，就可以与前面提及的<a href="/docs/zh/tutorials/tutorial4_1_export_xml_bson/">导出和使用XML/BSON行为树</a>一样的接口和方式加载使用这些文件，只是需要将文件格式改为<code class="highlighter-rouge">EFF_cs</code>：</li>
</ul>
<figure class="highlight">
<pre><code class="language-cs" data-lang="cs"><span class="n">behaviac</span><span class="p">.</span><span class="n">Workspace</span><span class="p">.</span><span class="n">Instance</span><span class="p">.</span><span class="n">FileFormat</span> <span class="p">=</span> <span class="n">behaviac</span><span class="p">.</span><span class="n">Workspace</span><span class="p">.</span><span class="n">EFileFormat</span><span class="p">.</span><span class="n">EF</span></code></pre>
</figure>
]]></content:encoded>
					
					<wfw:commentRss>/tutorial4_3_export_cs/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>导出和使用XML/BSON行为树</title>
		<link>/tutorial4_1_export_xml_bson/</link>
					<comments>/tutorial4_1_export_xml_bson/#respond</comments>
		
		<dc:creator><![CDATA[admin]]></dc:creator>
		<pubDate>Fri, 13 May 2016 02:27:46 +0000</pubDate>
				<category><![CDATA[3.5]]></category>
		<category><![CDATA[unity]]></category>
		<category><![CDATA[上手]]></category>
		<category><![CDATA[C++]]></category>
		<category><![CDATA[运行时]]></category>
		<guid isPermaLink="false">/?p=282</guid>

					<description><![CDATA[目前behaviac组件支持4种文件格式（XML、BSON、C++和C#）行为树的导出。在项目开发过程中，建议使用XML格式的导出文件，以便于调试和查错等；而在<a class="moretag" href="/tutorial4_1_export_xml_bson/">Read More...</a>]]></description>
										<content:encoded><![CDATA[<p id="section">目前behaviac组件支持4种文件格式（XML、BSON、C++和C#）行为树的导出。在项目开发过程中，建议使用XML格式的导出文件，以便于调试和查错等；而在最终的发布（release）版本中，可以导出C++或C#格式的行为树文件，以便提高运行效率。</p>
<h3 id="xmlbson">导出和使用XML/BSON行为树</h3>
<ul>
<li>在编辑器中导出整个工作区文件，在“导出行为树”对话框中，勾选“Xml Behavior Exporter”或“Bson Behavior Exporter”，如下图所示：</li>
</ul>
<p><img class="aligncenter" src="/img/tutorials/tutorial4/exportXMLBson.png" alt="" /></p>
<ul>
<li>导出行为树文件结束后，回到运行时（游戏）代码端，按以下步骤使用行为树文件：
<ul>
<li>在游戏的初始化函数中，添加Agent::Register&lt;***&gt;()注册类信息到引擎库中。</li>
<li>调用Workspace::SetFilePath(…)函数，设置行为树文件的加载路径，也即编辑器导出行为树文件所在的目录。</li>
<li>调用Workspace::SetFileFormat(…)函数，设置加载行为树的文件格式，如果不调用则默认加载EFF_xml格式。</li>
<li>通过调用Agent的接口btload(…)加载所需的行为树文件。</li>
<li>通过调用Agent的接口btsetcurrent(…)设置当前准备执行的行为树文件。</li>
<li>行为树的更新执行流程请参考<a href="/docs/zh/tutorials/tutorial13_updateloop/">更新流程</a>。</li>
<li>在游戏的释放函数里面，添加Agent::Unregister&lt;***&gt;()用于释放类型的注册信息。</li>
</ul>
</li>
</ul>
<p>如下代码样例所示：</p>
<div class="highlighter-rouge">
<pre class="highlight"><code>
<span class="n">bool</span> <span class="nf">InitBehavic</span><span class="p">(</span><span class="n">behaviac</span><span class="o">::</span><span class="n">Workspace</span><span class="o">::</span><span class="n">EFileFormat</span> <span class="n">ff</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">behaviac</span><span class="o">::</span><span class="n">Config</span><span class="o">::</span><span class="n">SetSocketBlocking</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>
    <span class="n">behaviac</span><span class="o">::</span><span class="n">Config</span><span class="o">::</span><span class="n">SetSocketPort</span><span class="p">(</span><span class="mi">8081</span><span class="p">);</span>

    <span class="n">behaviac</span><span class="o">::</span><span class="n">Agent</span><span class="o">::</span><span class="n">Register</span><span class="o">&lt;</span><span class="n">CBTPlayer</span><span class="o">&gt;</span><span class="p">();</span>

    <span class="n">behaviac</span><span class="o">::</span><span class="n">Workspace</span><span class="o">::</span><span class="n">GetInstance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">SetFilePath</span><span class="p">(</span><span class="s">"../test/demo_running/behaviac/exported"</span><span class="p">);</span>
    <span class="n">behaviac</span><span class="o">::</span><span class="n">Workspace</span><span class="o">::</span><span class="n">GetInstance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">SetFileFormat</span><span class="p">(</span><span class="n">ff</span><span class="p">);</span>

    <span class="n">behaviac</span><span class="o">::</span><span class="n">Workspace</span><span class="o">::</span><span class="n">GetInstance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">ExportMetas</span><span class="p">(</span><span class="s">"../test/demo_running/behaviac/demo_running.xml"</span><span class="p">);</span>

    <span class="c1">//behaviac::Agent::SetIdMask(kIdMask_Wolrd | kIdMask_Opponent);
</span>    <span class="n">behaviac</span><span class="o">::</span><span class="n">Workspace</span><span class="o">::</span><span class="n">GetInstance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">SetDeltaFrames</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">bool</span> <span class="nf">InitPlayer</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">pszTreeName</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">g_player</span> <span class="o">=</span> <span class="n">behaviac</span><span class="o">::</span><span class="n">Agent</span><span class="o">::</span><span class="n">Create</span><span class="o">&lt;</span><span class="n">CBTPlayer</span><span class="o">&gt;</span><span class="p">();</span>

    <span class="n">bool</span> <span class="n">bRet</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="n">bRet</span> <span class="o">=</span> <span class="n">g_player</span><span class="o">-&gt;</span><span class="n">btload</span><span class="p">(</span><span class="n">pszTreeName</span><span class="p">);</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">bRet</span><span class="p">);</span>

    <span class="n">g_player</span><span class="o">-&gt;</span><span class="n">btsetcurrent</span><span class="p">(</span><span class="n">pszTreeName</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">bRet</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">CleanupPlayer</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">behaviac</span><span class="o">::</span><span class="n">Agent</span><span class="o">::</span><span class="n">Destroy</span><span class="p">(</span><span class="n">g_player</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">CleanupBehaviac</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">behaviac</span><span class="o">::</span><span class="n">Agent</span><span class="o">::</span><span class="n">UnRegister</span><span class="o">&lt;</span><span class="n">CBTPlayer</span><span class="o">&gt;</span><span class="p">();</span>

<span class="n">    behaviac</span><span class="o">::</span><span class="n">Workspace</span><span class="o">::</span><span class="n">GetInstance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">Cleanup</span><span class="p">();</span>
<span class="p">}</span>

</code></pre>
</div>
<p>总之，一棵行为树的加载到执行，关键的就是前面提及的三个接口：btload()、btsetcurrent()和btexec()。</p>
<p>更多细节可以参考behaviac组件C++源码中附带的test/demo_running工程的<a href="https://github.com/Tencent/behaviac/blob/master/test/demo_running/demo_running.cpp">demo_running.cpp</a>文件。</p>
<p>类似的，对于C#版的运行时端，采用如下代码样例加载使用刚才导出的行为树：</p>
<figure class="highlight">
<pre><code class="language-cs" data-lang="cs"><span class="k">public</span> <span class="kt">bool</span> <span class="nf">Init</span> <span class="p">()</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ms_fileSystem</span> <span class="p">==</span> <span class="k">null</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">ms_fileSystem</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">BehaviacFileManager</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="c1">//&lt; write log file
</span>    <span class="n">behaviac</span><span class="p">.</span><span class="n">Config</span><span class="p">.</span><span class="n">IsLogging</span> <span class="p">=</span> <span class="k">true</span><span class="p">;</span>
    <span class="c1">//behaviac.Config.IsSocketing = false;
</span>
    <span class="n">behaviac</span><span class="p">.</span><span class="n">Workspace</span><span class="p">.</span><span class="n">Instance</span><span class="p">.</span><span class="n">FilePath</span> <span class="p">=</span> <span class="k">this</span><span class="p">.</span><span class="n">WorkspaceExportPath</span><span class="p">;</span>
    <span class="n">behaviac</span><span class="p">.</span><span class="n">Workspace</span><span class="p">.</span><span class="n">Instance</span><span class="p">.</span><span class="n">FileFormat</span> <span class="p">=</span> <span class="n">behaviac</span><span class="p">.</span><span class="n">Workspace</span><span class="p">.</span><span class="n">EFileFormat</span><span class="p">.</span><span class="n">EFF_xml</span><span class="p">;</span>

    <span class="c1">//register names
</span>    <span class="n">behaviac</span><span class="p">.</span><span class="n">Agent</span><span class="p">.</span><span class="n">RegisterInstanceName</span><span class="p">&lt;</span><span class="n">GameLevelCommon</span><span class="p">&gt;(</span><span class="s">"GameLevel"</span><span class="p">);</span>
    <span class="n">behaviac</span><span class="p">.</span><span class="n">Workspace</span><span class="p">.</span><span class="n">Instance</span><span class="p">.</span><span class="nf">ExportMetas</span><span class="p">(</span><span class="s">"behaviac/workspace/xmlmeta/BattleCityMeta.xml"</span><span class="p">);</span>

    <span class="n">behaviac</span><span class="p">.</span><span class="n">Debug</span><span class="p">.</span><span class="nf">Log</span><span class="p">(</span><span class="s">"Behaviac meta data export over."</span><span class="p">);</span>
    <span class="n">behaviac</span><span class="p">.</span><span class="n">Agent</span><span class="p">.</span><span class="nf">SetIdMask</span><span class="p">(</span><span class="m">0xffffffff</span><span class="p">);</span>

    <span class="k">return</span> <span class="k">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">void</span> <span class="nf">Uninit</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">behaviac</span><span class="p">.</span><span class="n">Workspace</span><span class="p">.</span><span class="n">Instance</span><span class="p">.</span><span class="nf">Cleanup</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">// 加载所需的行为树文件
</span><span class="k">if</span><span class="p">(</span><span class="n">behaviorTree</span><span class="p">.</span><span class="n">Length</span> <span class="p">&gt;</span> <span class="m">0</span><span class="p">)</span>
<span class="p">{</span>
<span class="n">    btloadResult</span> <span class="p">=</span> agent.<span class="nf">btload</span><span class="p">(</span><span class="n">behaviorTree</span><span class="p">,</span> <span class="k">true</span><span class="p">);</span>
<span class="k">    if</span><span class="p">(</span><span class="n">btloadResult</span><span class="p">)</span>
        agent.<span class="nf">btsetcurrent</span><span class="p">(</span><span class="n">behaviorTree</span><span class="p">);</span>
<span class="k">    else</span>
        <span class="n">Debug</span><span class="p">.</span><span class="nf">LogError</span><span class="p">(</span><span class="s">"Behavior tree data load failed! "</span> <span class="p">+ </span><span class="n">behaviorTree</span><span class="p">);</span>
<span class="p">}</span></code></pre>
</figure>
<p>更多细节可以参考behaviac组件C#源码中附带的integration/BattleCityDemo工程的<a href="https://github.com/Tencent/behaviac/blob/master/integration/BattleCityDemo/Assets/Scripts/BehaviacSystem.cs">BehaviacSystem.cs</a>文件。</p>
]]></content:encoded>
					
					<wfw:commentRss>/tutorial4_1_export_xml_bson/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>Agent实例的用法</title>
		<link>/instance/</link>
					<comments>/instance/#respond</comments>
		
		<dc:creator><![CDATA[admin]]></dc:creator>
		<pubDate>Fri, 13 May 2016 02:44:53 +0000</pubDate>
				<category><![CDATA[3.5]]></category>
		<category><![CDATA[上手]]></category>
		<category><![CDATA[概念]]></category>
		<guid isPermaLink="false">/?p=313</guid>

					<description><![CDATA[在编辑器的节点属性窗口中，为了给某个节点选择和配置属性，首先需要选择一个实例（instance），然后再选择该实例的属性或方法，如下图所示： 这些实例主要来自于<a class="moretag" href="/instance/">Read More...</a>]]></description>
										<content:encoded><![CDATA[<p>在编辑器的节点属性窗口中，为了给某个节点选择和配置属性，首先需要选择一个实例（instance），然后再选择该实例的属性或方法，如下图所示：</p>
<p><img class="aligncenter" src="/img/tutorials/tutorial17/instance_list.png" alt="" /></p>
<p>这些实例主要来自于如下三个方面：</p>
<ul>
<li>Self：表示当前行为树根节点所配置的Agent类型的实例，类似于程序语言中的this。</li>
<li>成员实例：当前行为树根节点所配置的Agent类型的成员属性、自定义属性或局部变量，也是Agent或其子类类型。</li>
<li>全局实例：运行时端（游戏端）注册和导出的各种Agent或其子类的全局实例。</li>
</ul>
<p>其中，成员实例无需编写额外代码来进行注册和导出，behaviac组件会自动根据当前行为树根节点所配置的Agent类型，列举出所有的成员实例以供选择。但在使用该成员实例之前，需要确保该实例已经赋过值，不是空指针/引用。</p>
<p>对于全局实例，在运行时端（游戏端）的各种Agent或其子类实例的名字注册和绑定的设计意图，主要是为了支持单件（Singleton）或者类似确定的全局性的实例（同一个类可能会有若干个实例而不是仅仅有一个实例），例如：player，camera，director等。</p>
<p>注意：只有通过RegisterInstanceName注册过的“名字”才在导出元信息时被导出；而BindInstance和Create等与实例相关的函数在执行行为树的时候才需要，如果只是导出元信息则不需要。</p>
<h3 id="c">C++中全局实例的注册</h3>
<p>Agent::RegisterInstanceName可以注册一个名字，该名字表示游戏中某个Agent类的实例，如下代码所示：</p>
<div class="highlighter-rouge">
<pre class="highlight"><code>
<span class="n">behaviac</span><span class="o">::</span><span class="n">Agent</span><span class="o">::</span><span class="n">RegisterInstanceName</span><span class="o">&lt;</span><span class="n">AgentNodeTest</span><span class="o">&gt;</span><span class="p">();</span>
<span class="n">behaviac</span><span class="o">::</span><span class="n">Agent</span><span class="o">::</span><span class="n">RegisterInstanceName</span><span class="o">&lt;</span><span class="n">behaviac</span><span class="o">::</span><span class="n">Agent</span><span class="o">&gt;</span><span class="p">(</span><span class="s">"Name_Agent_0"</span><span class="p">);</span>

</code></pre>
</div>
<p>需要说明的是，游戏中需要调用Agent::Create或Agent::BindInstance创建实例并且绑定到该名字。如果指定的名字没有注册或注册的类型不同或该名字已经绑定，则调用Agent::Create的时候会有runtime的错误。</p>
<p>当调用Agent::RegisterInstanceName和Agent::Create而没有指定名字的时候，该Agent类型的名字将作为实例的名字被注册和绑定，如下代码所示：</p>
<div class="highlighter-rouge">
<pre class="highlight"><code>
<span class="n">behaviac</span><span class="o">::</span><span class="n">Agent</span><span class="o">*</span> <span class="n">testAgentA</span> <span class="o">=</span> <span class="n">behaviac</span><span class="o">::</span><span class="n">Agent</span><span class="o">::</span><span class="n">Create</span><span class="o">&lt;</span><span class="n">behaviac</span><span class="o">::</span><span class="n">Agent</span><span class="o">&gt;</span><span class="p">(</span><span class="s">"Name_Agent_0"</span><span class="p">);</span>
<span class="n">AgentNodeTest</span><span class="o">*</span> <span class="n">testAgentB</span> <span class="o">=</span> <span class="n">behaviac</span><span class="o">::</span><span class="n">Agent</span><span class="o">::</span><span class="n">Create</span><span class="o">&lt;</span><span class="n">AgentNodeTest</span><span class="o">&gt;</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>

<span class="n">behaviac</span><span class="o">::</span><span class="n">Agent</span><span class="o">*</span> <span class="n">testAgent_0</span> <span class="o">=</span> <span class="n">behaviac</span><span class="o">::</span><span class="n">Agent</span><span class="o">::</span><span class="n">GetInstance</span><span class="o">&lt;</span><span class="n">behaviac</span><span class="o">::</span><span class="n">Agent</span><span class="o">&gt;</span><span class="p">(</span><span class="s">"Name_Agent_0"</span><span class="p">);</span>
<span class="n">AgentNodeTest</span><span class="o">*</span> <span class="n">testAgent_1</span> <span class="o">=</span> <span class="n">behaviac</span><span class="o">::</span><span class="n">Agent</span><span class="o">::</span><span class="n">GetInstance</span><span class="o">&lt;</span><span class="n">AgentNodeTest</span><span class="o">&gt;</span><span class="p">();</span>

<span class="n">behaviac</span><span class="o">::</span><span class="n">Agent</span><span class="o">::</span><span class="n">BindInstance</span><span class="p">(</span><span class="n">testAgent_0</span><span class="p">,</span> <span class="s">"Name_Agent_0"</span><span class="p">);</span>
<span class="n">behaviac</span><span class="o">::</span><span class="n">Agent</span><span class="o">::</span><span class="n">BindInstance</span><span class="p">(</span><span class="n">testAgent_1</span><span class="p">,</span> <span class="err">“</span><span class="n">AgentNodeTest</span><span class="err">”</span><span class="p">);</span>

<span class="n">CHECK_EQUAL</span><span class="p">(</span><span class="n">testAgent_0</span><span class="p">,</span> <span class="n">testAgentA</span><span class="p">);</span>
<span class="n">CHECK_EQUAL</span><span class="p">(</span><span class="n">testAgent_1</span><span class="p">,</span> <span class="n">testAgentB</span><span class="p">);</span>

<span class="n">behaviac</span><span class="o">::</span><span class="n">Agent</span><span class="o">::</span><span class="n">UnbindInstance</span><span class="p">(</span><span class="s">"Name_Agent_0"</span><span class="p">);</span>
<span class="n">behaviac</span><span class="o">::</span><span class="n">Agent</span><span class="o">::</span><span class="n">UnbindInstance</span><span class="p">(</span><span class="s">"AgentNodeTest"</span><span class="p">);</span>

</code></pre>
</div>
<p>更多细节可以参考behaviac组件C++源码中附带的test工程的<a href="https://github.com/Tencent/behaviac/blob/master/test/btunittest/Others/btloadtest.cpp">btloadtest.cpp</a>文件。</p>
<h3 id="c-">C# 中全局实例的注册</h3>
<p>类似的，在C#中实例的注册和绑定相关代码如下：</p>
<pre><span class="n">behaviac</span><span class="p">.</span><span class="n">Agent</span><span class="p">.</span><span class="n">RegisterInstanceName</span><span class="p">&lt;</span><span class="n">AgentNodeTest</span><span class="p">&gt;();</span> <span class="n">behaviac</span><span class="p">.</span><span class="n">Agent</span><span class="p">.</span><span class="n">RegisterInstanceName</span><span class="p">&lt;</span><span class="n">behaviac</span><span class="p">.</span><span class="n">Agent</span><span class="p">&gt;(</span><span class="s">"Name_Agent_0"</span><span class="p">);</span> 

<span class="n">behaviac</span><span class="p">.</span><span class="n">Agent</span><span class="p">.</span><span class="nf">BindInstance</span><span class="p">(</span><span class="n">parTestAgent</span><span class="p">,</span> <span class="s">"Name_Agent_0"</span><span class="p">);</span> <span class="n">behaviac</span><span class="p">.</span><span class="n">Agent</span><span class="p">.</span><span class="nf">BindInstance</span><span class="p">(</span><span class="n">nodeTestAgent</span><span class="p">,</span> <span class="s">"AgentNodeTest"</span><span class="p">);

</span><span class="n">behaviac</span><span class="p">.</span><span class="n">Agent</span> <span class="n">testAgent_0</span> <span class="p">=</span> <span class="n">behaviac</span><span class="p">.</span><span class="n">Agent</span><span class="p">.</span><span class="n">GetInstance</span><span class="p">&lt;</span><span class="n">behaviac</span><span class="p">.</span><span class="n">Agent</span><span class="p">&gt;(</span><span class="s">"Name_Agent_0"</span><span class="p">);
</span><span class="n">AgentNodeTest</span> <span class="n">testAgent_1</span> <span class="p">=</span> <span class="n">behaviac</span><span class="p">.</span><span class="n">Agent</span><span class="p">.</span><span class="n">GetInstance</span><span class="p">&lt;</span><span class="n">AgentNodeTest</span><span class="p">&gt;();</span> 
<span class="n">AgentNodeTest</span> <span class="n">testAgent_3</span> <span class="p">=</span> <span class="n">behaviac</span><span class="p">.</span><span class="n">Agent</span><span class="p">.</span><span class="nf">GetAgent</span><span class="p">(</span><span class="s">"AgentNodeTest"</span><span class="p">)</span> <span class="k">as</span> <span class="n">AgentNodeTest</span><span class="p">;

</span><span class="n">Assert</span><span class="p">.</span><span class="nf">AreEqual</span><span class="p">(</span><span class="n">testAgent_0</span><span class="p">,</span> <span class="n">parTestAgent</span><span class="p">);
</span><span class="n">Assert</span><span class="p">.</span><span class="nf">AreEqual</span><span class="p">(</span><span class="n">testAgent_1</span><span class="p">,</span> <span class="n">nodeTestAgent</span><span class="p">);
</span><span class="n">Assert</span><span class="p">.</span><span class="nf">AreEqual</span><span class="p">(</span><span class="n">testAgent_1</span><span class="p">,</span> <span class="n">testAgent_3</span><span class="p">);

</span><span class="n">Assert</span><span class="p">.</span><span class="nf">NotNull</span><span class="p">(</span><span class="n">testAgent_0</span><span class="p">);
</span><span class="n">Assert</span><span class="p">.</span><span class="nf">NotNull</span><span class="p">(</span><span class="n">testAgent_1</span><span class="p">);

</span><span class="n">behaviac</span><span class="p">.</span><span class="n">Agent</span><span class="p">.</span><span class="nf">UnbindInstance</span><span class="p">(</span><span class="s">"Name_Agent_0"</span><span class="p">);
</span><span class="n">behaviac</span><span class="p">.</span><span class="n">Agent</span><span class="p">.</span><span class="nf">UnbindInstance</span><span class="p">(</span><span class="s">"AgentNodeTest"</span><span class="p">);</span></pre>
<p>更多细节可以参考behaviac组件C#源码中附带的integration/unity工程的<a href="https://github.com/Tencent/behaviac/blob/master/integration/unity/Assets/Scripts/behaviac/BehaviacUnitTest/Editor/ParUnitTest/OtherUnitTest.cs">OtherUnitTest.cs</a>文件。</p>
<div class="section-nav"></div>
]]></content:encoded>
					
					<wfw:commentRss>/instance/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>事件处理</title>
		<link>/tutorial11_event/</link>
					<comments>/tutorial11_event/#respond</comments>
		
		<dc:creator><![CDATA[admin]]></dc:creator>
		<pubDate>Fri, 13 May 2016 02:40:42 +0000</pubDate>
				<category><![CDATA[3.5]]></category>
		<category><![CDATA[事件]]></category>
		<category><![CDATA[概念]]></category>
		<guid isPermaLink="false">/?p=302</guid>

					<description><![CDATA[事件处理 执行行为树的过程中，当状态、条件发生变化或发生事件（Event）时，如何响应或打断当前的执行是个重要的问题。 目前behaviac组件支持三种方式来处<a class="moretag" href="/tutorial11_event/">Read More...</a>]]></description>
										<content:encoded><![CDATA[<h3><span class="ez-toc-section" id="i">事件处理</span></h3>
<p id="section">执行行为树的过程中，当状态、条件发生变化或发生事件（Event）时，如何响应或打断当前的执行是个重要的问题。</p>
<p>目前behaviac组件支持三种方式来处理状态变化或事件发生：并行节点、选择监测节点、事件附件等。</p>
<p>简而言之，并行和选择监测节点的工作方式是采用“轮询”的方式，每次执行时需要重新评估所有子节点，而不是像其他节点会保留上一次正在执行的子节点以便在下一次执行时继续执行。事件附件是在游戏逻辑发出事件时，才按需得到响应。</p>
<h3 id="section-1"><span class="ez-toc-section" id="i-2">并行节点</span></h3>
<p>依靠并行（Parallel）节点处理事件，需要把事件用条件的形式表达并且需要监控该条件，当该条件不满足的时候就退出。这种方式在概念上不太清晰，使用起来也比较繁琐，如下图所示：</p>
<p><img class="aligncenter" src="/img/overview/parallel.png" alt="" /></p>
<h3 id="section-2"><span class="ez-toc-section" id="i-3">选择监测节点</span></h3>
<p>选择监测（SelectorMonitor）和监测分支（WithPrecondition）节点作为对传统行为树的扩展，可以很自然的处理事件和状态的改变。选择监测和监测分支节点只能配对使用，即选择监测只能添加监测分支作为它的子节点，监测分支也只能作为选择监测的子节点被添加，如下图所示：</p>
<ul>
<li>选择监测节点是一个动态的选择节点，和选择（Selector）节点相同的是，它选择第一个返回成功的子节点，但不同的是，它不是只选择一次，而是每次执行时都对其子节点重新进行选择。</li>
<li>监测分支节点有条件分支子树和动作分支子树。只有条件分支子树返回成功的时候，动作分支子树才能够被执行。</li>
</ul>
<p><img class="aligncenter" src="/img/overview/selectormonitor.png" alt="" /></p>
<h3><span class="ez-toc-section" id="i-4">事件附件</span></h3>
<p>事件（Event）作为一种附件，是behaviac组件的一大特色。事件主要用于在游戏逻辑发出事件时，得到响应后打断当前正在执行的行为树，并切换到所设置的另一个行为树。</p>
<p>用一个具体例子来说明事件的原理和用法：</p>
<ul>
<li>首先，在编辑器中为AgentNodeTest类添加了event_test_int_bool(int val_int, bool val_bool)这个任务（Task）或者更形象的称之为“接口”（Interface），如下图所示：</li>
</ul>
<p><img class="aligncenter" src="/img/overview/task.png" alt="" /></p>
<ul>
<li>其次，为行为树event_subtree_2添加一个任务节点，并作为根节点的第一个子节点，为该任务节点选择一个任务，这里我们直接选择event_test_int_bool，如下图所示。类似于编程语言中的函数参数为函数体的代码提供了局部变量，任务节点中的接口参数为当前的行为树提供了局部变量，这些局部变量可以根据需要用于该行为树所有子节点。</li>
</ul>
<p><img class="aligncenter" src="/img/overview/settask.png" alt="" /></p>
<ul>
<li>再次，将上面的行为树event_subtree_2通过鼠标拖拽到行为树event_ut_1中的第一个序列节点上，这样该序列节点就有了一个事件的附件，如下图所示：</li>
</ul>
<p><img src="/img/overview/addevent.png" alt="" /></p>
<ul>
<li>然后，为该事件设置参数，如下图所示：<img src="/img/overview/eventparam.png" alt="" /><br />
其中，“触发一次”表示该事件是否只触发一次就不再起作用。“触发模式”控制该事件触发后对当前行为树的影响以及被触发的子树结束时应该如何恢复，有转移（Transfer）和返回（Return）两个选项：</p>
<ul>
<li>转移：当子树结束时，当前行为树被中断和重置，该子树将被设置为当前行为树。</li>
<li>返回：当子树结束时，返回控制到之前打断的地方继续执行。当前行为树直接“压”到执行堆栈上而不被中断和重置，该子树被设置为当前行为树，当该子树结束时，原本的那棵行为树从执行堆栈上“弹出”，并从当初的节点恢复执行。</li>
</ul>
</li>
<li>最后，在游戏代码端通过如下代码，将事件“event_test_int_bool”发出，并指定所需的参数（这里是15和true两个值）。</li>
</ul>
<figure class="highlight">
<pre><code class="language-cs" data-lang="cs"><span class="n">testAgent</span><span class="p">.</span><span class="nf">FireEvent</span><span class="p">(</span><span class="err">“</span><span class="n">event_test_int_bool</span><span class="err">”</span><span class="p">,</span> <span class="m">15</span><span class="p">,</span> <span class="k">true</span><span class="p">);</span></code></pre>
</figure>
<p>这样，在执行行为树event_ut_1时，如果接收到事件“event_test_int_bool”，那么行为树中的事件附件将得到响应和处理，行为树的执行就会从当前的event_ut_1跳转到event_subtree_2。</p>
<p>调用FireEvent的时候，只有处于running状态的节点才响应事件。这样子是是为了事件的灵活性的考虑。这个设计是为了允许不同的分支不同的时机同样的事件可以触发不同的行为。比如同样是BeingHit，你受伤的时候，或者逃跑的时候可以对应不同的行为。如果不需要根据不同的节点相应不同的行为，只是需要响应事件，可以把事件配置在根节点上（根节点同样需要是running状态，非running状态的节点没有机会相应事件）。</p>
<p>另外需要补充说明的是，行为树event_subtree_2带有任务节点，我们也可以直接将该行为树拖拽到行为树event_ut_1中，如下图所示：</p>
<p><img class="aligncenter" src="/img/overview/eventsubtree.png" alt="" /></p>
<p>这样在行为树event_ut_1中，选中引用节点event_test_int_bool后，就可以直接配置该子树执行时所需的参数（这里是val_int和val_bool），如下图所示：</p>
<p><img class="aligncenter" src="/img/overview/subtreeparam.png" alt="" /></p>
<p>行为树的任务及其参数可以类比编程语言中的函数及其参数，因此event_test_int_bool这个“函数”有两个“形式参数”val_int和val_bool，而上图中所选择的5和true值就是event_test_int_bool函数执行时所用到的“实际参数”。</p>
<p>只有根节点是Task的子树才能被拖拽到另一个符合要求的树上生成事件。</p>
<p>可以查看 <a href="https://github.com/Tencent/behaviac/blob/master/test/btunittest/NodeTest/EventUnitTest.cpp">test/btunittest/NodeTest/EventUnitTest.cpp</a></p>
]]></content:encoded>
					
					<wfw:commentRss>/tutorial11_event/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>behaviac概述</title>
		<link>/overview/</link>
					<comments>/overview/#comments</comments>
		
		<dc:creator><![CDATA[admin]]></dc:creator>
		<pubDate>Mon, 11 Apr 2016 10:00:46 +0000</pubDate>
				<category><![CDATA[3.5]]></category>
		<category><![CDATA[概念]]></category>
		<guid isPermaLink="false">/?p=166</guid>

					<description><![CDATA[1 项目概况 behaviac是游戏AI的开发框架组件，也是游戏原型的快速设计工具。支持全平台，适用于客户端和服务器，助力游戏快速迭代开发。 编辑器可以运行在P<a class="moretag" href="/overview/">Read More...</a>]]></description>
										<content:encoded><![CDATA[<h2 id="section"><span class="ez-toc-section" id="1">1 项目概况</span></h2>
<ul>
<li>behaviac是游戏AI的开发框架组件，也是游戏原型的快速设计工具。支持全平台，适用于客户端和服务器，助力游戏快速迭代开发。</li>
<li>编辑器可以运行在PC上，操作方便直观可靠，支持实时和离线调试；编辑器可以导出xml/bson等多种格式，更可以导出C++/C#源码，提供最高效率。</li>
<li>运行时支持全平台，有C++/C#两个版本，原生支持Unity。</li>
<li>已被多款知名游戏及更多其他预研项目使用。</li>
<li>所有代码（包括编辑器和运行时）已经全部开源：<a href="https://github.com/Tencent/behaviac">https://github.com/Tencent/behaviac</a></li>
</ul>
<h2 id="section-1"><span class="ez-toc-section" id="2">2 背景</span></h2>
<p>游戏AI的目标之一就是要找到一种简单并可扩展的开发逻辑的方案，常用的技术包括有限状态机（FSM）、层次化有限状态机（HFSM）、面向目标的动作规划（GOAP）、层次化任务网络（HTN）等。</p>
<p>行为树作为次时代的AI技术，距其原型提出也约有10年左右，像Halo、Spore、Crysis等大作已经采用。目前，很多知名的游戏引擎也已整合或提供了自己的行为树组件，例如Unreal4、Unity引擎等。</p>
<h3 id="section-2"><span class="ez-toc-section" id="21">2.1 有限状态机</span></h3>
<p>提到有限状态机（Finite State Machine，FSM），很多程序员都相当熟悉。状态机技术在游戏开发中也已变得很成熟和流行，它反映了从系统开始到现在的输入变化。</p>
<ul>
<li>动作（Action）：指在给定时刻要进行的活动的描述。</li>
<li>状态（State）：指对象的某种形态，在当前形态下可能会拥有不同的行为和属性。</li>
<li>转换（Transition）：表示状态变更，并且必须满足确使转移发生的条件来执行。</li>
<li>状态机（State Machine）：控制对象状态的管理器。对象的状态不会无端的改变，它需要在某种条件下才会变换。状态会在某个事件触发之后变更，不同的状态也有可能决定了对象的不同属性和行为。</li>
</ul>
<p>如下图2.1所示，有限状态机维护了一张图，图的节点是一个个的状态，节点和节点的连线是状态间根据一定规则所执行的状态转换，每一个状态内的逻辑都可以简要描述为：</p>
<ul>
<li>如果满足条件1，则跳转到状态1；</li>
<li>如果满足条件2，则跳转到状态2；</li>
<li>…；</li>
<li>否则，不做任何跳转，维持当前状态。</li>
</ul>
<p><img src="/img/overview/fsm.png" alt="" /></p>
<p>图2.1 有限状态机</p>
<p>有限状态机有着简单的优势，采用状态机来实现AI更符合思维的朴素表达。对于一些简单的AI，用状态机更加便捷，但是面对一些复杂的AI逻辑就会显得比较繁杂。</p>
<p>同时，当需要对现有行为逻辑进行扩展的时候，代码上会显得比较吃力，因为要维护的状态量会成倍增加。</p>
<p>对于大型的系统，分层有限状态机（HFSM）也支持状态间切换的重用。但是状态机需要用转换连接状态，从而状态失去了模块性。</p>
<h3 id="section-3"><span class="ez-toc-section" id="22">2.2 行为树</span></h3>
<p>行为树（Behavior Tree，BT），使得实现AI的过程变得更加需要技巧。框架设计者较为全面的考虑了可能会遇到的种种情况，把每种情况都抽象成了某个类型的节点，而游戏开发者要做的就是按照规范把各种节点连接成一棵所需的行为树。这样，行为树更加具有面向对象的特征，行为模块间的藕合度相对较低。</p>
<p>概念上，行为树就是一段脚本，以树的形式展现给用户。节点的执行结果由其父节点来管理，决定接下来做什么。由于节点间不再有转换，因此不再称为状态，节点只是行为。</p>
<p>行为树的基本结构如图2.2所示，行为树由叶子节点和中间节点组成，从左到右依次是父子关系的节点：叶子节点主要是一些动作、条件和赋值等原子操作节点，包含了最基本的行为（如跑动、攻击等），当一个叶子节点被选择后，就会激活其对应的基本行为；中间节点主要是一些组合节点，代表逻辑单元，用于管理子节点如何执行等。</p>
<p><img src="/img/overview/bt.png" alt="" /></p>
<p>图2.2 行为树</p>
<p>叶子节点和中间节点主要分为五大类节点或附件：动作、条件、组合、修饰、附件等。其中，动作、条件节点为叶子节点，组合、修饰节点为中间节点，附件必须附属在这四类节点上面而不能独立存在。</p>
<p>每个节点执行结束后，都必须将其返回值提供给父节点。节点的返回值包括三种：成功（Success）、失败（Failure）以及正在执行（Running）。最基本的行为（叶子节点）可能执行成功也可能失败，高等级的行为（中间节点）是否执行成功依赖于子节点是否执行成功，子节点执行失败可能导致其父节点选择另一个子节点。<br />
行为树中最常用的节点包括：</p>
<ul>
<li>动作节点（Action）：属于叶子节点，用于描述一个最终执行的动作。</li>
<li>条件节点（Condition）：属于叶子节点，用于描述一个条件是否成立。</li>
<li>选择节点（Selector）：属于组合节点，用于顺序执行子节点，只要它的一个子节点返回成功，则整个分支返回成功，反之返回失败，类似程序中的逻辑或（OR）。</li>
<li>顺序节点（Sequence）：属于组合节点，用于顺序执行子节点，只要它的一个子节点返回失败，则整个分支返回失败，反之返回成功，类似程序中的逻辑与（AND）。</li>
</ul>
<p>行为树的执行通过帧循环的更新来驱动，不一定是每帧都需要更新，但是需要周期性的执行。基于效率的考虑，行为树的执行有点类似于协程（Coroutine）的概念。如果有返回正在执行的节点，那么在行为树下一次执行的时候会接着执行。否则，一个返回成功或失败也就是已经结束了的行为树，下一次执行就会从根节点重新开始。</p>
<p>一棵行为树首先需要设置一个Agent类型，Agent也就是游戏中的AI角色。在这棵行为树中的所有节点（主要是叶子节点），可以进一步选择Agent的属性、方法以及其他变量等进行配置。这些Agent的类型、属性、方法等信息，称之为类型信息，后文会更详细的对其进行介绍。</p>
<p>行为树的优势如下：</p>
<ul>
<li>行为逻辑和状态数据分离，任何节点都可以反复利用。</li>
<li>重用性高，可用通过重组不同的节点来实现不同的行为树。</li>
<li>呈线性的方式布局，易扩展。</li>
<li>可配置，把工作交给策划。</li>
</ul>
<h2 id="behaviac"><span class="ez-toc-section" id="3_behaviac">3 behaviac组件</span></h2>
<p>behaviac组件包括编辑器（Designer）和运行时（Runtime）两大部分：编辑器主要用于编辑行为树，运行时库主要用于解释和执行编辑并导出过的行为树，运行时库需要整合到自己的游戏项目中去。<br />
编辑器和运行时之间通过类型信息（Meta）进行交互，如图3.1所示：</p>
<p><img src="/img/overview/meta.png" alt="" /></p>
<p>图3.1 基于类型信息的编辑器和运行时端的交互</p>
<h3 id="section-4"><span class="ez-toc-section" id="31">3.1 类型信息</span></h3>
<p>类型信息是behaviac组件的核心，包括Agent的类型、属性、方法以及类的实例名称等信息。游戏中负责运行行为的实体称谓Agent，每个Agent都存有自己的数据或者能执行自己的动作，这样的数据被称为属性（Property），这样的动作被称为方法（Method）。所谓的类型信息就是对一个Agent的描述，包括其属性和方法等。</p>
<p>运行时库产生一个描述Agent类型信息的XML文件。注意图3.1中类型信息的双向箭头，“双向”表示运行时端可以导出类型信息给编辑器使用，在编辑器中也可以编辑并导出类型信息到运行时端。</p>
<p>在运行时端，也即游戏代码端，通过注册（C++通过宏的方式，C#通过标记Attribute的方式，如代码段3.1.1和3.1.2所示）并导出供行为树引擎和编辑器使用的XML类型信息。运行时端主要是由程序员编写Agent子类及其属性和方法，然后调用相关接口将这些类型信息导出，就可以在编辑器中对这些类型信息进行使用。</p>
<div class="highlighter-rouge">
<pre class="highlight"><code>
<span class="n">BEGIN_PROPERTIES_DESCRIPTION</span><span class="p">(</span><span class="n">AgentNodeTest</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">//CLASS_DISPLAYNAME(L"测试behaviac::Agent")
</span>    <span class="c1">//CLASS_DESC(L"测试behaviac::Agent的说明")
</span>    <span class="n">REGISTER_PROPERTY</span><span class="p">(</span><span class="n">testVar_0</span><span class="p">);</span>
    <span class="n">REGISTER_PROPERTY</span><span class="p">(</span><span class="n">testVar_1</span><span class="p">).</span><span class="n">DISPLAYNAME</span><span class="p">(</span><span class="s">L"testVar_1"</span><span class="p">).</span><span class="n">DESC</span><span class="p">(</span><span class="s">L"testVar_1 property"</span><span class="p">).</span><span class="n">RANGE</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
    <span class="n">REGISTER_PROPERTY</span><span class="p">(</span><span class="n">testVar_2</span><span class="p">);</span>
    <span class="n">REGISTER_PROPERTY</span><span class="p">(</span><span class="n">testVar_3</span><span class="p">);</span>
    <span class="n">REGISTER_PROPERTY</span><span class="p">(</span><span class="n">waiting_timeout_interval</span><span class="p">);</span>
    <span class="n">REGISTER_PROPERTY</span><span class="p">(</span><span class="n">testVar_str_0</span><span class="p">);</span>

    <span class="n">REGISTER_METHOD</span><span class="p">(</span><span class="n">setEventVarInt</span><span class="p">);</span>
    <span class="n">REGISTER_METHOD</span><span class="p">(</span><span class="n">setEventVarBool</span><span class="p">);</span>
    <span class="n">REGISTER_METHOD</span><span class="p">(</span><span class="n">setEventVarFloat</span><span class="p">);</span>
    <span class="n">REGISTER_METHOD</span><span class="p">(</span><span class="n">setEventVarAgent</span><span class="p">);</span>
    <span class="n">REGISTER_METHOD</span><span class="p">(</span><span class="n">getConstOne</span><span class="p">);</span>
    <span class="n">REGISTER_METHOD</span><span class="p">(</span><span class="n">setTestVar_0</span><span class="p">);</span>
    <span class="n">REGISTER_METHOD</span><span class="p">(</span><span class="n">setTestVar_1</span><span class="p">);</span>
    <span class="n">REGISTER_METHOD</span><span class="p">(</span><span class="n">setTestVar_2</span><span class="p">);</span>
    <span class="n">REGISTER_METHOD</span><span class="p">(</span><span class="n">setTestVar_0_2</span><span class="p">);</span>
    <span class="n">REGISTER_METHOD</span><span class="p">(</span><span class="n">setTestVar_R</span><span class="p">);</span>
    <span class="n">REGISTER_METHOD</span><span class="p">(</span><span class="n">setTestVar_3</span><span class="p">);</span>
    <span class="n">REGISTER_METHOD</span><span class="p">(</span><span class="n">enter_action_0</span><span class="p">);</span>
    <span class="n">REGISTER_METHOD</span><span class="p">(</span><span class="n">exit_action_0</span><span class="p">);</span>
    <span class="n">REGISTER_METHOD</span><span class="p">(</span><span class="n">enter_action_1</span><span class="p">);</span>
    <span class="n">REGISTER_METHOD</span><span class="p">(</span><span class="n">exit_action_1</span><span class="p">);</span>
    <span class="n">REGISTER_METHOD</span><span class="p">(</span><span class="n">enter_action_2</span><span class="p">);</span>
    <span class="n">REGISTER_METHOD</span><span class="p">(</span><span class="n">exit_action_2</span><span class="p">);</span>
    <span class="n">REGISTER_METHOD</span><span class="p">(</span><span class="n">createGameObject</span><span class="p">);</span>
    <span class="n">REGISTER_METHOD</span><span class="p">(</span><span class="n">testGameObject</span><span class="p">);</span>
    <span class="n">REGISTER_METHOD</span><span class="p">(</span><span class="n">createExtendedNode</span><span class="p">);</span>
    <span class="n">REGISTER_METHOD</span><span class="p">(</span><span class="n">testExtendedRefType</span><span class="p">);</span>
    <span class="n">REGISTER_METHOD</span><span class="p">(</span><span class="n">testExtendedStruct</span><span class="p">);</span>
    <span class="n">REGISTER_METHOD</span><span class="p">(</span><span class="n">switchRef</span><span class="p">);</span>

    <span class="n">REGISTER_METHOD</span><span class="p">(</span><span class="n">CanSeeEnemy</span><span class="p">);</span>
    <span class="n">REGISTER_METHOD</span><span class="p">(</span><span class="n">Move</span><span class="p">);</span>
    <span class="n">REGISTER_METHOD</span><span class="p">(</span><span class="n">MoveToTarget</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">END_PROPERTIES_DESCRIPTION</span><span class="p">()</span>

</code></pre>
</div>
<p>代码3.1.1 在C++中通过宏注册类型信息</p>
<figure class="highlight">
<pre><code class="language-cs" data-lang="cs"><span class="na">[behaviac.TypeMetaInfo()]</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">AgentNodeTest</span> <span class="p">:</span> <span class="n">behaviac</span><span class="p">.</span><span class="n">Agent</span>
<span class="p">{</span>
    <span class="p">[</span><span class="n">behaviac</span><span class="p">.</span><span class="nf">MemberMetaInfo</span><span class="p">()]</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">testVar_0</span> <span class="p">=</span> <span class="p">-</span><span class="m">1</span><span class="p">;</span>

    <span class="p">[</span><span class="n">behaviac</span><span class="p">.</span><span class="nf">MemberMetaInfo</span><span class="p">(</span><span class="s">"testVar_1"</span><span class="p">,</span> <span class="s">"testVar_1 property"</span><span class="p">,</span> <span class="m">100</span><span class="p">)]</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">testVar_1</span> <span class="p">=</span> <span class="p">-</span><span class="m">1</span><span class="p">;</span>

    <span class="p">[</span><span class="n">behaviac</span><span class="p">.</span><span class="nf">MemberMetaInfo</span><span class="p">()]</span>
    <span class="k">public</span> <span class="kt">float</span> <span class="n">testVar_2</span> <span class="p">=</span> <span class="p">-</span><span class="m">1.0f</span><span class="p">;</span>

    <span class="p">[</span><span class="n">behaviac</span><span class="p">.</span><span class="nf">MemberMetaInfo</span><span class="p">()]</span>
    <span class="k">public</span> <span class="kt">float</span> <span class="n">testVar_3</span> <span class="p">=</span> <span class="p">-</span><span class="m">1.0f</span><span class="p">;</span>

    <span class="p">[</span><span class="n">behaviac</span><span class="p">.</span><span class="nf">MemberMetaInfo</span><span class="p">()]</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">waiting_timeout_interval</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>

    <span class="p">[</span><span class="n">behaviac</span><span class="p">.</span><span class="nf">MemberMetaInfo</span><span class="p">()]</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">testVar_str_0</span> <span class="p">=</span> <span class="kt">string</span><span class="p">.</span><span class="n">Empty</span><span class="p">;</span>

    <span class="p">[</span><span class="n">behaviac</span><span class="p">.</span><span class="nf">MemberMetaInfo</span><span class="p">()]</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">testVar_str_1</span> <span class="p">=</span> <span class="kt">string</span><span class="p">.</span><span class="n">Empty</span><span class="p">;</span>

    <span class="k">public</span> <span class="kt">bool</span> <span class="n">m_bCanSee</span> <span class="p">=</span> <span class="k">false</span><span class="p">;</span>

    <span class="k">public</span> <span class="kt">int</span> <span class="n">event_test_var_int</span> <span class="p">=</span> <span class="p">-</span><span class="m">1</span><span class="p">;</span>
    <span class="k">public</span> <span class="kt">bool</span> <span class="n">event_test_var_bool</span> <span class="p">=</span> <span class="k">false</span><span class="p">;</span>
    <span class="k">public</span> <span class="kt">float</span> <span class="n">event_test_var_float</span> <span class="p">=</span> <span class="p">-</span><span class="m">1.0f</span><span class="p">;</span>
    <span class="k">public</span> <span class="n">AgentNodeTest</span> <span class="n">event_test_var_agent</span> <span class="p">=</span> <span class="k">null</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</figure>
<p>代码3.1.2 在C#中通过Attribute标记类型信息</p>
<p>此外，behaviac组件的特色之一就是编辑器中也可以创建和编辑类型信息。编辑器主要交给策划编辑行为树，也可以编辑类型信息。策划在项目开始初期，也就是程序员还没把代码写出来之前，策划就可以自己手动的创建一些Agent类型、属性和方法等类型信息。这样可以加速游戏原型的创建，也就是策划不用等程序员，就可以进行游戏原型的编辑。</p>
<p>如图3.1.3所示，打开编辑器中提供的类型信息浏览器，可以查看或新建Agent类型。选中其中一个Agent类型之后，可以查看它的属性、方法等信息，并可以扩展Agent类型的成员属性和方法等，还支持新建枚举和结构体类型等。</p>
<p><img src="/img/overview/metabrowser.png" alt="" /></p>
<p>图3.1.3 在类型信息浏览器中查看和编辑类型信息</p>
<h4 id="section-5"><span class="ez-toc-section" id="311">3.1.1 类型</span></h4>
<p>类型（Type）分为Agent、枚举和结构体等。</p>
<ul>
<li>Agent类：作为行为树的基本组成元素，是供其他游戏类派生的基类，在图3.1.3所示的类型信息浏览器中，我们可以查看所有导出和创建的Agent类型，这些Agent类型又包含变量和方法两大部分。可以在类型信息浏览器中添加自己的Agent子类，为其添加成员属性和方法，但方法的实现需要另外编写需要的逻辑代码。</li>
<li>枚举：游戏端的用到枚举类型会导出在类型信息文件中，也可以在类型信息浏览器中添加自己的枚举类型，并可以导出生成C++或C#源码，再添加到游戏端代码中。</li>
<li>结构体：游戏端的用到结构体类型会导出在类型信息文件中，也可以在类型信息浏览器中添加自己的结构体类型，但只能为其增加成员属性，不能添加成员方法，可以导出生成C++或C#源码，添加到游戏端代码中。</li>
</ul>
<p>如图3.1.1.1所示，在新建一棵行为树时，首先需要为根节点选择一种Agent类型，以表明当前新建的行为树是用的哪种Agent，该行为树的所有叶子节点将可以使用该Agent类型的属性和方法。</p>
<p><img src="/img/articles/agenttype_selector.png" alt="" /></p>
<p><img src="/img/overview/agenttype.png" alt="" /></p>
<p>图3.1.1.1 为根节点设置Agent类型</p>
<h4 id="section-6"><span class="ez-toc-section" id="312">3.1.2 实例</span></h4>
<p>上面已经提及了一棵行为树需要设置它的Agent类型，以便于所有叶子节点使用该Agent类型的属性和方法。对于这种情况，我们称之为使用自身（Self）的属性和方法。</p>
<p>另一方面，某个节点的参数可能会用到不是自身的属性或方法，这时就需要首先选择实例（Instance），然后再选择该实例所属的Agent类型的属性或方法，如图3.1.2.1所示。</p>
<p>所有Agent类的实例在运行时端需要通过注册并导出到类型信息文件中，这样编辑器拿到所有的实例列表后就可以一一列举出来以供选择，具体注册方法详见使用手册。</p>
<p><img src="/img/overview/properties.png" alt="" /></p>
<p>图3.1.2.1 为条件节点设置左参数</p>
<h4 id="section-7"><span class="ez-toc-section" id="313">3.1.3 变量</span></h4>
<p>变量分为成员字段（Field）、属性（Property）、自定义的属性以及局部变量等。</p>
<ul>
<li>成员字段：也即面向对象编程（C++/C#）中类的字段。</li>
<li>成员属性：也即C#中类的属性，带有getter和setter。</li>
<li>自定义的属性：主要是在编辑器中为Agent类型新建出来的成员属性。在变量前有一个‘*’星号标识。如下图。</li>
<li>局部变量：在变量前有一个‘-’减号标识。相对于成员属性和自定义的属性这些全局属性而言。为什么称之为全局属性？在整个游戏项目中，可能会有很多棵行为树，我们称之为工作区来管理所有的行为树。每一种Agent类型的成员属性和自定义的属性是可以供这个工作区中的所有行为树选择使用的，而局部变量只是针对某一棵行为树，局限于在这一棵行为树中所使用的变量。</li>
</ul>
<p><img src="/img/overview/variable_indicator.png" alt="" /></p>
<p>behaviac组件支持变量的只读（Readonly）特性，这样在编辑器中只可以对该属性进行读取，但不能为其赋值。局部变量不仅支持int、float、bool、枚举等基本的数据类型，也支持复杂的指针或引用类型。</p>
<h4 id="section-8"><span class="ez-toc-section" id="314">3.1.4 方法</span></h4>
<p>方法包括成员方法、自定义的方法、任务（Task）等。</p>
<ul>
<li>成员方法：也即面向对象编程中类的成员方法。</li>
<li>自定义的方法：在编辑器中创建出来的方法。自定义的方法只是作为占位符，允许设计人员可以继续工作。使用了自定义方法的行为树不允许导出。只有当程序员实现了该方法后，自定义方法变成了成员方法后该行为树才允许被导出。这个设定是为了保证导出的行为树是可以执行的。</li>
<li>任务：用于描述子树所需的接口，包括接口名和参数列表，跟方法的定义类似。后文将结合子树的概念，对任务的用法进行更详细的说明。</li>
</ul>
<p>最后，在编辑器中就可以根据导出和创建的类型信息，对行为树进行编辑。在行为树的每个节点上可以根据需要选择或设置属性、方法及其参数等，如图3.1.4.1所示。</p>
<p><img src="/img/overview/action.png" alt="" /></p>
<p>图3.1.4.1 编辑节点的属性</p>
<h3 id="section-9"><span class="ez-toc-section" id="32">3.2 工作区</span></h3>
<p>采用behaviac组件开始项目时，首先需要在编辑器中创建一个工作区（Workspace）。</p>
<p>工作区文件以.workspace.xml为后缀名，是管理游戏项目中所有行为树文件的配置文件，如图3.2.1所示：</p>
<p><img src="/img/overview/workspace.png" alt="" /></p>
<p>图3.2.1 工作区文件</p>
<p>该配置文件可以指定XML类型信息文件、行为树源文件的路径、导出文件的路径等，可以通过编辑器中的“新建工作区”或“编辑工作区”工具编辑相关设置，如图3.2.2所示：</p>
<p><img src="/img/overview/editworkspace.png" alt="" /></p>
<p>图3.2.2 编辑工作区</p>
<p>行为树源文件和导出文件的区别在于，行为树源文件是在编辑器中供策划编辑使用的初始源文件（XML格式），包含了很多冗余的信息，比如UI显示所需的属性等。而导出文件是一种精简版的行为树文件，只是给运行时端使用的一种高效的执行文件。</p>
<p>源文件就像那些Raw Data，必须导出后才能在运行时中使用，而导出文件就像那些处理过并在游戏中直接使用的Game Data。工作区文件、源文件、类型信息文件等在游戏中都不再需要，游戏中只需要导出的文件。</p>
<p>目前支持XML、BSON、C++和C#四种导出格式。其中，XML/BSON主要用于开发阶段，C++/C#主要用于最后的发布。C++/C#的内存和性能明显要优于XML/BSON的格式，所以我们建议在最后的发布过程，使用C++/C#的行为树导出文件。</p>
<h3 id="section-10"><span class="ez-toc-section" id="33">3.3 行为树</span></h3>
<p>behaviac组件提供了数量繁多、功能齐全的节点和附件，并支持扩展自己所需的节点类型。此外，behaviac组件还支持子树、事件、预制等高级用法，下面将一一进行介绍。</p>
<h4 id="section-11"><span class="ez-toc-section" id="331">3.3.1 节点与附件</span></h4>
<p>前面已经介绍，行为树的节点主要分为五大类节点或附件：动作、条件、组合、修饰、附件等，如图3.3.1所示。其中，动作、条件节点为叶子节点，组合、修饰节点为中间节点，附件必须附属在这四类节点上面而不能独立存在。</p>
<p>behaviac组件还支持扩展新的节点类型，具体用法可以详见使用手册中的介绍。</p>
<p><img src="/img/overview/nodes.png" alt="" /></p>
<p>图3.3.1.1 行为树的节点和附件</p>
<p>为了支持子树（Subtree）的功能，behaviac组件还提供了引用节点（ReferencedBehavior）类型，后文将对子树和引用节点详细介绍。</p>
<p>节点可以具有前置（Preaction）和后置（Postaction）等附件，如图3.3.2所示。前置可以表示执行某个条件或者某个操作，如果是条件，那么前置必须返回成功后才能继续执行所在的节点，否则直接返回到父节点。而后置只用于表示该节点执行完毕后继续执行的操作。</p>
<p><img src="/img/overview/attachments.png" alt="" /></p>
<p>图3.3.1.2 节点上的前置和后置</p>
<p>还有一种附件比较特殊，也即事件（Event）。事件是将一棵行为树作为另一棵行为树中某个节点（一般为根节点）的附件，用于响应事件发生时行为树的切换。后文将对事件进行更详细的说明。</p>
<p>为了支持某些特殊应用，behaviac组件还为序列（Sequence）、选择（Selector）等组合节点添加了中断条件（Interrupted Condition），如图3.3.1.3所示。增加中断条件是为了让序列节点（或其他组合节点）在依次执行每个子节点的时候，都需要根据该中断条件的执行结果，来判断是否需要执行当前子节点。也即，所有的子节点有一个统一的中断条件被打断执行。</p>
<p><img src="/img/overview/interupt.png" alt="" /></p>
<p>图3.3.1.3 中断条件</p>
<p>在编辑器中，可以通过鼠标拖拽这些节点到新建的行为树中，或拖拽前置和后置附件到某个节点上。</p>
<h4 id="section-12"><span class="ez-toc-section" id="332">3.3.2 预制</span></h4>
<p>为了方便或加速行为树的编辑，behaviac编辑器提供了预制（Prefab）的功能，以便利于复用已经编辑好的行为树。</p>
<p>behaviac组件的预制跟Unity引擎中的预制工作机制类似，如果在用到预制的地方改变了预制中某个节点的属性，那么就会在所在的行为树中创建一份该预制的实例（Instance）。如果没有改变预制中任何节点的属性，则直接跟预制母体的属性保持一致，也即修改了预制中任何节点的属性，用到该预制的其他行为树也跟着同步改变。</p>
<p>在编辑器中，可以将已经编辑好的行为树另存为预制，这些预制会组织在Prefabs目录下，以便区分于项目所需的行为树（归类在Behaviors目录下），如图3.3.2.1所示。</p>
<p><img src="/img/overview/behaviors.png" alt="" /></p>
<p>图3.3.2.1 行为树与预制</p>
<p>如图3.3.2.2所示，先构建了一个预制行为树“Prefab_安全的随机移动”。</p>
<p><img src="/img/overview/prefab.png" alt="" /></p>
<p>图3.3.2.2 预制</p>
<p>如图3.3.2.3所示，再将该行为树拖拽进行为树Tank_SafeWander_RandomFire中，可以看到该预制行为树会得到展开并复制过去，这加速了行为树的编辑，提高了开发工作的效率。</p>
<p><img src="/img/overview/prefabinstance.png" alt="" /></p>
<p>图3.3.2.3 使用预制的行为树</p>
<h4 id="section-13"><span class="ez-toc-section" id="333">3.3.3 子树与递归</span></h4>
<p>在编辑器中，可以通过鼠标拖拽一棵行为树到另一棵行为树中，并作为引用节点（ReferencedBehavior）添加到另一棵行为树上。如图3.3.3.1所示，action_ut_0就是action_ut_1的子树，action_ut_0所在的节点是一个引用节点。</p>
<p><img src="/img/overview/subtree.png" alt="" /></p>
<p>图3.3.3.1 子树</p>
<p>有了子树的功能，behaviac组件自然也支持了“递归”的功能，只要将当前行为树作为自己的子树即可。形成递归的时候需要注意不要造成死循环，这可以通过变量的使用来避免。</p>
<p>如图3.3.3.2所示，利用testVar_0来避免死循环：第一次进入的时候testVar_0 == 0，所以可以执行下面的序列，先把testVar_0赋值为1，那么在下面的递归重入的时候由于testVar_0 == 1，所以testVar_0 == 0的条件不满足，所以下面的序列不会进入从而避免了死循环。</p>
<p><img src="/img/overview/reverse.png" alt="" /></p>
<p>图3.3.3.2 递归</p>
<h4 id="section-14"><span class="ez-toc-section" id="334">3.3.4 事件处理</span></h4>
<p>执行行为树的过程中，当状态、条件发生变化或发生事件（Event）时如何响应或打断当前的执行是个重要的问题。</p>
<p>请详看文档《<a href="/docs/zh/tutorials/tutorial11_event/">事件处理</a>》。</p>
<h4 id="section-15"><span class="ez-toc-section" id="335">3.3.5 热加载</span></h4>
<p>behaviac组件中的编辑器和运行时库都支持热加载，但是只针对XML/BSON格式的行为树文件。</p>
<p>在编辑器中，只要当前打开的行为树文件在编辑器外由于某种原因得到修改（例如通过项目中的文件版本管理系统强制同步行为树文件，或者通过文本编辑器强制修改行为树XML文件等），那么都可以自动的在编辑器中得到刷新。</p>
<p>对于运行时端（或游戏端），只要在编辑器中修改了行为树文件并重新导出，那么在游戏运行过程中不用退出游戏，最新导出的行为树可以自动进行加载，这样就可以及时查看行为树最新的效果。</p>
<p>请详看文档《<a href="/docs/zh/tutorials/tutorial12_hotreload/">热加载</a>》。</p>
<h3 id="section-16"><span class="ez-toc-section" id="34">3.4 有限状态机</span></h3>
<p>除了上面提及的行为树，behaviac组件还支持传统的有限状态机（FSM）。在前面的2.1章节已经说明，有限状态机主要由状态（State）和转换（Transition）构成，如图3.4.1所示。</p>
<p><img src="/img/overview/fsm.png" alt="" /></p>
<p>图3.4.1 有限状态机</p>
<p>类似于前面提及的行为树子树的概念，behaviac组件的一大特色就是支持将编辑好的一个有限状态机整体作为另一个有限状态机的“子树”，甚至有限状态机还可以跟行为树交替引用，互相作为彼此的子树，也即一个有限状态机可以整体作为一棵行为树的“引用节点”，同时一棵行为树也可以整体作为一个有限状态机中的“引用状态”。</p>
<p>在behaviac编辑器中，状态是作为类似行为树的节点一样独立存在，而转换是为类似行为树中的附件一样挂在某个状态上。有限状态机的编辑也很简单，只需要通过鼠标拖拽“状态”节点和“转换”附件到新建的有限状态机中，如图3.4.2所示。</p>
<p><img src="/img/overview/states.png" alt="" /></p>
<p>图3.4.2 有限状态机的状态和转换</p>
<p>类似于行为树中的节点，还可以为有限状态机中的状态节点添加前置和后置附件，以表示执行到当前状态节点时，所需要执行的前置条件和后置操作。</p>
<h3 id="section-17"><span class="ez-toc-section" id="35">3.5 调试</span></h3>
<p>编辑器支持跟游戏端进行连调，如图3.5.1所示。</p>
<p><img src="/img/overview/connect.png" alt="" /></p>
<p>图3.5.1 连接游戏</p>
<p>支持查看属性的变化（图3.5.2）、在节点上设置断点（图3.5.3）、高亮显示行为树的执行路径（图3.5.3）以及记录每帧信息以便后续查看等功能。</p>
<p><img src="/img/overview/agentproperties.png" alt="" /></p>
<p>图3.5.2 查看Agent的属性</p>
<p><img src="/img/overview/breakpoints.png" alt="" /></p>
<p>图3.5.3 设置断点以及高亮显示执行路径</p>
<h3 id="demo"><span class="ez-toc-section" id="36">3.6 单元测试与</span></h3>
<p>为了方便入门，behaviac组件提供了C++和C#两种编程语言的单元测试以及游戏Demo，可以通过编辑器中的菜单项“帮助”-&gt;“控制说明” 进入，然后点击快速打开所需的单元测试或游戏Demo所用到的工作区，如图3.6.1所示。</p>
<p><img src="/img/overview/demo.png" alt="" /></p>
<p>图3.6.1 单元测试与Demo</p>
<h3 id="section-18"><span class="ez-toc-section" id="37">3.7 开源</span></h3>
<p>behaviac组件已在github上开源，网址是<a href="https://github.com/Tencent/behaviac">https://github.com/Tencent/behaviac</a>，可以下载最新的安装包、源码以及相关文档等。</p>
<p>另外，behaviac视频讲解的链接为：<a href="http://gad.qq.com/tool/detail/2">http://gad.qq.com/tool/detail/2</a></p>
]]></content:encoded>
					
					<wfw:commentRss>/overview/feed/</wfw:commentRss>
			<slash:comments>2</slash:comments>
		
		
			</item>
		<item>
		<title>扩展节点类型</title>
		<link>/tutorial9_extendnodes/</link>
					<comments>/tutorial9_extendnodes/#respond</comments>
		
		<dc:creator><![CDATA[admin]]></dc:creator>
		<pubDate>Fri, 13 May 2016 02:37:40 +0000</pubDate>
				<category><![CDATA[3.5]]></category>
		<category><![CDATA[扩展]]></category>
		<guid isPermaLink="false">/?p=298</guid>

					<description><![CDATA[有时候，behaviac组件自带的节点类型不能满足项目需求，或者需要更高效的节点类型，可以通过添加新的节点类型来扩展系统。 添加新的节点类型，编辑器端需要实现一<a class="moretag" href="/tutorial9_extendnodes/">Read More...</a>]]></description>
										<content:encoded><![CDATA[<p id="section">有时候，behaviac组件自带的节点类型不能满足项目需求，或者需要更高效的节点类型，可以通过添加新的节点类型来扩展系统。</p>
<p>添加新的节点类型，编辑器端需要实现一个插件，运行时端需要实现相应的节点类型以便加载数据并且负责执行。</p>
<h3 id="section-1"><span class="ez-toc-section" id="i">编辑器端的插件</span></h3>
<p>随项目提供了ExamplePlugin，可以根据该插件做相应的修改来添加自己的新节点。该项目所在路径：tools/Designer/Plugins/ExamplePlugin。</p>
<h3 id="section-2"><span class="ez-toc-section" id="i-2">项目设置</span></h3>
<ul>
<li>该项目依赖如下DLL，如下图所示：</li>
</ul>
<p><img class="aligncenter" src="/img/tutorials/tutorial9/referencedDlls.png" alt="" /></p>
<ul>
<li>产生的DLL需要放置在BehaviacDesigner.exe同一个目录。</li>
<li>如果自己的插件只是对ExamplePlugin修改了相应的名字，并且该插件项目和ExamplePlugin的所在位置一样，即位于tools/Designer/Plugins中，那么对BehaviacDesignerBase.dll的引用以及产生DLL的输出路径不需要改动即可。否则，如果有编译错误或者运行时不能看到添加的节点，请确保上面两个步骤的设置都是正确的。</li>
<li>打开编辑器后，正常情况下新加的节点ExampleNode将出现在动作组下，如下图所示：</li>
</ul>
<p><img class="aligncenter" src="/img/tutorials/tutorial9/actionFolder.png" alt="" /></p>
<h3><span class="ez-toc-section" id="i-3">节点类型</span></h3>
<p>每一个要添加的节点类型，都需要仿照ExampleNode或相应的节点新建文件ExampleNode.cs，并编写类ExampleNode的实现。</p>
<ul>
<li>该类的Attribute（即NodeDesc）用来指定该节点出现的组和图标（icon）。如果使用自己的图标文件，则需要添加进工程的Resources.resx文件中，假如该图标命名为“exampleNodeIcon”，并使用如下代码：<br />
[NodeDesc(“Actions”, “exampleNodeIcon”)]</li>
<li>构造函数里需要提供显示用的名字（DisplanName）和描述（Description）</li>
<li>ExportClass用来指定该类导出供C++载入时的类名。</li>
<li>根据需要添加自己的属性（Property），这些属性在designer里将会自动的显示出来供用户指定数据。</li>
<li>如果上一步添加了属性，那么需要重载protected override void CloneProperties(Node newnode)，来clone这些新加的属性。</li>
<li>重载public override void CheckForErrors(BehaviorNode rootBehavior, List result)来验证数据的有效性已经提供无效时的说明。</li>
<li>此外，还需编写生成新加节点类型的C++或C#相关的代码，参考“5.4扩展生成节点或编程语言”。这里介绍用于生成C++代码的相关类和接口（生成C#完全类似）：
<ul>
<li>添加文件ExampleNodeCppExporter.cs（注意，必须是CppExporter结尾，若是生成C#，则必须以CsExporter结尾，后面类推），编写类ExampleNodeCppExporter的实现。</li>
<li>根据新加节点的需要，重载GenerateConstructor、GenerateMember、GenerateMethod等函数。</li>
<li>其他细节请参考样例代码的实现。</li>
</ul>
</li>
</ul>
<h3 id="section-4"><span class="ez-toc-section" id="i-4">属性</span></h3>
<ul>
<li>属性（Property）的类型可以是基本类型如bool、int、float、string等</li>
<li>可以是VariableDef、MethodDef，RightValueDef来表示访问Agent的属性或方法。</li>
<li>可以是结构体（Struct）、数组（Array）或结构体的数组。</li>
<li>可以是枚举（Enum）或枚举的数组。</li>
<li>需要提供相应的Attribute来描述该属性的类型信息，比如，显示名、描述、范围、显示顺序等。请注意属性的类型必须与相应的Attribute的类型保持一致。
<ul>
<li>DesignerBoolean</li>
<li>DesignerInteger</li>
<li>DesignerFloat</li>
<li>DesignerString</li>
<li>DesignerTypeEnum</li>
<li>DesignerStruct</li>
<li>DesignerPropertyEnum</li>
<li>DesignerRightValueEnum</li>
<li>DesignerMethodEnum</li>
<li>DesignerArrayStruct</li>
<li>DesignerArrayBoolean</li>
<li>DesignerArrayInteger</li>
<li>DesignerArrayFloat</li>
<li>DesignerArrayString</li>
<li>DesignerArrayEnum</li>
</ul>
</li>
</ul>
<h3 id="section-5"><span class="ez-toc-section" id="i-5">运行时端需要实现相应的节点类型</span></h3>
<p>节点类型包括叶子节点和分支节点，而分支节点又分为组合节点（Composite）或装饰节点（Decorator）。需要根据具体的节点类型从相应的基类继承来创建自己的节点类。<br />
每个节点类型需要两个相应的类：一个是静态Node，这个是静态的数据，负责load数据以及创建相应的动态节点；另一个是动态Task。<br />
详细代码请参考action.h、condition.h或waitframes.h等头文件。</p>
<h4 id="node"><span class="ez-toc-section" id="Node">静态Node</span></h4>
<p>静态的Node必须提供的两个虚函数如下：</p>
<ul>
<li>virtual void load(int version, const char* agentType, const properties_t&amp; properties);</li>
<li>virtual BehaviorTask* createTask() const;</li>
<li>BehaviorNode::Register&lt;***&gt;();进入程序前需要注册该静态的Node类型，动态的Task类不需要注册。</li>
<li>BehaviorNode::UnRegister&lt;***&gt;();结束程序前需要反注册该静态的Node类型，动态的Task类不需要反注册。</li>
</ul>
<h4 id="task"><span class="ez-toc-section" id="Task">动态Task</span></h4>
<p>对应静态Node，动态Task需要提供下列虚函数：</p>
<ul>
<li>virtual void copyto(BehaviorTask* target) const;</li>
<li>virtual void save(ISerializableNode* node) const;</li>
<li>virtual void load(ISerializableNode* node);</li>
<li>virtual bool onenter(Agent* pAgent);</li>
<li>virtual void onexit(Agent* pAgent, EBTStatus s);</li>
<li>virtual EBTStatus update(Agent* pAgent, Interval_t&amp; interval, EBTStatus childStatus);</li>
</ul>
<p>如果没有特殊需要，则直接调用super的函数就可以了。</p>
]]></content:encoded>
					
					<wfw:commentRss>/tutorial9_extendnodes/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>类、结构体或枚举的数组</title>
		<link>/tutorial8_customarray/</link>
					<comments>/tutorial8_customarray/#respond</comments>
		
		<dc:creator><![CDATA[admin]]></dc:creator>
		<pubDate>Fri, 13 May 2016 02:34:48 +0000</pubDate>
				<category><![CDATA[3.5]]></category>
		<category><![CDATA[扩展]]></category>
		<category><![CDATA[C++]]></category>
		<category><![CDATA[运行时]]></category>
		<guid isPermaLink="false">/?p=296</guid>

					<description><![CDATA[对于C#版，类型信息不支持[]类型的数组，只支持List&#60;***&#62;类型的数组。 对于C++版，需要按照如下方式进行注册： 基本类型（bool、int<a class="moretag" href="/tutorial8_customarray/">Read More...</a>]]></description>
										<content:encoded><![CDATA[<p id="section">对于C#版，类型信息不支持[]类型的数组，只支持List&lt;***&gt;类型的数组。</p>
<p>对于C++版，需要按照如下方式进行注册：</p>
<p>基本类型（bool、int、float、char、sbyte、ubyte等）的数组可以直接使用，但当使用到其他自定义类型数组的时候，需要添加特殊的宏和代码，否则运行时可能会有错误（如果没有使用到相应的操作，则没有错误）：</p>
<ul>
<li>在.h的头文件里添加如下所示的宏，但需放在任意namespace之外：</li>
</ul>
<div class="highlighter-rouge">
<pre class="highlight"><code>
<span class="n">BEHAVIAC_DECLARE_TYPE_VECTOR_HANDLER</span><span class="p">(</span><span class="n">TNS</span><span class="o">::</span><span class="n">ST</span><span class="o">::</span><span class="n">PER</span><span class="o">::</span><span class="n">WRK</span><span class="o">::</span><span class="n">kEmployee</span><span class="p">);</span>

</code></pre>
</div>
<ul>
<li>在初始化的代码里添加如下所示的注册代码：</li>
</ul>
<div class="highlighter-rouge">
<pre class="highlight"><code>
<span class="n">behaviac</span><span class="o">::</span><span class="n">TypeRegister</span><span class="o">::</span><span class="n">Register</span><span class="o">&lt;</span><span class="n">TNS</span><span class="o">::</span><span class="n">ST</span><span class="o">::</span><span class="n">PER</span><span class="o">::</span><span class="n">WRK</span><span class="o">::</span><span class="n">kEmployee</span><span class="o">&gt;</span><span class="p">(</span><span class="s">" TNS::ST::PER::WRK::kEmployee"</span><span class="p">);</span>

</code></pre>
</div>
<ul>
<li>在结束代码里添加如下所示的反注册代码：</li>
</ul>
<div class="highlighter-rouge">
<pre class="highlight"><code>
<span class="n">behaviac</span><span class="o">::</span><span class="n">TypeRegister</span><span class="o">::</span><span class="n">UnRegister</span><span class="o">&lt;</span><span class="n">TNS</span><span class="o">::</span><span class="n">ST</span><span class="o">::</span><span class="n">PER</span><span class="o">::</span><span class="n">WRK</span><span class="o">::</span><span class="n">kEmployee</span><span class="o">&gt;</span><span class="p">(</span><span class="s">" TNS::ST::PER::WRK::kEmployee"</span><span class="p">);</span>

</code></pre>
</div>
<p>更多细节可以参考behaviac组件C++源码中附带的<a href="https://github.com/Tencent/behaviac/blob/master/test/btunittest/Agent/UnitTestTypes.h">UnitTestTypes.h</a>文件中的结构体kEmployee。</p>
<ul>
<li>Agent及其子类的数组<br />
当涉及<code class="highlighter-rouge">behaviac::Agent</code>或是其子类的时候，仅支持其指针类型即<code class="highlighter-rouge">behaviac::Agent*</code>或<code class="highlighter-rouge">SubclassAgent*</code>（<code class="highlighter-rouge">SubclassAgent</code>是<code class="highlighter-rouge">behaviac::Agent</code>的一个子类）。<br />
<code class="highlighter-rouge">behaviac::Agent*</code>或<code class="highlighter-rouge">vector&lt;behaviac::Agent*&gt;</code>类型直接被支持，不需要做什么额外的工作，其任何子类<code class="highlighter-rouge">SubclassAgent*</code>也直接被支持。<br />
但是需要支持<code class="highlighter-rouge">vector&lt;SubclassAgent*&gt;</code>的时候，则需要在.h文件里添加如下所示的宏，但需放在任意namespace之外：</li>
</ul>
<div class="highlighter-rouge">
<pre class="highlight"><code>
<span class="n">BEHAVIAC_DECLARE_TYPE_VECTOR_HANDLER</span><span class="p">(</span><span class="n">SubclassAgent</span><span class="o">*</span><span class="p">);</span>

</code></pre>
</div>
<p>在初始化和结束的时候分别注册和反注册：</p>
<div class="highlighter-rouge">
<pre class="highlight"><code>
<span class="n">behaviac</span><span class="o">::</span><span class="n">Agent</span><span class="o">::</span><span class="n">Register</span><span class="o">&lt;</span><span class="n">SubclassAgent</span><span class="o">&gt;</span><span class="p">();</span>

<span class="n">behaviac</span><span class="o">::</span><span class="n">Agent</span><span class="o">::</span><span class="n">UnRegister</span><span class="o">&lt;</span><span class="n">SubclassAgent</span><span class="o">&gt;</span><span class="p">();</span>

</code></pre>
</div>
<p>更多细节可以参考behaviac组件C++源码中附带的<a href="https://github.com/Tencent/behaviac/blob/master/test/btunittest/Agent/EmployeeParTestAgent.h">EmployeeParTestAgent.h</a>文件中的类EmployeeParTestAgent。</p>
]]></content:encoded>
					
					<wfw:commentRss>/tutorial8_customarray/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>元信息的使用和编辑</title>
		<link>/tutorial3_3_meta_edit/</link>
					<comments>/tutorial3_3_meta_edit/#respond</comments>
		
		<dc:creator><![CDATA[admin]]></dc:creator>
		<pubDate>Fri, 13 May 2016 02:26:41 +0000</pubDate>
				<category><![CDATA[3.5]]></category>
		<category><![CDATA[上手]]></category>
		<category><![CDATA[编辑器]]></category>
		<guid isPermaLink="false">/?p=280</guid>

					<description><![CDATA[使用元信息 在编辑器中新建一个工作区，并根据上一步中导出的元数据文件所在的文件夹，设置该工作区的“元数据位置”，可以看到demo_running.xml文件已经<a class="moretag" href="/tutorial3_3_meta_edit/">Read More...</a>]]></description>
										<content:encoded><![CDATA[<h2>使用元信息</h2>
<ul>
<li>在编辑器中新建一个工作区，并根据上一步中导出的元数据文件所在的文件夹，设置该工作区的“元数据位置”，可以看到demo_running.xml文件已经可以使用，如下图所示：</li>
</ul>
<p><img class="aligncenter" src="/img/tutorials/tutorial3/editWorkspace.png" alt="" /></p>
<ul>
<li>新建行为树文件，并为该行为树添加一些节点，选择某个节点后，可以设置该节点的属性（可选属性正是来至上面导出的元信息），如下图所示：</li>
</ul>
<p><img class="aligncenter" src="/img/overview/action.png" alt="" /></p>
<h2>编辑元信息</h2>
<ul>
<li>前面介绍的是在运行时（游戏）端编写代码导出元信息到编辑器中，behaviac组件也支持在编辑器中创建和编辑元信息。</li>
<li>在编辑器中，通过菜单项“视图”-&gt;“元信息浏览”（或快捷键Ctrl+M）打开元信息浏览器，如下图所示：</li>
</ul>
<p><img class="aligncenter" src="/img/overview/metabrowser.png" alt="" /></p>
<ul>
<li>类型列表：左上方的“类型列表”显示了所有的Agent类、自定义的枚举和结构体类型，其右侧是当前选中的类型的属性。“类型列表”中的名字前面带有“*”，表示该类型是在编辑器中创建出来的。创建一个类型（Agent类、枚举或结构体），可以点击元信息浏览器右上角的“新增”按钮，如下图所示。后文将提到对这些新增的类型，导出时会自动生成相应的C++或C#源码文件，这样程序员就可以在生成的源码文件基础上添加和实现自己的游戏逻辑。</li>
</ul>
<p><img class="aligncenter" src="/img/tutorials/tutorial3/newType.png" alt="" /></p>
<ul>
<li>实例名称：元信息浏览器中的“实例名称”，用于列出当前选中的Agent类型的所有实例，这些实例是通过之前提及的Agent::RegisterInstanceName接口在运行时端注册并导出的。如果当前选中的Agent类型没有导出任何实例，那么这一行显示为空白。</li>
<li>成员类型：成员类型包括属性（Property）、方法（Method）和任务（Task）。</li>
<li>成员列表：选中了上面的“成员类型”后，会列出当前选中的类型的所有成员属性、方法或任务。如果是自定义的成员，那么在列表中的名字前会多出一个“*”。点击“成员列表”右侧的“新增”按钮，可以新增一个成员，可以通过选中“是否局部变量”，将该变量标记为局部变量（在列表中的名字前会多出一个“-”），如下图所示。新增一个方法或任务也类似。选中某个成员后，在元信息浏览器下方会列出该成员的所有属性。</li>
</ul>
<p><img class="aligncenter" src="/img/tutorials/tutorial3/newProperty.png" alt="" /></p>
<p>只要在元信息浏览器中编辑了元信息，那么点击元信息浏览器下方的“应用”或“确认”按钮后，编辑器就会在工作区源文件所在目录的保存出一个名为“behaviac.bb.xml”的文件，如下图所示：</p>
<p><img class="aligncenter" src="/img/tutorials/tutorial3/bbFile.png" alt="" /></p>
<p>后文我们将介绍，这个“behaviac.bb.xml”文件也会跟其他行为树源文件一并导出给运行时库。</p>
]]></content:encoded>
					
					<wfw:commentRss>/tutorial3_3_meta_edit/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>快速原型设计</title>
		<link>/tutorial3_4_prototype/</link>
					<comments>/tutorial3_4_prototype/#respond</comments>
		
		<dc:creator><![CDATA[admin]]></dc:creator>
		<pubDate>Fri, 13 May 2016 02:20:43 +0000</pubDate>
				<category><![CDATA[3.5]]></category>
		<category><![CDATA[编辑器]]></category>
		<guid isPermaLink="false">/?p=271</guid>

					<description><![CDATA[本文主要介绍在不需要程序员编写任何代码的前提下，策划如何在编辑器中快速开发行为树原型。 1 新建工作区 打开编辑器，点击菜单项“文件”-&#62;“新建工作区”新<a class="moretag" href="/tutorial3_4_prototype/">Read More...</a>]]></description>
										<content:encoded><![CDATA[<p id="section">本文主要介绍在不需要程序员编写任何代码的前提下，策划如何在编辑器中快速开发行为树原型。</p>
<h3 id="section-1"><span class="ez-toc-section" id="1">1 新建工作区</span></h3>
<p>打开编辑器，点击菜单项“文件”-&gt;“新建工作区”新建一个自己的工作区，如下图所示：</p>
<p><img src="/img/tutorials/tutorial3/newWorkspace.png" alt="" /></p>
<p>图1.1 新建工作区</p>
<p>暂不设置“元数据位置”，表示没有从运行时端导出任何元信息文件，元信息都会在编辑器中创建出来。</p>
<p>点击确认，创建完之后，整个编辑器几乎是空的，如下图所示：</p>
<p><img src="/img/tutorials/tutorial3/emptyEditor.png" alt="" /></p>
<p>图1.2 初始的编辑器</p>
<h3 id="section-2"><span class="ez-toc-section" id="2">2 新建行为树</span></h3>
<p>从工具栏中点击“新建行为树”按钮，开始创建我们的第一棵行为树，如下图所示：</p>
<p><img src="/img/tutorials/tutorial3/newBehavior.png" alt="" /></p>
<p>图2.1 新建行为树</p>
<p>创建后，将这棵行为树命名为“first_behavior”，如下图所示：</p>
<p><img src="/img/tutorials/tutorial3/firstBehavior.png" alt="" /></p>
<p>图2.2 第一棵行为树</p>
<p>从图2.2中可以看出这棵行为树只有一个根节点，鼠标点击该根节点后，可以看到它的Agent类型只有一个<code class="highlighter-rouge">behaviac::Agent</code>可以选择，但是不要选它，如下图所示：</p>
<p><img src="/img/tutorials/tutorial3/rootAgentType.png" alt="" /></p>
<p>图2.3 根节点的Agent类型</p>
<h3 id="agent"><span class="ez-toc-section" id="3_Agent">3 新建自定义的Agent子类及其属性和方法</span></h3>
<p>为了让行为树可以描述一个Agent类型，首先需要创建一个我们的Agent子类，通过菜单项“视图”-&gt;“元信息浏览”（或通过快捷键Ctrl+M）打开元信息浏览器，如下图所示：</p>
<p><img src="/img/tutorials/tutorial3/metaBrowser.png" alt="" /></p>
<p>图3.1 元信息浏览器</p>
<p>点击元信息浏览器右上角的“新建”按钮，开始创建我们的第一个Agent子类，命名为<code class="highlighter-rouge">FirstAgent</code>，如下图所示：</p>
<p><img src="/img/tutorials/tutorial3/newAgent.png" alt="" /></p>
<p>图3.2 新建Agent子类</p>
<p>从上图可以看出，<code class="highlighter-rouge">FirstAgent</code>类没有任何的成员属性和方法，我们接着为其添加属性和方法。</p>
<p>点击元信息浏览器中间靠右的“新建”按钮，为<code class="highlighter-rouge">FirstAgent</code>类添加第一个成员属性，如下图所示：</p>
<p><img src="/img/tutorials/tutorial3/createProperty.png" alt="" /></p>
<p>图3.3 开始添加成员属性</p>
<p>为这个属性命名为<code class="highlighter-rouge">FirstProperty</code>，并设置为int类型，如下图所示：</p>
<p><img src="/img/tutorials/tutorial3/createFirstProperty.png" alt="" /></p>
<p>图3.4 新建成员属性</p>
<p>创建完之后，我们可以看到，<code class="highlighter-rouge">FirstAgent</code>类已经有了第一个成员属性<code class="highlighter-rouge">FirstProperty</code>，如下图所示：</p>
<p><img src="/img/tutorials/tutorial3/firstProperty.png" alt="" /></p>
<p>图3.5 第一个成员属性</p>
<p>类似的，在元信息浏览器中，选择“成员类型”为“Method”，为<code class="highlighter-rouge">FirstAgent</code>类添加第一个成员方法，如下图所示：</p>
<p><img src="/img/tutorials/tutorial3/createMethod.png" alt="" /></p>
<p>图3.6 新建成员方法</p>
<p>创建完之后，我们可以看到，<code class="highlighter-rouge">FirstAgent</code>类已经有了第一个成员方法<code class="highlighter-rouge">FirstMethod</code>，如下图所示：</p>
<p><img src="/img/tutorials/tutorial3/firstMethod.png" alt="" /></p>
<p>图3.7 第一个成员方法</p>
<p>这样，我们的第一个Agent子类（<code class="highlighter-rouge">FirstAgent</code>）就有了一个成员属性（<code class="highlighter-rouge">FirstProperty</code>）和一个成员方法（<code class="highlighter-rouge">FirstMethod</code>）。</p>
<p>在元信息浏览器上点击下面的“确认”按钮，关闭元信息浏览器，回到编辑器主视口，继续编辑之前创建的第一棵行为树。</p>
<h3 id="section-3"><span class="ez-toc-section" id="4">4 编辑行为树</span></h3>
<p>鼠标选中根节点，为其设置Agent类型，这时，我们可以看到有了<code class="highlighter-rouge">FirstProperty</code>可供选择，如下图所示：</p>
<p><img src="/img/tutorials/tutorial3/selectAgentType.png" alt="" /></p>
<p>图4.1 设置Agent类型</p>
<p>编辑该行为树，通过鼠标将左边的节点列表中的节点拖拽到主视口中，为该行为树添加一个序列节点、一个条件节点和一个动作节点，如下图所示：</p>
<p><img src="/img/tutorials/tutorial3/editBehavior.png" alt="" /></p>
<p>图4.2 为行为树添加节点</p>
<p>为条件节点选择刚才创建的属性<code class="highlighter-rouge">FirstProperty</code>，如下图所示：</p>
<p><img src="/img/tutorials/tutorial3/editCondition.png" alt="" /></p>
<p>图4.3 设置条件节点</p>
<p>为动作节点选择刚才创建的方法<code class="highlighter-rouge">FirstMethod</code>，如下图所示：</p>
<p><img src="/img/tutorials/tutorial3/editAction.png" alt="" /></p>
<p>图4.4 设置动作节点</p>
<p>这样，我们就编辑完了第一棵行为树。</p>
<p>注意，如果点击当前行为树主视图窗口右上角的“检查错误”按钮，如下图所示：</p>
<p><img src="/img/tutorials/tutorial3/checkError.png" alt="" /></p>
<p>图4.5 检查错误</p>
<p>检查当前行为树是否包含错误，将会弹出如下图所示的错误信息提示框：</p>
<p><img src="/img/tutorials/tutorial3/errorInfo.png" alt="" /></p>
<p>图4.6 错误信息提示框</p>
<p>如何消除该错误，请查看使用说明文档<a href="/docs/zh/references/action/">动作节点</a>。</p>
<h3 id="c"><span class="ez-toc-section" id="5_C">5 生成C++源码文件</span></h3>
<p>为了方便讨论，下面只介绍生成C++源码文件，生成C#源码文件的流程基本类似，也可以分别参考下面两篇文档：</p>
<ul>
<li><a href="/docs/zh/tutorials/tutorial4_2_export_cpp/">导出和使用C++行为树</a></li>
<li><a href="/docs/zh/tutorials/tutorial4_3_export_cs/">导出和使用C#行为树</a></li>
</ul>
<p>开始导出C++源码文件，点击工具栏中的“导出行为树”按钮，如下图所示：</p>
<p><img src="/img/tutorials/tutorial3/startExportingBehaviors.png" alt="" /></p>
<p>图5.1 开始导出C++源码文件</p>
<p>弹出导出行为树设置窗口，我们看到“first_behavior”是一棵“有错误的行为树”，暂时忽略这个错误，直接选择下面的“导出设置”，只选择“C++ Behavior Export”，如下图所示：</p>
<p><img src="/img/tutorials/tutorial3/exportBehaviors.png" alt="" /></p>
<p>图5.2 导出C++源码文件</p>
<p>点击“C++ Behavior Export”最右侧的“…”按钮，弹出如下图所示的配置窗口：</p>
<p><img src="/img/tutorials/tutorial3/exportCppSettings.png" alt="" /></p>
<p>图5.3 导出C++源码文件设置</p>
<p>在上图中，暂时不用修改任何设置，只需使用默认值，直接点击“确认”按钮，回到图5.2中的导出行为树窗口，点击“导出”按钮。</p>
<p>导出结束后，在工作区设置的导出路径（本文示例中的导出路径是“D:\test\exported”）中，会生成“behaviac_generated”文件夹，里面又有“types”文件夹，可以看到包含了“FirstAgent.h”和“FirstAgent.cpp”文件。</p>
<p>这两个文件正是编辑器为运行时自动生成FirstAgent类的源码文件，需要程序员接着实现该类的其他属性和方法逻辑等代码，并添加进自己的游戏项目中去。</p>
<p>“FirstAgent.h”文件内容如下所示：</p>
<div class="highlighter-rouge">
<pre class="highlight"><code>
<span class="c1">// ---------------------------------------------------------------------
// This agent file is auto-generated by behaviac designer, but you should
// implement the methods of the agent class if necessary!
// ---------------------------------------------------------------------
</span>
<span class="cp">#ifndef BEHAVIAC_FIRSTAGENT_H
#define BEHAVIAC_FIRSTAGENT_H
</span>
<span class="cp">#include "behaviac/behaviac.h"
</span>
<span class="k">class</span> <span class="nc">FirstAgent</span> <span class="o">:</span> <span class="k">public</span> <span class="n">behaviac</span><span class="o">::</span><span class="n">Agent</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
	<span class="n">FirstAgent</span><span class="p">();</span>
	<span class="k">virtual</span> <span class="o">~</span><span class="n">FirstAgent</span><span class="p">();</span>

	<span class="n">DECLARE_BEHAVIAC_AGENT</span><span class="p">(</span><span class="n">FirstAgent</span><span class="p">,</span> <span class="n">behaviac</span><span class="o">::</span><span class="n">Agent</span><span class="p">)</span>

<span class="k">public</span><span class="o">:</span>
	<span class="kt">int</span> <span class="n">FirstProperty</span><span class="p">;</span>

<span class="k">public</span><span class="o">:</span>
	<span class="kt">int</span> <span class="n">FirstMethod</span><span class="p">();</span>

<span class="p">};</span>

<span class="n">BEHAVIAC_DECLARE_TYPE_VECTOR_HANDLER</span><span class="p">(</span><span class="n">FirstAgent</span><span class="o">*</span><span class="p">);</span>

<span class="cp">#endif
</span>
</code></pre>
</div>
<p>“FirstAgent.cpp”文件内容如下所示：</p>
<div class="highlighter-rouge">
<pre class="highlight"><code>
<span class="c1">// ---------------------------------------------------------------------
// This agent file is auto-generated by behaviac designer, but you should
// implement the methods of the agent class if necessary!
// ---------------------------------------------------------------------
</span>
<span class="cp">#include "FirstAgent.h"
</span>
<span class="n">FirstAgent</span><span class="o">::</span><span class="n">FirstAgent</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">FirstProperty</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">FirstAgent</span><span class="o">::~</span><span class="n">FirstAgent</span><span class="p">()</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="n">BEGIN_PROPERTIES_DESCRIPTION</span><span class="p">(</span><span class="n">FirstAgent</span><span class="p">)</span>
<span class="p">{</span>
	<span class="c1">// CLASS_DISPLAYNAME(L"FirstAgent");
</span>	<span class="c1">// CLASS_DESC(L"");
</span>
	<span class="n">REGISTER_PROPERTY</span><span class="p">(</span><span class="n">FirstProperty</span><span class="p">);</span>

	<span class="n">REGISTER_METHOD</span><span class="p">(</span><span class="n">FirstMethod</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">END_PROPERTIES_DESCRIPTION</span><span class="p">()</span>

<span class="kt">int</span> <span class="n">FirstAgent</span><span class="o">::</span><span class="n">FirstMethod</span><span class="p">()</span>
<span class="p">{</span>
	<span class="c1">// Write your logic codes here.
</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</code></pre>
</div>
<h3 id="section-4"><span class="ez-toc-section" id="6">6 导出元信息文件</span></h3>
<p>将上面自动生成的“FirstAgent.h”和“FirstAgent.cpp”文件添加到自己的游戏项目中，并参考<a href="/docs/zh/tutorials/tutorial3_1_meta_cpp_register/">C++元信息的注册和导出</a>的做法导出元信息文件。</p>
<p>这里我们假设生成的元信息文件名为“firstagent.xml”，并放在meta文件夹中，meta文件夹放在这个工作区的路径中，如下图所示：</p>
<p><img src="/img/tutorials/tutorial3/metaPath.png" alt="" /></p>
<p>图6.1 元信息文件</p>
<p>回到编辑器中，点击菜单项“文件”-&gt;“编辑工作区”，为当前的工作区设置“元信息位置”，如下图所示：</p>
<p><img src="/img/tutorials/tutorial3/editWorkspaceMeta.png" alt="" /></p>
<p>图6.2 设置元信息位置</p>
<p>点击工具栏中的“重新加载”按钮，重新加载整个工作区，如下图所示：</p>
<p><img src="/img/tutorials/tutorial3/refreshWorkspace.png" alt="" /></p>
<p>图6.3 重新加载工作区</p>
<p>重新加载整个工作区之后，再次打开我们的第一棵行为树“first_behavior”，然后点击主视口中右上角的“检查错误”按钮，如下图所示：</p>
<p><img src="/img/tutorials/tutorial3/startCheckingErrors.png" alt="" /></p>
<p>图6.4 检查错误</p>
<p>这个时候，我们发现该行为树已经没有任何错误，可以导出了，这里我们只导出XML行为树，如下图所示：</p>
<p><img src="/img/tutorials/tutorial3/exportXMLBehaviors.png" alt="" /></p>
<p>图6.5 开始导出XML行为树</p>
<p>导出结束后，在工作区的导出路径下，导出了我们的第一棵行为树，如下图所示：</p>
<p><img src="/img/tutorials/tutorial3/xmlBehavior.png" alt="" /></p>
<p>图6.6 第一棵导出的XML行为树</p>
<p>有了导出的行为树，就可以参考<a href="/docs/zh/tutorials/tutorial14_cpp_workflow/">C++运行时端的使用上手</a>的做法开始使用运行时库。</p>
<h3 id="section-5"><span class="ez-toc-section" id="7">7 导出行为树</span></h3>
<p>需要注意的是，<strong>如果行为树使用到了这里在编辑器里创建的’自定义方法’的话，那个行为树是不允许导出的</strong>。因为运行时还没有实现那个方法，如果运行时试图运行那个行为树的话，由于那个方法没有定义，没办法处理。</p>
<p>这种情况下，编辑器只是作为‘设计’工具。</p>
]]></content:encoded>
					
					<wfw:commentRss>/tutorial3_4_prototype/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>自定义枚举</title>
		<link>/tutorial7_customenum/</link>
					<comments>/tutorial7_customenum/#respond</comments>
		
		<dc:creator><![CDATA[admin]]></dc:creator>
		<pubDate>Fri, 13 May 2016 02:34:01 +0000</pubDate>
				<category><![CDATA[3.5]]></category>
		<category><![CDATA[扩展]]></category>
		<category><![CDATA[C++]]></category>
		<category><![CDATA[运行时]]></category>
		<guid isPermaLink="false">/?p=294</guid>

					<description><![CDATA[类似于自定义类，在.h文件中，任意编写一个自定义枚举类型，然后通过宏DECLARE_BEHAVIAC_ENUM声明该枚举类型。需要注意的是，宏DECLARE_B<a class="moretag" href="/tutorial7_customenum/">Read More...</a>]]></description>
										<content:encoded><![CDATA[<ul>
<li>类似于自定义类，在.h文件中，任意编写一个自定义枚举类型，然后通过宏DECLARE_BEHAVIAC_ENUM声明该枚举类型。需要注意的是，宏DECLARE_BEHAVIAC_ENUM必须定义在全局的namespace里，即放在任何命名空间之外。<br />
如下代码样例所示：</li>
</ul>
<div class="highlighter-rouge">
<pre class="highlight"><code><span class="k">namespace</span> <span class="n">TNS</span>
<span class="p">{
</span><span class="k">    namespace</span> <span class="n">NE</span>
<span class="p">    {</span>
<span class="k">        namespace</span> <span class="n">NAT</span>
	<span class="p">{</span>
            <span class="k">enum</span> <span class="n">eColor</span>
	    <span class="p">{</span>
	        <span class="n">RED</span><span class="p">,</span>
                <span class="n">GREEN</span><span class="p">,</span>
                <span class="n">BLUE</span><span class="p">,</span>
                <span class="n">YELLOW</span><span class="p">,</span>
                <span class="n">WHITE</span><span class="p">,</span>
	    <span class="p">};</span>
	<span class="p">}</span>
<span class="p">    }</span>
<span class="p">}</span>

<span class="n">DECLARE_BEHAVIAC_ENUM</span><span class="p">(</span><span class="n">TNS</span><span class="o">::</span><span class="n">NE</span><span class="o">::</span><span class="n">NAT</span><span class="o">::</span><span class="n">eColor</span><span class="p">,</span> <span class="n">eColor</span><span class="p">);</span>
</code></pre>
</div>
<ul>
<li>在.cpp文件中，通过一系列宏注册该枚举自身的描述及其枚举值：
<ul>
<li>宏BEGIN_ENUM_DESCRIPTION和END_ENUM_DESCRIPTION表示枚举信息注册的开始和结束。</li>
<li>可选的宏ENUMCLASS_DISPLAY_INFO用于注册枚举自身的显示名和描述。</li>
<li>宏DEFINE_ENUM_VALUE用于注册枚举的值，可以通过.DISPLAYNAME的追加方式为值添加显示名，通过.DESC的追加方式为值添加描述。<br />
如下代码样例所示：</li>
</ul>
</li>
</ul>
<div class="highlighter-rouge">
<pre class="highlight"><code><span class="n">BEGIN_ENUM_DESCRIPTION</span><span class="p">(</span><span class="n">TNS</span><span class="o">::</span><span class="n">NE</span><span class="o">::</span><span class="n">NAT</span><span class="o">::</span><span class="n">eColor</span><span class="p">,</span> <span class="n">eColor</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">ENUMCLASS_DISPLAY_INFO</span><span class="p">(</span><span class="s">L"色彩枚举"</span><span class="p">,</span> <span class="s">L"eColor是用于测试枚举使用的类型"</span><span class="p">);</span>

    <span class="n">DEFINE_ENUM_VALUE</span><span class="p">(</span><span class="n">TNS</span><span class="o">::</span><span class="n">NE</span><span class="o">::</span><span class="n">NAT</span><span class="o">::</span><span class="n">RED</span><span class="p">,</span> <span class="s">"RED"</span><span class="p">).</span><span class="n">DISPLAY_INFO</span><span class="p">(</span><span class="s">L"红色"</span><span class="p">,</span> <span class="s">L"激进"</span><span class="p">);</span>
    <span class="n">DEFINE_ENUM_VALUE</span><span class="p">(</span><span class="n">TNS</span><span class="o">::</span><span class="n">NE</span><span class="o">::</span><span class="n">NAT</span><span class="o">::</span><span class="n">GREEN</span><span class="p">,</span> <span class="s">"GREEN"</span><span class="p">);</span>
    <span class="n">DEFINE_ENUM_VALUE</span><span class="p">(</span><span class="n">TNS</span><span class="o">::</span><span class="n">NE</span><span class="o">::</span><span class="n">NAT</span><span class="o">::</span><span class="n">BLUE</span><span class="p">,</span> <span class="s">"BLUE"</span><span class="p">);</span>
    <span class="n">DEFINE_ENUM_VALUE</span><span class="p">(</span><span class="n">TNS</span><span class="o">::</span><span class="n">NE</span><span class="o">::</span><span class="n">NAT</span><span class="o">::</span><span class="n">YELLOW</span><span class="p">,</span> <span class="s">"YELLOW"</span><span class="p">);</span>
    <span class="n">DEFINE_ENUM_VALUE</span><span class="p">(</span><span class="n">TNS</span><span class="o">::</span><span class="n">NE</span><span class="o">::</span><span class="n">NAT</span><span class="o">::</span><span class="n">WHITE</span><span class="p">,</span> <span class="s">"WHITE"</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">END_ENUM_DESCRIPTION</span><span class="p">()</span>
</code></pre>
</div>
<ul>
<li>在初始化注册（Register）的部分需要加上如下的代码，反注册（UnRegister）的部分添加相应UnRegister的代码。注意这部分Register/UnRegister的代码不是必须的，如果该类型没有用作par或者没有用作条件比较，就可以不需要。</li>
</ul>
<div class="highlighter-rouge">
<pre class="highlight"><code><span class="n">behaviac</span><span class="o">::</span><span class="n">TypeRegister</span><span class="o">::</span><span class="n">Register</span><span class="o">&lt;</span> <span class="n">TNS</span><span class="o">::</span><span class="n">EnumTest</span> <span class="o">&gt;</span><span class="p">(</span><span class="s">" TNS::EnumTest "</span><span class="p">);</span>

<span class="n">behaviac</span><span class="o">::</span><span class="n">TypeRegister</span><span class="o">::</span><span class="n">UnRegister</span><span class="o">&lt;</span> <span class="n">TNS</span><span class="o">::</span><span class="n">EnumTest</span> <span class="o">&gt;</span><span class="p">(</span><span class="s">" TNS::EnumTest "</span><span class="p">);</span>
</code></pre>
</div>
<p>更多细节可以参考behaviac组件C++源码库中btunittest工程的<a href="#?https://github.com/Tencent/behaviac/blob/master/test/btunittest/Agent/UnitTestTypes.h">UnitTestTypes.h</a>文件中eColor结构体相关的代码。</p>
<hr />
<p><!--StartFragment --></p>
<div>声明的类型只用被使用过才会导出。所谓使用过是指：</div>
<div>1. 作为某Agent的成员</div>
<div>2. 作为某Agent成员函数的参数或返回值</div>
<div></div>
<div>如果只是声明了，但是没有被使用过，则不会被导出。</div>
]]></content:encoded>
					
					<wfw:commentRss>/tutorial7_customenum/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>自定义类或结构体</title>
		<link>/tutorial6_customtypes/</link>
					<comments>/tutorial6_customtypes/#comments</comments>
		
		<dc:creator><![CDATA[admin]]></dc:creator>
		<pubDate>Fri, 13 May 2016 02:32:53 +0000</pubDate>
				<category><![CDATA[3.5]]></category>
		<category><![CDATA[扩展]]></category>
		<category><![CDATA[运行时]]></category>
		<guid isPermaLink="false">/?p=292</guid>

					<description><![CDATA[在.h文件中，任意编写一个自定义的类或结构体，并用宏DECLARE_BEHAVIAC_STRUCT声明该类或者结构体为非虚类，如下代码所示： struct Ty<a class="moretag" href="/tutorial6_customtypes/">Read More...</a>]]></description>
										<content:encoded><![CDATA[<ul>
<li>在.h文件中，任意编写一个自定义的类或结构体，并用宏DECLARE_BEHAVIAC_STRUCT声明该类或者结构体为非虚类，如下代码所示：</li>
</ul>
<pre>struct TypeTest2_t
{
    int	  name;
    float weight;
    bool  bLive;

    DECLARE_BEHAVIAC_STRUCT(TypeTest2_t);
};</pre>
<p>上面的用法定义出来的TypeTest2_t在导出的元信息中为值类型（也即在导出的元信息中其值IsRefType为false），值类型可以在编辑器中设置其成员属性。与值类型对应的是引用类型，引用类型不会导出其成员属性，在编辑器中也不用配置其成员属性。</p>
<p>另外，宏DECLARE_BEHAVIAC_STRUCT也可以带2个参数，第一个参数为类型，第二个参数为true表示该类型用作为引用类型（也即导出元信息后其值IsRefType为true），否则不用第二个参数表示为值类型，如下代码所示：</p>
<pre>DECLARE_BEHAVIAC_STRUCT(TypeTest2_t, true);</pre>
<ul>
<li>在.cpp文件中，通过一系列宏注册该类或结构体自身的描述及其属性：</li>
</ul>
<pre>BEGIN_PROPERTIES_DESCRIPTION(TypeTest2_t)
{
    CLASS_DISPLAYNAME(L"测试结构体")
    CLASS_DESC(L"自定义结构体")

    REGISTER_PROPERTY(name);
    REGISTER_PROPERTY(weight).DISPLAYNAME(L”重量”);
    REGISTER_PROPERTY(bLive) .DISPLAYNAME(L”是否活着”).DESC(L”存活状态”);
}
END_PROPERTIES_DESCRIPTION()</pre>
<ul>
<li>在初始化注册（Register）的部分需要加上如下的代码，反注册（UnRegister）的部分添加相应UnRegister的代码。注意这部分Register/UnRegister的代码不是必须的，如果该类型没有用作par或者没有用作条件比较，就可以不需要。</li>
</ul>
<pre>behaviac::TypeRegister::Register&amp;amp;amp;amp;lt; TypeTest2_t &amp;amp;amp;amp;gt;(" TypeTest2_t ");

behaviac::TypeRegister::UnRegister&amp;amp;amp;amp;lt; TypeTest2_t &amp;amp;amp;amp;gt;(" TypeTest2_t ");</pre>
<p>更多细节可以参考behaviac组件C++源码库中btunittest工程的<a href="https://github.com/Tencent/behaviac/blob/master/test/btunittest/Others/reflectionunittest.cpp">reflectionunittest.cpp</a>文件中TypeTest2_t结构体相关的代码。</p>
]]></content:encoded>
					
					<wfw:commentRss>/tutorial6_customtypes/feed/</wfw:commentRss>
			<slash:comments>3</slash:comments>
		
		
			</item>
		<item>
		<title>扩展使用已有的类型</title>
		<link>/tutorial5_extendtypes/</link>
					<comments>/tutorial5_extendtypes/#respond</comments>
		
		<dc:creator><![CDATA[admin]]></dc:creator>
		<pubDate>Fri, 13 May 2016 02:32:11 +0000</pubDate>
				<category><![CDATA[3.5]]></category>
		<category><![CDATA[扩展]]></category>
		<category><![CDATA[运行时]]></category>
		<guid isPermaLink="false">/?p=290</guid>

					<description><![CDATA[在某些情况下，除了运行时库（C++）中提供支持的一些基本类型（bool、short、int、float等）之外，behaviac还支持扩展使用已有的或者用户自定<a class="moretag" href="/tutorial5_extendtypes/">Read More...</a>]]></description>
										<content:encoded><![CDATA[<p>在某些情况下，除了运行时库（C++）中提供支持的一些基本类型（bool、short、int、float等）之外，behaviac还支持扩展使用已有的或者用户自定义的类、结构体和枚举类型。<br />
这里有两种情况，其处理方式是不同的：</p>
<ul>
<li>有些类型是程序中本来就有的，该类型可能是某个第三方库中提供的，但这些类型是不方便随意修改的。</li>
<li>另外一些可以随便修改的类型，请参考<a href="/docs/zh/tutorials/tutorial6_customtypes/">自定义类或结构体</a>。</li>
</ul>
<h3 id="section">字符串和数组类型</h3>
<p>需要注意的是，behaviac组件为了支持C++的反射系统，对字符串和数组类型有如下要求：</p>
<ul>
<li>字符串：不要使用std::string，需要使用behaviac::string，因为behaviac::string使用了自定义的allocator，可以对内存的使用进行统一的管理。</li>
<li>数组：不要使用std::vector，需要使用behaviac::vector。</li>
</ul>
<h3 id="char">char类型</h3>
<p>此外，需要对char、signed char和unsigned char做出一些必要的说明：</p>
<ul>
<li>在C++中，char、signed char和unsigned char是三个不同的类型。</li>
<li>在编辑器中，分别对应char、sbyte、ubyte。</li>
<li>对于C#，char、sbyte和byte是基本类型，分别对应编辑器中的char、sbyte和ubyte。</li>
</ul>
<h3 id="section-1">扩展使用已有的类型</h3>
<p>对于已有的不能修改源码的类型，需要按照如下步骤进行扩展：</p>
<ul>
<li>在.h文件中，通过宏BEHAVIAC_EXTEND_EXISTING_TYPE特化某个需要的类型。<br />
如下代码样例所示（假设TestNS::Float2是某个第三方库中的类型，需要用到但不能修改它）：</li>
</ul>
<div class="highlighter-rouge">
<pre class="highlight"><code><span class="n">BEHAVIAC_EXTEND_EXISTING_TYPE</span><span class="p">(</span><span class="n">myFloat2</span><span class="p">,</span> <span class="n">TestNS</span><span class="o">::</span><span class="n">Float2</span><span class="p">);</span>
</code></pre>
</div>
<ul>
<li>定义一个“相似”的struct（myFloat2），该struct的作用是用来定义那个已存在的类的成员，以便behaviac能够访问该类。</li>
<li>通过DECLARE_BEHAVIAC_STRUCT的第二个参数isRefType为true或false表示该类型是否为引用类型，如下代码所示。</li>
</ul>
<div class="highlighter-rouge">
<pre class="highlight"><code><span class="k">struct</span> <span class="n">myFloat2</span>
<span class="p">{</span>
    <span class="kt">float</span> <span class="n">x</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">y</span><span class="p">;
</span>
    <span class="n">DECLARE_BEHAVIAC_STRUCT</span> <span class="p">(</span><span class="n">myFloat2</span><span class="p">,</span> <span class="nb">false</span><span class="p">);
</span>
    <span class="n">myFloat2</span><span class="p">()</span>
<span class="p">    {</span>
<span class="p">    }
</span>
<span class="n">    myFloat2</span><span class="p">(</span><span class="k">const</span> <span class="n">TestNS</span><span class="o">::</span><span class="n">Float2</span><span class="o">&amp;</span> <span class="n">v</span><span class="p">)</span> <span class="o">:</span> <span class="n">x</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">x</span><span class="p">),</span> <span class="n">y</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">y</span><span class="p">)</span>
<span class="p">    {</span>
<span class="p">    }</span>
<span class="p">};</span>
</code></pre>
</div>
<ul>
<li>在命名空间StringUtils的嵌套子空间Private中实现该类型的ToString()和FromString()函数。注意myFloat2中需要实现相应的转换构造函数（myFloat2(const TestNS::Float2&amp; v)），如下代码样例所示：</li>
</ul>
<div class="highlighter-rouge">
<pre class="highlight"><code><span class="k">namespace</span> <span class="n">behaviac</span>
<span class="p">{</span>
    <span class="c1">// ValueToString &amp; ValueFromString
</span>    <span class="k">namespace</span> <span class="n">StringUtils</span>
    <span class="p">{</span>
        <span class="k">namespace</span> <span class="n">Private</span>
        <span class="p">{</span>
            <span class="k">template</span><span class="o">&lt;&gt;</span>
            <span class="kr">inline</span> <span class="n">behaviac</span><span class="o">::</span><span class="n">string</span> <span class="n">ToString</span><span class="p">(</span><span class="k">const</span> <span class="n">TestNS</span><span class="o">::</span><span class="n">Float2</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="c1">//myFloat2::ToString is defined by DECLARE_BEHAVIAC_STRUCT(myFloat2)
</span>                <span class="n">myFloat2</span> <span class="n">temp</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
                <span class="k">return</span> <span class="n">temp</span><span class="p">.</span><span class="n">ToString</span><span class="p">();</span>
            <span class="p">}</span>

            <span class="k">template</span><span class="o">&lt;&gt;</span>
            <span class="kr">inline</span> <span class="n">bool</span> <span class="n">FromString</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">str</span><span class="p">,</span> <span class="n">TestNS</span><span class="o">::</span><span class="n">Float2</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">myFloat2</span> <span class="n">temp</span><span class="p">;</span>

                <span class="c1">//myFloat2::FromString is defined by DECLARE_BEHAVIAC_STRUCT(myFloat2)
</span>                <span class="k">if</span> <span class="p">(</span><span class="n">temp</span><span class="p">.</span><span class="n">FromString</span><span class="p">(</span><span class="n">str</span><span class="p">))</span>
                <span class="p">{</span>
                    <span class="n">val</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">temp</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
                    <span class="n">val</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">temp</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
                    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
                <span class="p">}</span>

                <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>
<ul>
<li>实现该类型的模板函数SwapByteTempl()，注意该函数不能放在任何命名空间（namespace）中，如下代码样例所示：</li>
</ul>
<div class="highlighter-rouge">
<pre class="highlight"><code><span class="k">template</span><span class="o">&lt;</span> <span class="k">typename</span> <span class="n">SWAPPER</span> <span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">void</span> <span class="n">SwapByteTempl</span><span class="p">(</span><span class="n">TestNS</span><span class="o">::</span><span class="n">Float2</span><span class="o">&amp;</span> <span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
<span class="n">    SwapByteTempl</span><span class="o">&lt;</span> <span class="n">SWAPPER</span> <span class="o">&gt;</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">x</span><span class="p">);</span>
<span class="n">    SwapByteTempl</span><span class="o">&lt;</span> <span class="n">SWAPPER</span> <span class="o">&gt;</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
</div>
<ul>
<li>在命名空间behaviac的嵌套子空间Details中实现该类型的Equal()模板函数，如下代码样例所示：</li>
</ul>
<div class="highlighter-rouge">
<pre class="highlight"><code><span class="k">namespace</span> <span class="n">behaviac</span>
<span class="p">{
</span><span class="k">    namespace</span> <span class="n">Details</span>
    <span class="p">{</span>
        <span class="k">template</span><span class="o">&lt;&gt;</span>
	<span class="kr">inline</span> <span class="n">bool</span> <span class="n">Equal</span><span class="p">(</span><span class="k">const</span> <span class="n">TestNS</span><span class="o">::</span><span class="n">Float2</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="k">const</span> <span class="n">TestNS</span><span class="o">::</span><span class="n">Float2</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span>
        <span class="p">{</span>
	    <span class="k">return</span> <span class="n">Tag</span><span class="o">::</span><span class="n">IsEqualWithEpsilon</span><span class="p">(</span><span class="n">lhs</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">rhs</span><span class="p">.</span><span class="n">x</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">Tag</span><span class="o">::</span><span class="n">IsEqualWithEpsilon</span><span class="p">(</span><span class="n">lhs</span><span class="p">.</span><span class="n">y</span><span class="p">,</span> <span class="n">rhs</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">    }</span>
<span class="p">}</span>
</code></pre>
</div>
<ul>
<li>在初始化注册（Register）的部分需要加上如下的代码，反注册（UnRegister）的部分添加相应UnRegister的代码。注意：这部分Register/UnRegister的代码不是必须的，如果该类型没有用作par或者没有用作条件比较，就可以不需要。</li>
</ul>
<div class="highlighter-rouge">
<pre class="highlight"><code><span class="n">behaviac</span><span class="o">::</span><span class="n">TypeRegister</span><span class="o">::</span><span class="n">Register</span><span class="o">&lt;</span><span class="n">TestNS</span><span class="o">::</span><span class="n">Float2</span><span class="o">&gt;</span><span class="p">(</span><span class="s">"TestNS::Float2"</span><span class="p">);</span>

<span class="n">behaviac</span><span class="o">::</span><span class="n">TypeRegister</span><span class="o">::</span><span class="n">UnRegister</span><span class="o">&lt;</span><span class="n">TestNS</span><span class="o">::</span><span class="n">Float2</span><span class="o">&gt;</span><span class="p">(</span><span class="s">"TestNS::Float2"</span><span class="p">);</span>
</code></pre>
</div>
<p>详细代码可以参考behaviac组件C++源码库中btunittest工程的<a href="https://github.com/Tencent/behaviac/blob/master/test/btunittest/ext/extendstruct.h">extendstruct.h</a>文件。</p>
]]></content:encoded>
					
					<wfw:commentRss>/tutorial5_extendtypes/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
	</channel>
</rss>
